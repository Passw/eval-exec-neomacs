//! Process/subprocess management for the Elisp VM.
//!
//! Provides process abstractions: creating, killing, querying, and
//! communicating with subprocesses.  `start-process` creates a tracked
//! record; `call-process` and `shell-command-to-string` run real OS
//! commands via `std::process::Command`.

use std::collections::HashMap;
#[cfg(not(target_os = "windows"))]
use std::ffi::CStr;
use std::ffi::CString;
use std::fs::OpenOptions;
use std::process::{Command, Stdio};
#[cfg(target_os = "linux")]
use std::ptr;
use std::time::{SystemTime, UNIX_EPOCH};

use super::error::{signal, EvalResult, Flow};
use super::intern::resolve_sym;
use super::value::{StringTextPropertyRun, Value, list_to_vec, read_cons, with_heap};
use crate::gc::GcTrace;

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

/// Unique identifier for a process.
pub type ProcessId = u64;

/// Status of a managed process.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ProcessStatus {
    Run,
    Stop,
    Exit(i32),
    Signal(i32),
}

/// Process family used by compatibility helpers.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ProcessKind {
    Real,
    Network,
    Pipe,
    Serial,
}

/// A tracked process record.
#[derive(Clone, Debug)]
pub struct Process {
    pub id: ProcessId,
    pub name: String,
    pub command: String,
    pub args: Vec<String>,
    pub kind: ProcessKind,
    pub status: ProcessStatus,
    pub buffer_name: Option<String>,
    /// Queued input (sent via `process-send-string`).
    pub stdin_queue: String,
    /// Captured stdout.
    pub stdout: String,
    /// Captured stderr.
    pub stderr: String,
    /// Query-on-exit flag state.
    pub query_on_exit_flag: bool,
    /// Process filter callback (or default marker symbol).
    pub filter: Value,
    /// Process sentinel callback (or default marker symbol).
    pub sentinel: Value,
    /// Process plist state.
    pub plist: Value,
    /// Current decoding coding-system.
    pub coding_decode: Value,
    /// Current encoding coding-system.
    pub coding_encode: Value,
    /// Inherit-coding-system flag.
    pub inherit_coding_system_flag: bool,
    /// Attached thread object.
    pub thread: Value,
    /// Last process-window-size columns value.
    pub window_cols: Option<i64>,
    /// Last process-window-size rows value.
    pub window_rows: Option<i64>,
    /// Terminal name reported by `process-tty-name`, when this process uses a tty.
    pub tty_name: Option<String>,
    /// Whether stdin is tty-backed for this process.
    pub tty_stdin: bool,
    /// Whether stdout is tty-backed for this process.
    pub tty_stdout: bool,
    /// Whether stderr is tty-backed for this process.
    pub tty_stderr: bool,
}

/// Manages the set of live processes.
#[derive(Clone, Debug)]
pub struct ProcessManager {
    processes: HashMap<ProcessId, Process>,
    deleted_processes: HashMap<ProcessId, Process>,
    next_id: ProcessId,
    /// Environment variable overrides (for `setenv`/`getenv`).
    env_overrides: HashMap<String, Option<String>>,
}

impl Default for ProcessManager {
    fn default() -> Self {
        Self::new()
    }
}

impl ProcessManager {
    pub fn new() -> Self {
        Self {
            processes: HashMap::new(),
            deleted_processes: HashMap::new(),
            next_id: 1,
            env_overrides: HashMap::new(),
        }
    }

    /// Create a new process record.  Returns the process id.
    pub fn create_process(
        &mut self,
        name: String,
        buffer_name: Option<String>,
        command: String,
        args: Vec<String>,
    ) -> ProcessId {
        self.create_process_with_kind(name, buffer_name, command, args, ProcessKind::Real)
    }

    /// Create a new process record with an explicit process kind.
    pub fn create_process_with_kind(
        &mut self,
        name: String,
        buffer_name: Option<String>,
        command: String,
        args: Vec<String>,
        kind: ProcessKind,
    ) -> ProcessId {
        let id = self.next_id;
        self.next_id += 1;
        let (tty_name, tty_stdin, tty_stdout, tty_stderr) = match kind {
            ProcessKind::Real => {
                let tty_name = Some(default_process_tty_name());
                (tty_name, true, true, true)
            }
            ProcessKind::Network | ProcessKind::Pipe | ProcessKind::Serial => {
                (None, false, false, false)
            }
        };
        let proc = Process {
            id,
            name,
            command,
            args,
            kind,
            status: ProcessStatus::Run,
            buffer_name,
            stdin_queue: String::new(),
            stdout: String::new(),
            stderr: String::new(),
            query_on_exit_flag: true,
            filter: Value::symbol(DEFAULT_PROCESS_FILTER_SYMBOL),
            sentinel: Value::symbol(DEFAULT_PROCESS_SENTINEL_SYMBOL),
            plist: Value::Nil,
            coding_decode: Value::symbol("utf-8-unix"),
            coding_encode: Value::symbol("utf-8-unix"),
            inherit_coding_system_flag: false,
            thread: Value::Nil,
            window_cols: None,
            window_rows: None,
            tty_name,
            tty_stdin,
            tty_stdout,
            tty_stderr,
        };
        self.processes.insert(id, proc);
        id
    }

    /// Kill (remove) a process by id.  Returns true if found.
    pub fn kill_process(&mut self, id: ProcessId) -> bool {
        if let Some(proc) = self.processes.get_mut(&id) {
            proc.status = ProcessStatus::Signal(9);
            true
        } else {
            false
        }
    }

    /// Delete a process entirely.
    pub fn delete_process(&mut self, id: ProcessId) -> bool {
        if let Some(mut proc) = self.processes.remove(&id) {
            proc.status = ProcessStatus::Signal(9);
            self.deleted_processes.insert(id, proc);
            true
        } else {
            self.deleted_processes.contains_key(&id)
        }
    }

    /// Get process status.
    pub fn process_status(&self, id: ProcessId) -> Option<&ProcessStatus> {
        self.processes.get(&id).map(|p| &p.status)
    }

    /// Get process status for both live and stale process handles.
    pub fn process_status_any(&self, id: ProcessId) -> Option<&ProcessStatus> {
        self.processes
            .get(&id)
            .map(|p| &p.status)
            .or_else(|| self.deleted_processes.get(&id).map(|p| &p.status))
    }

    /// Get a process by id.
    pub fn get(&self, id: ProcessId) -> Option<&Process> {
        self.processes.get(&id)
    }

    /// Get a process by id from either live or stale process tables.
    pub fn get_any(&self, id: ProcessId) -> Option<&Process> {
        self.processes.get(&id).or_else(|| self.deleted_processes.get(&id))
    }

    /// Get a mutable process by id.
    pub fn get_mut(&mut self, id: ProcessId) -> Option<&mut Process> {
        self.processes.get_mut(&id)
    }

    /// Get a mutable process by id from either live or stale process tables.
    pub fn get_any_mut(&mut self, id: ProcessId) -> Option<&mut Process> {
        if self.processes.contains_key(&id) {
            self.processes.get_mut(&id)
        } else {
            self.deleted_processes.get_mut(&id)
        }
    }

    /// List all process ids.
    pub fn list_processes(&self) -> Vec<ProcessId> {
        self.processes.keys().copied().collect()
    }

    /// Returns true if this id has been allocated at least once.
    pub fn was_issued_id(&self, id: ProcessId) -> bool {
        id > 0 && id < self.next_id
    }

    /// Find a process by name.
    pub fn find_by_name(&self, name: &str) -> Option<ProcessId> {
        self.processes
            .values()
            .find(|p| p.name == name)
            .map(|p| p.id)
    }

    /// Find a process associated with BUFFER-NAME.
    pub fn find_by_buffer_name(&self, buffer_name: &str) -> Option<ProcessId> {
        self.processes
            .values()
            .find(|p| p.buffer_name.as_deref() == Some(buffer_name))
            .map(|p| p.id)
    }

    /// Queue input for a process.
    pub fn send_input(&mut self, id: ProcessId, input: &str) -> bool {
        if let Some(proc) = self.processes.get_mut(&id) {
            proc.stdin_queue.push_str(input);
            true
        } else {
            false
        }
    }

    /// Get stdout output from a process.
    pub fn get_output(&self, id: ProcessId) -> Option<&str> {
        self.processes.get(&id).map(|p| p.stdout.as_str())
    }

    /// Get an environment variable (checking overrides first, then OS).
    pub fn getenv(&self, name: &str) -> Option<String> {
        if let Some(override_val) = self.env_overrides.get(name) {
            return override_val.clone();
        }
        std::env::var(name).ok()
    }

    /// Set an environment variable override.  If value is None, unset it.
    pub fn setenv(&mut self, name: String, value: Option<String>) {
        self.env_overrides.insert(name, value);
    }
}

const DEFAULT_PROCESS_FILTER_SYMBOL: &str = "internal-default-process-filter";
const DEFAULT_PROCESS_SENTINEL_SYMBOL: &str = "internal-default-process-sentinel";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn expect_args(name: &str, args: &[Value], n: usize) -> Result<(), Flow> {
    if args.len() != n {
        Err(signal(
            "wrong-number-of-arguments",
            vec![Value::symbol(name), Value::Int(args.len() as i64)],
        ))
    } else {
        Ok(())
    }
}

fn expect_min_args(name: &str, args: &[Value], min: usize) -> Result<(), Flow> {
    if args.len() < min {
        Err(signal(
            "wrong-number-of-arguments",
            vec![Value::symbol(name), Value::Int(args.len() as i64)],
        ))
    } else {
        Ok(())
    }
}

fn expect_string(value: &Value) -> Result<String, Flow> {
    match value {
        Value::Str(s) => Ok(with_heap(|h| h.get_string(*s).clone())),
        Value::Symbol(id) => Ok(resolve_sym(*id).to_owned()),
        Value::Nil => Ok("nil".to_string()),
        Value::True => Ok("t".to_string()),
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("stringp"), *other],
        )),
    }
}

fn expect_sequence(value: &Value) -> Result<(), Flow> {
    if matches!(
        value,
        Value::Nil | Value::Cons(_) | Value::Vector(_) | Value::Str(_)
    ) {
        Ok(())
    } else {
        Err(signal_wrong_type_sequence(*value))
    }
}

fn expect_list(value: &Value) -> Result<(), Flow> {
    if value.is_list() {
        Ok(())
    } else {
        Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("listp"), *value],
        ))
    }
}

fn signal_wrong_type_sequence(value: Value) -> Flow {
    signal(
        "wrong-type-argument",
        vec![Value::symbol("sequencep"), value],
    )
}

fn signal_wrong_type_character(value: Value) -> Flow {
    signal(
        "wrong-type-argument",
        vec![Value::symbol("characterp"), value],
    )
}

fn char_from_codepoint_value(value: &Value) -> Result<char, Flow> {
    match value {
        Value::Char(c) => Ok(*c),
        Value::Int(n) if *n >= 0 => {
            char::from_u32(*n as u32).ok_or_else(|| signal_wrong_type_character(*value))
        }
        _ => Err(signal_wrong_type_character(*value)),
    }
}

fn sequence_value_to_env_string(value: &Value) -> Result<String, Flow> {
    match value {
        Value::Str(s) => Ok(with_heap(|h| h.get_string(*s).clone())),
        Value::Vector(items) => {
            let vec = with_heap(|h| h.get_vector(*items).clone());
            let chars = vec
                .iter()
                .map(char_from_codepoint_value)
                .collect::<Result<Vec<_>, _>>()?;
            Ok(chars.into_iter().collect())
        }
        Value::Cons(_) | Value::Nil => {
            let mut out = String::new();
            let mut cursor = *value;
            loop {
                match cursor {
                    Value::Nil => break,
                    Value::Cons(cell) => {
                        let (car, cdr) = {
                            let pair = read_cons(cell);
                            (pair.car, pair.cdr)
                        };
                        out.push(char_from_codepoint_value(&car)?);
                        cursor = cdr;
                    }
                    tail => {
                        return Err(signal(
                            "wrong-type-argument",
                            vec![Value::symbol("listp"), tail],
                        ))
                    }
                }
            }
            Ok(out)
        }
        other => Err(signal_wrong_type_sequence(*other)),
    }
}

fn expect_int_or_marker(value: &Value) -> Result<i64, Flow> {
    match value {
        Value::Int(n) => Ok(*n),
        Value::Char(c) => Ok(*c as i64),
        v if super::marker::is_marker(v) => super::marker::marker_position_as_int(v),
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("integer-or-marker-p"), *other],
        )),
    }
}

fn checked_region_bytes(
    buf: &crate::buffer::Buffer,
    start: i64,
    end: i64,
) -> Result<(usize, usize), Flow> {
    let point_min = buf.text.byte_to_char(buf.point_min()) as i64 + 1;
    let point_max = buf.text.byte_to_char(buf.point_max()) as i64 + 1;
    if start < point_min || start > point_max || end < point_min || end > point_max {
        return Err(signal(
            "args-out-of-range",
            vec![Value::Buffer(buf.id), Value::Int(start), Value::Int(end)],
        ));
    }

    let start_byte = buf.text.char_to_byte((start - 1) as usize);
    let end_byte = buf.text.char_to_byte((end - 1) as usize);
    Ok(if start_byte <= end_byte {
        (start_byte, end_byte)
    } else {
        (end_byte, start_byte)
    })
}

fn file_error_symbol(kind: std::io::ErrorKind) -> &'static str {
    match kind {
        std::io::ErrorKind::NotFound => "file-missing",
        std::io::ErrorKind::AlreadyExists => "file-already-exists",
        std::io::ErrorKind::PermissionDenied => "permission-denied",
        _ => "file-error",
    }
}

fn signal_process_io(action: &str, target: Option<&str>, err: std::io::Error) -> Flow {
    let mut data = vec![Value::string(action), Value::string(err.to_string())];
    if let Some(target) = target {
        data.push(Value::string(target));
    }
    signal(file_error_symbol(err.kind()), data)
}

#[derive(Clone, Debug)]
enum OutputTarget {
    Discard,
    Buffer(Value),
    File(String),
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum StderrTarget {
    Discard,
    ToStdoutTarget,
    File,
}

#[derive(Clone, Debug)]
struct DestinationSpec {
    stdout: OutputTarget,
    stderr: StderrTarget,
    stderr_file: Option<String>,
    no_wait: bool,
}

fn signal_wrong_type_string(value: Value) -> Flow {
    signal("wrong-type-argument", vec![Value::symbol("stringp"), value])
}

fn expect_string_strict(value: &Value) -> Result<String, Flow> {
    match value {
        Value::Str(s) => Ok(with_heap(|h| h.get_string(*s).clone())),
        other => Err(signal_wrong_type_string(*other)),
    }
}

fn expect_process_name_string(value: &Value) -> Result<String, Flow> {
    match value {
        Value::Str(s) => Ok(with_heap(|h| h.get_string(*s).clone())),
        _ => Err(signal(
            "error",
            vec![Value::string(":name value not a string")],
        )),
    }
}

fn keyword_name(value: &Value) -> Option<&str> {
    match value {
        Value::Keyword(k) => Some(resolve_sym(*k)),
        Value::Symbol(id) if resolve_sym(*id).starts_with(':') => Some(resolve_sym(*id)),
        _ => None,
    }
}

fn is_file_keyword(value: &Value) -> bool {
    matches!(value, Value::Keyword(k) if { let n = resolve_sym(*k); n == ":file" || n == "file" })
}

fn parse_file_target(items: &[Value]) -> Result<OutputTarget, Flow> {
    let file_value = items.get(1).cloned().unwrap_or(Value::Nil);
    let file = expect_string_strict(&file_value)?;
    Ok(OutputTarget::File(file))
}

fn parse_real_buffer_destination(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<(OutputTarget, bool), Flow> {
    match value {
        Value::Int(_) => Ok((OutputTarget::Discard, true)),
        Value::Nil => Ok((OutputTarget::Discard, false)),
        Value::True | Value::Str(_) => Ok((OutputTarget::Buffer(*value), false)),
        Value::Buffer(id) => {
            if eval.buffers.get(*id).is_none() {
                Err(signal(
                    "error",
                    vec![Value::string("Selecting deleted buffer")],
                ))
            } else {
                Ok((OutputTarget::Buffer(*value), false))
            }
        }
        Value::Cons(_) => {
            let items =
                list_to_vec(value).ok_or_else(|| signal_wrong_type_string(*value))?;
            let first = items.first().cloned().unwrap_or(Value::Nil);
            if is_file_keyword(&first) {
                Ok((parse_file_target(&items)?, false))
            } else {
                Err(signal_wrong_type_string(first))
            }
        }
        other => Err(signal_wrong_type_string(*other)),
    }
}

fn parse_stderr_destination(value: &Value) -> Result<(StderrTarget, Option<String>), Flow> {
    match value {
        Value::Nil => Ok((StderrTarget::Discard, None)),
        Value::True => Ok((StderrTarget::ToStdoutTarget, None)),
        Value::Str(s) => Ok((StderrTarget::File, Some(with_heap(|h| h.get_string(*s).clone())))),
        other => Err(signal_wrong_type_string(*other)),
    }
}

fn parse_call_process_destination(
    eval: &super::eval::Evaluator,
    destination: &Value,
) -> Result<DestinationSpec, Flow> {
    if let Value::Cons(_) = destination {
        let items = list_to_vec(destination)
            .ok_or_else(|| signal_wrong_type_string(*destination))?;
        let first = items.first().cloned().unwrap_or(Value::Nil);
        if is_file_keyword(&first) {
            let stdout = parse_file_target(&items)?;
            return Ok(DestinationSpec {
                stdout,
                stderr: StderrTarget::ToStdoutTarget,
                stderr_file: None,
                no_wait: false,
            });
        }
        let second = items.get(1).cloned().unwrap_or(Value::Nil);
        let (stdout, no_wait) = parse_real_buffer_destination(eval, &first)?;
        let (stderr, stderr_file) = parse_stderr_destination(&second)?;
        return Ok(DestinationSpec {
            stdout,
            stderr,
            stderr_file,
            no_wait,
        });
    }

    let (stdout, no_wait) = parse_real_buffer_destination(eval, destination)?;
    let stderr = match destination {
        Value::Nil | Value::Int(_) => StderrTarget::Discard,
        _ => StderrTarget::ToStdoutTarget,
    };
    Ok(DestinationSpec {
        stdout,
        stderr,
        stderr_file: None,
        no_wait,
    })
}

fn insert_process_output(
    eval: &mut super::eval::Evaluator,
    destination: &Value,
    output: &str,
) -> Result<(), Flow> {
    match destination {
        Value::Str(name) => {
            let name_str = with_heap(|h| h.get_string(*name).clone());
            let id = eval
                .buffers
                .find_buffer_by_name(&name_str)
                .unwrap_or_else(|| eval.buffers.create_buffer(&name_str));
            let buf = eval.buffers.get_mut(id).ok_or_else(|| {
                signal(
                    "error",
                    vec![Value::string("No such live buffer for process output")],
                )
            })?;
            buf.insert(output);
            Ok(())
        }
        Value::Buffer(id) => {
            let buf = eval
                .buffers
                .get_mut(*id)
                .ok_or_else(|| signal("error", vec![Value::string("Selecting deleted buffer")]))?;
            buf.insert(output);
            Ok(())
        }
        _ => {
            if let Some(buf) = eval.buffers.current_buffer_mut() {
                buf.insert(output);
            }
            Ok(())
        }
    }
}

fn write_output_target(
    eval: &mut super::eval::Evaluator,
    target: &OutputTarget,
    output: &[u8],
    append: bool,
) -> Result<(), Flow> {
    match target {
        OutputTarget::Discard => Ok(()),
        OutputTarget::Buffer(destination) => {
            let text = String::from_utf8_lossy(output).into_owned();
            insert_process_output(eval, destination, &text)
        }
        OutputTarget::File(path) => {
            if append {
                use std::io::Write;
                let mut file = OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path)
                    .map_err(|e| signal_process_io("Writing process output", Some(path), e))?;
                file.write_all(output)
                    .map_err(|e| signal_process_io("Writing process output", Some(path), e))
            } else {
                std::fs::write(path, output)
                    .map_err(|e| signal_process_io("Writing process output", Some(path), e))
            }
        }
    }
}

fn route_captured_output(
    eval: &mut super::eval::Evaluator,
    destination: &DestinationSpec,
    stdout: &[u8],
    stderr: &[u8],
) -> Result<(), Flow> {
    write_output_target(eval, &destination.stdout, stdout, false)?;
    match destination.stderr {
        StderrTarget::Discard => Ok(()),
        StderrTarget::ToStdoutTarget => {
            write_output_target(eval, &destination.stdout, stderr, true)
        }
        StderrTarget::File => {
            let path = destination
                .stderr_file
                .as_ref()
                .ok_or_else(|| signal("error", vec![Value::string("Missing stderr file target")]))?
                .clone();
            write_output_target(eval, &OutputTarget::File(path), stderr, false)
        }
    }
}

fn configure_call_process_stdin(command: &mut Command, infile: Option<&str>) -> Result<(), Flow> {
    match infile {
        None => {
            command.stdin(Stdio::null());
            Ok(())
        }
        Some(path) => {
            let file = std::fs::File::open(path)
                .map_err(|e| signal_process_io("Opening process input file", Some(path), e))?;
            command.stdin(Stdio::from(file));
            Ok(())
        }
    }
}

fn run_process_command(
    eval: &mut super::eval::Evaluator,
    program: &str,
    infile: Option<String>,
    destination: &Value,
    cmd_args: &[String],
) -> EvalResult {
    let destination_spec = parse_call_process_destination(eval, destination)?;

    if destination_spec.no_wait {
        let mut command = Command::new(program);
        command.args(cmd_args).stdout(Stdio::null());
        configure_call_process_stdin(&mut command, infile.as_deref())?;
        match destination_spec.stderr {
            StderrTarget::Discard | StderrTarget::ToStdoutTarget => {
                command.stderr(Stdio::null());
            }
            StderrTarget::File => {
                let path = destination_spec.stderr_file.as_ref().ok_or_else(|| {
                    signal("error", vec![Value::string("Missing stderr file target")])
                })?;
                let file = OpenOptions::new()
                    .create(true)
                    .truncate(true)
                    .write(true)
                    .open(path)
                    .map_err(|e| signal_process_io("Writing process output", Some(path), e))?;
                command.stderr(Stdio::from(file));
            }
        };

        let mut child = command
            .spawn()
            .map_err(|e| signal_process_io("Searching for program", Some(program), e))?;
        std::thread::spawn(move || {
            let _ = child.wait();
        });
        return Ok(Value::Nil);
    }

    let mut command = Command::new(program);
    command
        .args(cmd_args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    configure_call_process_stdin(&mut command, infile.as_deref())?;
    let output = command
        .output()
        .map_err(|e| signal_process_io("Searching for program", Some(program), e))?;

    let exit_code = output.status.code().unwrap_or(-1);
    route_captured_output(eval, &destination_spec, &output.stdout, &output.stderr)?;
    Ok(Value::Int(exit_code as i64))
}

fn run_process_capture_output(program: &str, cmd_args: &[String]) -> Result<(i32, Vec<u8>), Flow> {
    let mut command = Command::new(program);
    command
        .args(cmd_args)
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::null());
    let output = command
        .output()
        .map_err(|e| signal_process_io("Searching for program", Some(program), e))?;
    Ok((output.status.code().unwrap_or(-1), output.stdout))
}

fn parse_output_lines(stdout: &[u8]) -> Value {
    let mut text = String::from_utf8_lossy(stdout).into_owned();
    if text.ends_with('\n') {
        text.pop();
    }
    if text.is_empty() {
        Value::Nil
    } else {
        Value::list(text.split('\n').map(Value::string).collect())
    }
}

fn parse_optional_infile(args: &[Value], index: usize) -> Result<Option<String>, Flow> {
    if args.len() > index && !args[index].is_nil() {
        Ok(Some(expect_string_strict(&args[index])?))
    } else {
        Ok(None)
    }
}

fn parse_string_args_strict(args: &[Value]) -> Result<Vec<String>, Flow> {
    args.iter().map(expect_string_strict).collect()
}

fn parse_sequence_args(args: &[Value]) -> Result<Vec<String>, Flow> {
    args.iter().map(sequence_value_to_env_string).collect()
}

fn signal_process_lines_status_error(program: &str, status: i32) -> Flow {
    signal(
        "error",
        vec![Value::string(format!(
            "{program} exited with status {status}"
        ))],
    )
}

fn shell_quote_argument(arg: &str) -> String {
    let mut out = String::from("'");
    for ch in arg.chars() {
        if ch == '\'' {
            out.push_str("'\\''");
        } else {
            out.push(ch);
        }
    }
    out.push('\'');
    out
}

fn shell_command_with_args(command: &str, args: &[String]) -> String {
    if args.is_empty() {
        return command.to_string();
    }
    let quoted = args
        .iter()
        .map(|arg| shell_quote_argument(arg))
        .collect::<Vec<_>>()
        .join(" ");
    if command.is_empty() {
        quoted
    } else {
        format!("{command} {quoted}")
    }
}

fn signal_wrong_type_processp(value: Value) -> Flow {
    signal(
        "wrong-type-argument",
        vec![Value::symbol("processp"), value],
    )
}

fn signal_process_does_not_exist(name: &str) -> Flow {
    signal(
        "error",
        vec![Value::string(format!("Process {name} does not exist"))],
    )
}

fn signal_process_not_active(eval: &super::eval::Evaluator, id: ProcessId) -> Flow {
    let name = eval
        .processes
        .get_any(id)
        .map(|proc| proc.name.clone())
        .unwrap_or_else(|| id.to_string());
    signal(
        "error",
        vec![Value::string(format!("Process {name} is not active"))],
    )
}

fn stale_process_not_running_reason(status: &ProcessStatus) -> &'static str {
    match status {
        ProcessStatus::Signal(_) => "killed",
        ProcessStatus::Exit(_) => "finished",
        ProcessStatus::Stop => "stopped",
        ProcessStatus::Run => "inactive",
    }
}

fn signal_process_not_running(eval: &super::eval::Evaluator, id: ProcessId) -> Flow {
    let (name, reason) = eval
        .processes
        .get_any(id)
        .map(|proc| {
            (
                proc.name.clone(),
                stale_process_not_running_reason(&proc.status),
            )
        })
        .unwrap_or_else(|| (id.to_string(), "inactive"));
    signal(
        "error",
        vec![Value::string(format!(
            "Process {name} not running: {reason}\n"
        ))],
    )
}

fn resolve_process_or_wrong_type(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<ProcessId, Flow> {
    match value {
        Value::Int(n) if *n >= 0 => {
            let id = *n as ProcessId;
            if eval.processes.get(id).is_some() {
                Ok(id)
            } else {
                Err(signal_wrong_type_processp(*value))
            }
        }
        Value::Str(s) => {
            let name = with_heap(|h| h.get_string(*s).clone());
            eval.processes
                .find_by_name(&name)
                .ok_or_else(|| signal_wrong_type_processp(*value))
        }
        _ => Err(signal_wrong_type_processp(*value)),
    }
}

fn resolve_process_or_wrong_type_any(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<ProcessId, Flow> {
    match value {
        Value::Int(n) if *n >= 0 => {
            let id = *n as ProcessId;
            if eval.processes.get_any(id).is_some() {
                Ok(id)
            } else {
                Err(signal_wrong_type_processp(*value))
            }
        }
        Value::Str(s) => {
            let name = with_heap(|h| h.get_string(*s).clone());
            eval.processes
                .find_by_name(&name)
                .ok_or_else(|| signal_wrong_type_processp(*value))
        }
        _ => Err(signal_wrong_type_processp(*value)),
    }
}

fn resolve_process_or_missing_error(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<ProcessId, Flow> {
    match value {
        Value::Str(s) => {
            let name = with_heap(|h| h.get_string(*s).clone());
            eval.processes
                .find_by_name(&name)
                .ok_or_else(|| signal_process_does_not_exist(&name))
        }
        _ => resolve_process_or_wrong_type(eval, value),
    }
}

fn resolve_process_or_missing_error_any(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<ProcessId, Flow> {
    match value {
        Value::Str(s) => {
            let name = with_heap(|h| h.get_string(*s).clone());
            eval.processes
                .find_by_name(&name)
                .ok_or_else(|| signal_process_does_not_exist(&name))
        }
        _ => resolve_process_or_wrong_type_any(eval, value),
    }
}

fn resolve_process_for_status(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<Option<ProcessId>, Flow> {
    match value {
        Value::Int(n) if *n >= 0 => {
            let id = *n as ProcessId;
            if eval.processes.get_any(id).is_some() {
                Ok(Some(id))
            } else {
                Err(signal_wrong_type_processp(*value))
            }
        }
        Value::Str(s) => {
            let name = with_heap(|h| h.get_string(*s).clone());
            Ok(eval.processes.find_by_name(&name))
        }
        _ => Err(signal_wrong_type_processp(*value)),
    }
}

fn resolve_buffer_name_for_process_lookup(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<Option<String>, Flow> {
    match value {
        Value::Nil => Ok(eval
            .frames
            .selected_frame()
            .and_then(|frame| frame.selected_window())
            .and_then(|window| window.buffer_id())
            .and_then(|id| eval.buffers.get(id))
            .map(|buf| buf.name.clone())),
        Value::Str(name) => {
            let name_str = with_heap(|h| h.get_string(*name).clone());
            Ok(eval
                .buffers
                .find_buffer_by_name(&name_str)
                .and_then(|id| eval.buffers.get(id))
                .map(|buf| buf.name.clone()))
        }
        Value::Buffer(id) => Ok(eval.buffers.get(*id).map(|buf| buf.name.clone())),
        other => Err(signal_wrong_type_string(*other)),
    }
}

/// Resolve a live process designator for compatibility builtins.
///
/// NeoVM currently models process handles as integer ids.  These helpers treat
/// a live process id as a process designator for runtime parity surfaces.
fn resolve_live_process_designator(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Option<ProcessId> {
    match value {
        Value::Int(n) if *n >= 0 => {
            let id = *n as ProcessId;
            eval.processes.get(id).map(|_| id)
        }
        _ => None,
    }
}

fn resolve_live_process_or_wrong_type(
    eval: &super::eval::Evaluator,
    value: &Value,
) -> Result<ProcessId, Flow> {
    resolve_live_process_designator(eval, value).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), *value],
        )
    })
}

fn is_stale_process_id_designator(eval: &super::eval::Evaluator, value: &Value) -> bool {
    match value {
        Value::Int(n) if *n > 0 => {
            let id = *n as ProcessId;
            eval.processes.get(id).is_none()
                && (eval.processes.get_any(id).is_some() || eval.processes.was_issued_id(id))
        }
        _ => false,
    }
}

fn resolve_optional_process_or_current_buffer(
    eval: &super::eval::Evaluator,
    value: Option<&Value>,
) -> Result<ProcessId, Flow> {
    if let Some(v) = value {
        if !v.is_nil() {
            return resolve_process_or_missing_error(eval, v);
        }
    }

    let current_buffer_name = eval
        .buffers
        .current_buffer()
        .map(|buffer| buffer.name.clone())
        .ok_or_else(|| signal("error", vec![Value::string("No current buffer")]))?;

    eval.processes
        .find_by_buffer_name(&current_buffer_name)
        .ok_or_else(|| {
            signal(
                "error",
                vec![Value::string(format!(
                    "Buffer {} has no process",
                    current_buffer_name
                ))],
            )
        })
}

fn process_live_status_value(status: &ProcessStatus, kind: &ProcessKind) -> Value {
    match status {
        ProcessStatus::Run => match kind {
            ProcessKind::Network => Value::list(vec![
                Value::symbol("listen"),
                Value::symbol("connect"),
                Value::symbol("stop"),
            ]),
            ProcessKind::Pipe => Value::list(vec![
                Value::symbol("open"),
                Value::symbol("listen"),
                Value::symbol("connect"),
                Value::symbol("stop"),
            ]),
            _ => Value::list(vec![
                Value::symbol("run"),
                Value::symbol("open"),
                Value::symbol("listen"),
                Value::symbol("connect"),
                Value::symbol("stop"),
            ]),
        },
        ProcessStatus::Stop => Value::list(vec![Value::symbol("stop")]),
        ProcessStatus::Exit(_) | ProcessStatus::Signal(_) => Value::Nil,
    }
}

fn default_process_tty_name() -> String {
    // NeoVM does not yet allocate real PTYs for subprocesses, but oracle behavior
    // expects tty-backed streams for default `start-process` paths.
    "/dev/pts/0".to_string()
}

fn signal_wrong_type_bufferp(value: Value) -> Flow {
    signal("wrong-type-argument", vec![Value::symbol("bufferp"), value])
}

fn signal_wrong_type_threadp(value: Value) -> Flow {
    signal("wrong-type-argument", vec![Value::symbol("threadp"), value])
}

fn signal_wrong_type_integerp(value: Value) -> Flow {
    signal(
        "wrong-type-argument",
        vec![Value::symbol("integerp"), value],
    )
}

fn signal_wrong_type_numberp(value: Value) -> Flow {
    signal("wrong-type-argument", vec![Value::symbol("numberp"), value])
}

fn signal_undefined_signal_name(name: &str) -> Flow {
    signal(
        "error",
        vec![Value::string(format!("Undefined signal name {name}"))],
    )
}

fn resolve_optional_process_with_explicit_return(
    eval: &super::eval::Evaluator,
    value: Option<&Value>,
) -> Result<(ProcessId, Value), Flow> {
    if let Some(v) = value {
        if !v.is_nil() && is_stale_process_id_designator(eval, v) {
            if let Value::Int(n) = v {
                return Err(signal_process_not_active(eval, *n as ProcessId));
            }
        }
    }
    if let Some(v) = value {
        if !v.is_nil() {
            let id = resolve_process_or_missing_error(eval, v)?;
            return Ok((id, *v));
        }
    }
    let id = resolve_optional_process_or_current_buffer(eval, value)?;
    Ok((id, Value::Nil))
}

enum SignalProcessTarget {
    Process(ProcessId),
    MissingNamedProcess,
    Pid(i64),
}

fn resolve_signal_process_target(
    eval: &super::eval::Evaluator,
    value: Option<&Value>,
) -> Result<SignalProcessTarget, Flow> {
    if let Some(v) = value {
        if !v.is_nil() {
            return match v {
                Value::Str(name) => {
                    let name_str = with_heap(|h| h.get_string(*name).clone());
                    Ok(match eval.processes.find_by_name(&name_str) {
                        Some(id) => SignalProcessTarget::Process(id),
                        None => SignalProcessTarget::MissingNamedProcess,
                    })
                }
                Value::Int(pid) if *pid >= 0 => {
                    let id = *pid as ProcessId;
                    if eval.processes.get(id).is_some() {
                        Ok(SignalProcessTarget::Process(id))
                    } else {
                        Ok(SignalProcessTarget::Pid(*pid))
                    }
                }
                _ => Err(signal_wrong_type_processp(*v)),
            };
        }
    }

    let id = resolve_optional_process_or_current_buffer(eval, value)?;
    Ok(SignalProcessTarget::Process(id))
}

fn parse_signal_number(value: &Value) -> Result<i32, Flow> {
    match value {
        Value::Int(n) => Ok(*n as i32),
        Value::Char(c) => Ok(*c as i32),
        Value::Str(_) => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("symbolp"), *value],
        )),
        _ => {
            if let Some(name) = value.as_symbol_name() {
                Err(signal_undefined_signal_name(name))
            } else {
                Err(signal_wrong_type_integerp(*value))
            }
        }
    }
}

fn pid_exists(pid: i64) -> bool {
    if pid < 0 {
        return false;
    }
    std::fs::metadata(format!("/proc/{pid}")).is_ok()
}

#[derive(Clone, Debug)]
struct ProcStatSnapshot {
    comm: String,
    state: String,
    ppid: i64,
    pgrp: i64,
    sess: i64,
    tpgid: i64,
    minflt: i64,
    majflt: i64,
    cminflt: i64,
    cmajflt: i64,
    utime_ticks: i64,
    stime_ticks: i64,
    cutime_ticks: i64,
    cstime_ticks: i64,
    pri: i64,
    nice: i64,
    thcount: i64,
    start_ticks: i64,
    vsize: i64,
    rss: i64,
    ttname: String,
}

impl ProcStatSnapshot {
    fn fallback(pid: i64) -> Self {
        Self {
            comm: String::new(),
            state: String::new(),
            ppid: 0,
            pgrp: 0,
            sess: 0,
            tpgid: 0,
            minflt: 0,
            majflt: 0,
            cminflt: 0,
            cmajflt: 0,
            utime_ticks: 0,
            stime_ticks: 0,
            cutime_ticks: 0,
            cstime_ticks: 0,
            pri: 0,
            nice: 0,
            thcount: 0,
            start_ticks: 0,
            vsize: 0,
            rss: 0,
            ttname: read_proc_tty_name(pid),
        }
    }
}

fn parse_stat_i64_field(fields: &[&str], index: usize) -> Option<i64> {
    fields.get(index)?.parse::<i64>().ok()
}

#[cfg(not(target_os = "windows"))]
fn page_size_kb() -> i64 {
    // SAFETY: `sysconf(_SC_PAGESIZE)` has no additional preconditions.
    let page_size_bytes = unsafe { libc::sysconf(libc::_SC_PAGESIZE) };
    if page_size_bytes <= 0 {
        4
    } else {
        ((page_size_bytes as i64) / 1024).max(1)
    }
}

#[cfg(target_os = "windows")]
fn page_size_kb() -> i64 {
    4
}

#[cfg(not(target_os = "windows"))]
fn clock_ticks_per_second() -> i64 {
    // SAFETY: `sysconf(_SC_CLK_TCK)` has no additional preconditions.
    let ticks = unsafe { libc::sysconf(libc::_SC_CLK_TCK) };
    if ticks <= 0 { 100 } else { ticks as i64 }
}

#[cfg(target_os = "windows")]
fn clock_ticks_per_second() -> i64 {
    100
}

fn read_proc_tty_name(pid: i64) -> String {
    std::fs::read_link(format!("/proc/{pid}/fd/0"))
        .ok()
        .map(|path| path.to_string_lossy().into_owned())
        .unwrap_or_else(|| "?".to_string())
}

fn parse_proc_cmdline(pid: i64) -> String {
    let bytes = match std::fs::read(format!("/proc/{pid}/cmdline")) {
        Ok(bytes) => bytes,
        Err(_) => return String::new(),
    };
    let mut args = Vec::new();
    for chunk in bytes.split(|b| *b == 0) {
        if chunk.is_empty() {
            continue;
        }
        args.push(String::from_utf8_lossy(chunk).into_owned());
    }
    args.join(" ")
}

fn parse_proc_boot_time_secs() -> Option<i64> {
    let stat = std::fs::read_to_string("/proc/stat").ok()?;
    for line in stat.lines() {
        if let Some(rest) = line.strip_prefix("btime ") {
            return rest.trim().parse::<i64>().ok();
        }
    }
    None
}

fn parse_total_memory_kb() -> Option<i64> {
    let meminfo = std::fs::read_to_string("/proc/meminfo").ok()?;
    for line in meminfo.lines() {
        if let Some(rest) = line.strip_prefix("MemTotal:") {
            let kb = rest.split_whitespace().next()?.parse::<i64>().ok()?;
            return Some(kb);
        }
    }
    None
}

fn ticks_to_secs_usecs(ticks: i64, hz: i64) -> (i64, i64) {
    if hz <= 0 {
        return (0, 0);
    }
    let secs = ticks.div_euclid(hz);
    let rem = ticks.rem_euclid(hz);
    let usecs = ((rem as i128) * 1_000_000i128 / (hz as i128)) as i64;
    (secs, usecs)
}

fn time_list_from_secs_usecs(secs: i64, usecs: i64) -> Value {
    let high = (secs >> 16) & 0xFFFF_FFFF;
    let low = secs & 0xFFFF;
    Value::list(vec![
        Value::Int(high),
        Value::Int(low),
        Value::Int(usecs.clamp(0, 999_999)),
        Value::Int(0),
    ])
}

fn time_list_from_ticks(ticks: i64, hz: i64) -> Value {
    let (secs, usecs) = ticks_to_secs_usecs(ticks, hz);
    time_list_from_secs_usecs(secs, usecs)
}

fn now_epoch_secs_usecs() -> Option<(i64, i64)> {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(dur) => Some((dur.as_secs() as i64, dur.subsec_micros() as i64)),
        Err(_) => None,
    }
}

fn nonnegative_time_diff(now: (i64, i64), then: (i64, i64)) -> (i64, i64) {
    let (now_secs, now_usecs) = now;
    let (then_secs, then_usecs) = then;
    if (now_secs, now_usecs) < (then_secs, then_usecs) {
        return (0, 0);
    }
    let mut secs = now_secs - then_secs;
    let mut usecs = now_usecs - then_usecs;
    if usecs < 0 {
        secs -= 1;
        usecs += 1_000_000;
    }
    (secs, usecs)
}

fn parse_proc_stat_snapshot(pid: i64) -> Option<ProcStatSnapshot> {
    let stat = std::fs::read_to_string(format!("/proc/{pid}/stat")).ok()?;
    let open_paren = stat.find('(')?;
    let close_paren = stat.rfind(')')?;
    if close_paren <= open_paren {
        return None;
    }

    let comm = stat.get((open_paren + 1)..close_paren)?.to_string();
    let trailing = stat.get((close_paren + 1)..)?.trim_start();
    let fields: Vec<&str> = trailing.split_whitespace().collect();
    if fields.len() < 22 {
        return None;
    }

    let state = fields[0].to_string();
    let ppid = parse_stat_i64_field(&fields, 1)?;
    let pgrp = parse_stat_i64_field(&fields, 2)?;
    let sess = parse_stat_i64_field(&fields, 3)?;
    let tpgid = parse_stat_i64_field(&fields, 5)?;
    let minflt = parse_stat_i64_field(&fields, 7)?;
    let cminflt = parse_stat_i64_field(&fields, 8)?;
    let majflt = parse_stat_i64_field(&fields, 9)?;
    let cmajflt = parse_stat_i64_field(&fields, 10)?;
    let utime_ticks = parse_stat_i64_field(&fields, 11)?;
    let stime_ticks = parse_stat_i64_field(&fields, 12)?;
    let cutime_ticks = parse_stat_i64_field(&fields, 13)?;
    let cstime_ticks = parse_stat_i64_field(&fields, 14)?;
    let pri = parse_stat_i64_field(&fields, 15)?;
    let nice = parse_stat_i64_field(&fields, 16)?;
    let thcount = parse_stat_i64_field(&fields, 17)?;
    let start_ticks = parse_stat_i64_field(&fields, 19)?;
    let vsize = parse_stat_i64_field(&fields, 20)?;
    let rss_pages = parse_stat_i64_field(&fields, 21)?;
    let rss = rss_pages.saturating_mul(page_size_kb());
    let ttname = read_proc_tty_name(pid);

    Some(ProcStatSnapshot {
        comm,
        state,
        ppid,
        pgrp,
        sess,
        tpgid,
        minflt,
        majflt,
        cminflt,
        cmajflt,
        utime_ticks,
        stime_ticks,
        cutime_ticks,
        cstime_ticks,
        pri,
        nice,
        thcount,
        start_ticks,
        vsize,
        rss,
        ttname,
    })
}

fn parse_effective_ids_from_proc_status(pid: i64) -> Option<(u32, u32)> {
    let status = std::fs::read_to_string(format!("/proc/{pid}/status")).ok()?;
    let mut euid = None;
    let mut egid = None;
    for line in status.lines() {
        if let Some(rest) = line.strip_prefix("Uid:") {
            let fields: Vec<&str> = rest.split_whitespace().collect();
            if fields.len() >= 2 {
                euid = fields[1].parse::<u32>().ok();
            }
        } else if let Some(rest) = line.strip_prefix("Gid:") {
            let fields: Vec<&str> = rest.split_whitespace().collect();
            if fields.len() >= 2 {
                egid = fields[1].parse::<u32>().ok();
            }
        }
        if euid.is_some() && egid.is_some() {
            break;
        }
    }
    Some((euid?, egid?))
}

#[cfg(not(target_os = "windows"))]
fn lookup_user_name(uid: u32) -> Option<String> {
    // SAFETY: libc returns either null or a valid passwd struct pointer.
    let user = unsafe { libc::getpwuid(uid as libc::uid_t) };
    if user.is_null() {
        return None;
    }
    // SAFETY: `user` is non-null and `pw_name` is a valid C string pointer.
    let name_ptr = unsafe { (*user).pw_name };
    if name_ptr.is_null() {
        return None;
    }
    // SAFETY: `name_ptr` is a valid NUL-terminated C string.
    Some(
        unsafe { CStr::from_ptr(name_ptr) }
            .to_string_lossy()
            .into_owned(),
    )
}

#[cfg(target_os = "windows")]
fn lookup_user_name(_uid: u32) -> Option<String> {
    None
}

#[cfg(not(target_os = "windows"))]
fn lookup_group_name(gid: u32) -> Option<String> {
    // SAFETY: libc returns either null or a valid group struct pointer.
    let group = unsafe { libc::getgrgid(gid as libc::gid_t) };
    if group.is_null() {
        return None;
    }
    // SAFETY: `group` is non-null and `gr_name` is a valid C string pointer.
    let name_ptr = unsafe { (*group).gr_name };
    if name_ptr.is_null() {
        return None;
    }
    // SAFETY: `name_ptr` is a valid NUL-terminated C string.
    Some(
        unsafe { CStr::from_ptr(name_ptr) }
            .to_string_lossy()
            .into_owned(),
    )
}

#[cfg(target_os = "windows")]
fn lookup_group_name(_gid: u32) -> Option<String> {
    None
}

fn parse_make_process_command(value: &Value) -> Result<Vec<String>, Flow> {
    let as_vec: Option<Vec<Value>> = match value {
        Value::Vector(items) => Some(with_heap(|h| h.get_vector(*items).clone())),
        Value::Cons(_) | Value::Nil => list_to_vec(value),
        _ => None,
    };

    let Some(items) = as_vec else {
        return Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), *value],
        ));
    };

    items
        .into_iter()
        .map(|item| expect_string_strict(&item))
        .collect()
}

fn parse_make_process_buffer(
    eval: &mut super::eval::Evaluator,
    value: &Value,
) -> Result<Option<String>, Flow> {
    match value {
        Value::Nil => Ok(None),
        Value::Str(name) => {
            let name_str = with_heap(|h| h.get_string(*name).clone());
            if eval.buffers.find_buffer_by_name(&name_str).is_none() {
                let _ = eval.buffers.create_buffer(&name_str);
            }
            Ok(Some(name_str))
        }
        Value::Buffer(id) => eval
            .buffers
            .get(*id)
            .map(|buf| Some(buf.name.clone()))
            .ok_or_else(|| signal("error", vec![Value::string("Selecting deleted buffer")])),
        _ => Err(signal_wrong_type_string(*value)),
    }
}

fn expect_integer(value: &Value) -> Result<i64, Flow> {
    match value {
        Value::Int(n) => Ok(*n),
        Value::Char(c) => Ok(*c as i64),
        _ => Err(signal_wrong_type_integerp(*value)),
    }
}

fn value_as_nonnegative_integer(value: &Value) -> Option<i64> {
    match value {
        Value::Int(n) if *n >= 0 => Some(*n),
        Value::Char(c) => Some(*c as i64),
        _ => None,
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum NetworkAddressFamily {
    Ipv4,
    Ipv6,
}

#[derive(Clone, Debug)]
struct HostInterfaceEntry {
    name: String,
    family: NetworkAddressFamily,
    address: Value,
    list_broadcast: Value,
    info_broadcast: Value,
    netmask: Value,
    hwaddr: Option<Value>,
    flags: Value,
}

fn vector_nonnegative_integers(value: &Value) -> Option<Vec<i64>> {
    let Value::Vector(values) = value else {
        return None;
    };
    let locked = with_heap(|h| h.get_vector(*values).clone());
    let mut out = Vec::with_capacity(locked.len());
    for item in locked.iter() {
        out.push(value_as_nonnegative_integer(item)?);
    }
    Some(out)
}

fn int_vector(values: &[i64]) -> Value {
    Value::vector(values.iter().map(|v| Value::Int(*v)).collect())
}

fn loopback_ipv4_address() -> Value {
    int_vector(&[127, 0, 0, 1, 0])
}

fn loopback_ipv4_broadcast() -> Value {
    int_vector(&[0, 0, 0, 0, 0])
}

fn loopback_ipv4_netmask() -> Value {
    int_vector(&[255, 0, 0, 0, 0])
}

fn loopback_ipv6_address() -> Value {
    int_vector(&[0, 0, 0, 0, 0, 0, 0, 1, 0])
}

fn loopback_ipv6_broadcast() -> Value {
    int_vector(&[0, 0, 0, 0, 0, 0, 0, 1, 0])
}

fn loopback_ipv6_netmask() -> Value {
    int_vector(&[65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 0])
}

fn loopback_hwaddr() -> Value {
    Value::cons(Value::Int(772), int_vector(&[0, 0, 0, 0, 0, 0]))
}

fn loopback_flags() -> Value {
    Value::list(vec![
        Value::symbol("running"),
        Value::symbol("loopback"),
        Value::symbol("up"),
    ])
}

fn zero_network_address(family: NetworkAddressFamily) -> Value {
    match family {
        NetworkAddressFamily::Ipv4 => int_vector(&[0, 0, 0, 0, 0]),
        NetworkAddressFamily::Ipv6 => int_vector(&[0, 0, 0, 0, 0, 0, 0, 0, 0]),
    }
}

fn network_directed_broadcast(
    family: NetworkAddressFamily,
    address: &Value,
    netmask: &Value,
) -> Option<Value> {
    let address_items = vector_nonnegative_integers(address)?;
    let netmask_items = vector_nonnegative_integers(netmask)?;
    match family {
        NetworkAddressFamily::Ipv4 => {
            if address_items.len() != 5 || netmask_items.len() != 5 {
                return None;
            }
            let mut out = [0_i64; 5];
            for idx in 0..4 {
                let addr = u8::try_from(address_items[idx]).ok()?;
                let mask = u8::try_from(netmask_items[idx]).ok()?;
                out[idx] = (addr | !mask) as i64;
            }
            Some(int_vector(&out))
        }
        NetworkAddressFamily::Ipv6 => {
            if address_items.len() != 9 || netmask_items.len() != 9 {
                return None;
            }
            let mut out = [0_i64; 9];
            for idx in 0..8 {
                let addr = u16::try_from(address_items[idx]).ok()?;
                let mask = u16::try_from(netmask_items[idx]).ok()?;
                out[idx] = (addr | !mask) as i64;
            }
            Some(int_vector(&out))
        }
    }
}

fn derive_network_interface_list_broadcast(
    family: NetworkAddressFamily,
    address: &Value,
    netmask: &Value,
    raw_broadcast: &Value,
) -> Value {
    network_directed_broadcast(family, address, netmask).unwrap_or(*raw_broadcast)
}

fn derive_network_interface_info_broadcast(
    family: NetworkAddressFamily,
    address: &Value,
    raw_broadcast: &Value,
) -> Value {
    if raw_broadcast == address {
        zero_network_address(family)
    } else {
        *raw_broadcast
    }
}

fn interface_flags(flags: libc::c_uint) -> Value {
    let mut out = Vec::new();
    if flags & (libc::IFF_MULTICAST as libc::c_uint) != 0 {
        out.push(Value::symbol("multicast"));
    }
    if flags & (libc::IFF_NOARP as libc::c_uint) != 0 {
        out.push(Value::symbol("noarp"));
    }
    if flags & (libc::IFF_RUNNING as libc::c_uint) != 0 {
        out.push(Value::symbol("running"));
    }
    if flags & (libc::IFF_POINTOPOINT as libc::c_uint) != 0 {
        out.push(Value::symbol("pointopoint"));
    }
    if flags & (libc::IFF_BROADCAST as libc::c_uint) != 0 {
        out.push(Value::symbol("broadcast"));
    }
    if flags & (libc::IFF_LOOPBACK as libc::c_uint) != 0 {
        out.push(Value::symbol("loopback"));
    }
    if flags & (libc::IFF_UP as libc::c_uint) != 0 {
        out.push(Value::symbol("up"));
    }
    Value::list(out)
}

fn parse_network_sockaddr(addr: *const libc::sockaddr) -> Option<(NetworkAddressFamily, Value)> {
    if addr.is_null() {
        return None;
    }

    // SAFETY: The caller passes pointers obtained from libc APIs that provide
    // valid `sockaddr*` records for the lifetime of iteration.
    unsafe {
        match (*addr).sa_family as i32 {
            libc::AF_INET => {
                let in4 = &*(addr as *const libc::sockaddr_in);
                let octets = in4.sin_addr.s_addr.to_ne_bytes();
                Some((
                    NetworkAddressFamily::Ipv4,
                    int_vector(&[
                        octets[0] as i64,
                        octets[1] as i64,
                        octets[2] as i64,
                        octets[3] as i64,
                        0,
                    ]),
                ))
            }
            libc::AF_INET6 => {
                let in6 = &*(addr as *const libc::sockaddr_in6);
                let mut segments = [0_i64; 9];
                for (idx, chunk) in in6.sin6_addr.s6_addr.chunks_exact(2).enumerate() {
                    segments[idx] = u16::from_be_bytes([chunk[0], chunk[1]]) as i64;
                }
                Some((NetworkAddressFamily::Ipv6, int_vector(&segments)))
            }
            _ => None,
        }
    }
}

fn resolve_network_lookup_addresses(
    name: &str,
    family: Option<NetworkAddressFamily>,
) -> Vec<Value> {
    struct AddrInfoGuard(*mut libc::addrinfo);

    impl Drop for AddrInfoGuard {
        fn drop(&mut self) {
            // SAFETY: Pointer is owned by `getaddrinfo` and released once.
            unsafe {
                if !self.0.is_null() {
                    libc::freeaddrinfo(self.0);
                }
            }
        }
    }

    // Emacs forwards names through C APIs where embedded NUL terminates the
    // effective hostname. Match that behavior instead of rejecting interior NUL.
    let normalized_name = name.split('\0').next().unwrap_or_default();
    let c_name = match CString::new(normalized_name) {
        Ok(value) => value,
        Err(_) => return Vec::new(),
    };
    let mut hints: libc::addrinfo = unsafe { std::mem::zeroed() };
    hints.ai_family = match family {
        Some(NetworkAddressFamily::Ipv4) => libc::AF_INET,
        Some(NetworkAddressFamily::Ipv6) => libc::AF_INET6,
        None => libc::AF_UNSPEC,
    };
    hints.ai_socktype = libc::SOCK_STREAM;
    hints.ai_protocol = 0;
    hints.ai_flags = 0;

    let mut root: *mut libc::addrinfo = std::ptr::null_mut();
    // SAFETY: `getaddrinfo` initializes `root` when successful.
    let status = unsafe {
        libc::getaddrinfo(
            c_name.as_ptr(),
            std::ptr::null(),
            &hints as *const libc::addrinfo,
            &mut root as *mut *mut libc::addrinfo,
        )
    };
    if status != 0 || root.is_null() {
        return Vec::new();
    }
    let _guard = AddrInfoGuard(root);

    let mut out = Vec::new();
    let mut current = root;
    while !current.is_null() {
        // SAFETY: `current` points to the `addrinfo` linked list returned by
        // `getaddrinfo` until the guard drops and frees it.
        unsafe {
            let info = &*current;
            if let Some((resolved_family, address)) =
                parse_network_sockaddr(info.ai_addr as *const libc::sockaddr)
            {
                let include = match family {
                    Some(expected) => expected == resolved_family,
                    None => true,
                };
                if include {
                    out.push(address);
                }
            }
            current = info.ai_next;
        }
    }

    out
}

#[cfg(target_os = "linux")]
fn parse_hwaddr(addr: *const libc::sockaddr) -> Option<Value> {
    if addr.is_null() {
        return None;
    }

    // SAFETY: The pointer is from `ifaddrs` and points to a valid socket
    // address for the current iteration node.
    unsafe {
        if (*addr).sa_family as i32 != libc::AF_PACKET {
            return None;
        }
        let ll = &*(addr as *const libc::sockaddr_ll);
        let len = usize::min(ll.sll_halen as usize, ll.sll_addr.len());
        let bytes = ll.sll_addr[..len]
            .iter()
            .map(|byte| Value::Int(*byte as i64))
            .collect::<Vec<_>>();
        Some(Value::cons(
            Value::Int(ll.sll_hatype as i64),
            Value::vector(bytes),
        ))
    }
}

#[cfg(target_os = "linux")]
fn parse_hwaddr_text(raw: &str) -> Option<Vec<Value>> {
    let mut bytes = Vec::new();
    for part in raw.trim().split(':') {
        if part.is_empty() {
            continue;
        }
        let byte = u8::from_str_radix(part, 16).ok()?;
        bytes.push(Value::Int(byte as i64));
    }
    Some(bytes)
}

#[cfg(target_os = "linux")]
fn read_hwaddr_from_sysfs(name: &str) -> Option<Value> {
    let hatype_path = format!("/sys/class/net/{name}/type");
    let address_path = format!("/sys/class/net/{name}/address");
    let addr_len_path = format!("/sys/class/net/{name}/addr_len");

    let hatype = std::fs::read_to_string(hatype_path).ok()?;
    let hatype = hatype.trim().parse::<i64>().ok()?;

    let default_len = std::fs::read_to_string(addr_len_path)
        .ok()
        .and_then(|raw| raw.trim().parse::<usize>().ok())
        .map(|len| if len == 0 { 6 } else { len })
        .unwrap_or(6)
        .min(32);

    let bytes = std::fs::read_to_string(address_path)
        .ok()
        .and_then(|raw| parse_hwaddr_text(&raw))
        .map(|mut parsed| {
            if parsed.len() < default_len {
                parsed.extend(std::iter::repeat_n(Value::Int(0), default_len - parsed.len()));
            } else if parsed.len() > default_len {
                parsed.truncate(default_len);
            }
            parsed
        })
        .unwrap_or_else(|| vec![Value::Int(0); default_len]);

    Some(Value::cons(Value::Int(hatype), Value::vector(bytes)))
}

#[cfg(target_os = "linux")]
fn host_interface_snapshot() -> Option<Vec<HostInterfaceEntry>> {
    struct IfAddrsGuard(*mut libc::ifaddrs);

    impl Drop for IfAddrsGuard {
        fn drop(&mut self) {
            // SAFETY: `self.0` comes from `getifaddrs` and is released exactly once.
            unsafe {
                if !self.0.is_null() {
                    libc::freeifaddrs(self.0);
                }
            }
        }
    }

    let mut root: *mut libc::ifaddrs = ptr::null_mut();
    // SAFETY: `getifaddrs` initializes `root` on success.
    unsafe {
        if libc::getifaddrs(&mut root as *mut *mut libc::ifaddrs) != 0 || root.is_null() {
            return None;
        }
    }
    let _guard = IfAddrsGuard(root);

    let mut entries = Vec::new();
    let mut hwaddr_by_name: HashMap<String, Value> = HashMap::new();

    let mut current = root;
    while !current.is_null() {
        // SAFETY: `current` is either null or points into the linked list
        // produced by `getifaddrs`; we advance using `ifa_next`.
        unsafe {
            let ifa = &*current;
            if !ifa.ifa_name.is_null() {
                let name = CStr::from_ptr(ifa.ifa_name).to_string_lossy().into_owned();

                if let Some(hwaddr) = parse_hwaddr(ifa.ifa_addr) {
                    hwaddr_by_name.entry(name.clone()).or_insert(hwaddr);
                }

                if let Some((family, address)) =
                    parse_network_sockaddr(ifa.ifa_addr as *const libc::sockaddr)
                {
                    let netmask = parse_network_sockaddr(ifa.ifa_netmask as *const libc::sockaddr)
                        .and_then(|(mask_family, mask)| (mask_family == family).then_some(mask))
                        .unwrap_or_else(|| zero_network_address(family));
                    let raw_broadcast =
                        parse_network_sockaddr(ifa.ifa_ifu as *const libc::sockaddr)
                            .and_then(|(bc_family, bc)| (bc_family == family).then_some(bc))
                            .unwrap_or_else(|| zero_network_address(family));
                    let list_broadcast = derive_network_interface_list_broadcast(
                        family,
                        &address,
                        &netmask,
                        &raw_broadcast,
                    );
                    let info_broadcast =
                        derive_network_interface_info_broadcast(family, &address, &raw_broadcast);

                    entries.push(HostInterfaceEntry {
                        name,
                        family,
                        address,
                        list_broadcast,
                        info_broadcast,
                        netmask,
                        hwaddr: None,
                        flags: interface_flags(ifa.ifa_flags),
                    });
                }
            }
            current = ifa.ifa_next;
        }
    }

    if entries.is_empty() {
        return None;
    }

    for entry in &mut entries {
        if let Some(hwaddr) = hwaddr_by_name.get(&entry.name) {
            entry.hwaddr = Some(*hwaddr);
        } else if let Some(hwaddr) = read_hwaddr_from_sysfs(&entry.name) {
            entry.hwaddr = Some(hwaddr);
        } else if entry.name == "lo" {
            entry.hwaddr = Some(loopback_hwaddr());
        }
    }

    Some(entries)
}

#[cfg(not(target_os = "linux"))]
fn host_interface_snapshot() -> Option<Vec<HostInterfaceEntry>> {
    None
}

fn interface_entry(name: &str, address: Value, full: bool) -> Value {
    if !full {
        return Value::cons(Value::string(name), address);
    }

    let (broadcast, netmask) = match &address {
        Value::Vector(values) if with_heap(|h| h.vector_len(*values)) == 9 => {
            (loopback_ipv6_broadcast(), loopback_ipv6_netmask())
        }
        _ => (loopback_ipv4_broadcast(), loopback_ipv4_netmask()),
    };

    Value::list(vec![Value::string(name), address, broadcast, netmask])
}

fn format_ipv4_network_address(items: &[i64], omit_port: bool) -> Option<String> {
    if items.len() != 4 && items.len() != 5 {
        return None;
    }
    let octets: Vec<u8> = items[..4]
        .iter()
        .map(|v| u8::try_from(*v).ok())
        .collect::<Option<Vec<_>>>()?;
    let addr = format!("{}.{}.{}.{}", octets[0], octets[1], octets[2], octets[3]);
    if items.len() == 5 && !omit_port {
        let port = u16::try_from(items[4]).ok()?;
        Some(format!("{addr}:{port}"))
    } else {
        Some(addr)
    }
}

fn format_ipv6_network_address(items: &[i64], omit_port: bool) -> Option<String> {
    if items.len() != 8 && items.len() != 9 {
        return None;
    }
    let mut segments = Vec::with_capacity(8);
    for value in &items[..8] {
        let segment = u16::try_from(*value).ok()?;
        segments.push(format!("{segment:x}"));
    }
    let addr = segments.join(":");
    if items.len() == 9 && !omit_port {
        let port = u16::try_from(items[8]).ok()?;
        Some(format!("[{addr}]:{port}"))
    } else {
        Some(addr)
    }
}

// ---------------------------------------------------------------------------
// Builtins (eval-dependent)
// ---------------------------------------------------------------------------

/// (backquote-delay-process ENV FORM) -> delayed-form
pub(crate) fn builtin_backquote_delay_process(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("backquote-delay-process", &args, 2)?;
    Ok(Value::list(vec![
        Value::Int(0),
        Value::symbol("quote"),
        Value::list(vec![args[1]]),
    ]))
}

/// (backquote-process FORM &optional LEVEL) -> processed
pub(crate) fn builtin_backquote_process(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("backquote-process", &args, 1)?;
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("backquote-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    Ok(Value::list(vec![Value::Int(0)]))
}

/// (clone-process PROCESS &optional NAME) -> process
pub(crate) fn builtin_clone_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("clone-process", &args, 1)?;
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("clone-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    Ok(Value::Int(id as i64))
}

/// (internal-default-interrupt-process &optional PROCESS CURRENT-GROUP) -> process-or-nil
pub(crate) fn builtin_internal_default_interrupt_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("internal-default-interrupt-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let (id, ret) = resolve_optional_process_with_explicit_return(eval, args.first())?;
    if let Some(proc) = eval.processes.get_mut(id) {
        proc.status = ProcessStatus::Signal(2);
    }
    Ok(ret)
}

/// (internal-default-signal-process PROCESS SIGNAL &optional CURRENT-GROUP) -> int-or-nil
pub(crate) fn builtin_internal_default_signal_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("internal-default-signal-process", &args, 2)?;
    if args.len() > 3 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("internal-default-signal-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }

    let signal_num = parse_signal_number(&args[1])?;
    match resolve_signal_process_target(eval, args.first())? {
        SignalProcessTarget::Process(id) => {
            if let Some(proc) = eval.processes.get_mut(id) {
                proc.status = ProcessStatus::Signal(signal_num);
            }
            Ok(Value::Int(0))
        }
        SignalProcessTarget::MissingNamedProcess => Ok(Value::Nil),
        SignalProcessTarget::Pid(pid) => Ok(Value::Int(if pid_exists(pid) { 0 } else { -1 })),
    }
}

/// (internal-default-process-filter PROCESS STRING) -> nil
pub(crate) fn builtin_internal_default_process_filter(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("internal-default-process-filter", &args, 2)?;
    let _id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    Ok(Value::Nil)
}

/// (internal-default-process-sentinel PROCESS STRING) -> nil
pub(crate) fn builtin_internal_default_process_sentinel(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("internal-default-process-sentinel", &args, 2)?;
    let _id = resolve_live_process_or_wrong_type(eval, &args[0])?;
    Ok(Value::Nil)
}

/// (isearch-process-search-char CHAR &optional COUNT) -> nil
pub(crate) fn builtin_isearch_process_search_char(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("isearch-process-search-char", &args, 1)?;
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("isearch-process-search-char"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    Ok(Value::Nil)
}

/// (isearch-process-search-string STRING MESSAGE) -> nil
pub(crate) fn builtin_isearch_process_search_string(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("isearch-process-search-string", &args, 2)?;
    Ok(Value::Nil)
}

/// (minibuffer--sort-preprocess-history HISTORY) -> nil
pub(crate) fn builtin_minibuffer_sort_preprocess_history(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("minibuffer--sort-preprocess-history", &args, 1)?;
    expect_sequence(&args[0])?;
    Ok(Value::Nil)
}

/// (print--preprocess OBJECT) -> nil
pub(crate) fn builtin_print_preprocess(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("print--preprocess", &args, 1)?;
    Ok(Value::Nil)
}

/// (syntax-propertize--in-process-p) -> nil
pub(crate) fn builtin_syntax_propertize_in_process_p(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("syntax-propertize--in-process-p", &args, 0)?;
    Ok(Value::Nil)
}

/// (tooltip-process-prompt-regexp PROCESS) -> nil
pub(crate) fn builtin_tooltip_process_prompt_regexp(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("tooltip-process-prompt-regexp", &args, 1)?;
    let _id = resolve_live_process_or_wrong_type(eval, &args[0])?;
    Ok(Value::Nil)
}

/// (window--adjust-process-windows) -> nil
pub(crate) fn builtin_window_adjust_process_windows(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("window--adjust-process-windows", &args, 0)?;
    Ok(Value::Nil)
}

/// (window--process-window-list) -> nil
pub(crate) fn builtin_window_process_window_list(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("window--process-window-list", &args, 0)?;
    Ok(Value::Nil)
}

/// (window-adjust-process-window-size PROCESS WINDOW) -> nil
pub(crate) fn builtin_window_adjust_process_window_size(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("window-adjust-process-window-size", &args, 2)?;
    expect_list(&args[1])?;
    Ok(Value::Nil)
}

/// (window-adjust-process-window-size-largest PROCESS WINDOW) -> nil
pub(crate) fn builtin_window_adjust_process_window_size_largest(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("window-adjust-process-window-size-largest", &args, 2)?;
    expect_list(&args[1])?;
    Ok(Value::Nil)
}

/// (window-adjust-process-window-size-smallest PROCESS WINDOW) -> nil
pub(crate) fn builtin_window_adjust_process_window_size_smallest(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("window-adjust-process-window-size-smallest", &args, 2)?;
    expect_list(&args[1])?;
    Ok(Value::Nil)
}

/// (format-network-address ADDRESS &optional OMIT-PORT) -> string-or-nil
pub(crate) fn builtin_format_network_address(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("format-network-address", &args, 1)?;
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("format-network-address"),
                Value::Int(args.len() as i64),
            ],
        ));
    }

    let omit_port = args.get(1).is_some_and(Value::is_truthy);
    match &args[0] {
        Value::Str(s) => Ok(Value::string(with_heap(|h| h.get_string(*s).clone()))),
        Value::Nil => Ok(Value::Nil),
        Value::Vector(_) => {
            let Some(items) = vector_nonnegative_integers(&args[0]) else {
                return Ok(Value::Nil);
            };
            if let Some(ipv4) = format_ipv4_network_address(&items, omit_port) {
                return Ok(Value::string(ipv4));
            }
            if let Some(ipv6) = format_ipv6_network_address(&items, omit_port) {
                return Ok(Value::string(ipv6));
            }
            Ok(Value::Nil)
        }
        Value::Cons(_) => {
            let first = list_to_vec(&args[0])
                .and_then(|items| items.first().cloned())
                .and_then(|v| value_as_nonnegative_integer(&v));
            if let Some(family) = first {
                Ok(Value::string(format!("<Family {family}>")))
            } else {
                Ok(Value::Nil)
            }
        }
        _ => Ok(Value::Nil),
    }
}

/// (network-interface-list &optional FULL FAMILY) -> interface-list
pub(crate) fn builtin_network_interface_list(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("network-interface-list"),
                Value::Int(args.len() as i64),
            ],
        ));
    }

    let full = args.first().is_some_and(Value::is_truthy);
    let family = args.get(1).cloned().unwrap_or(Value::Nil);
    let include_ipv4 = if family.is_nil() {
        true
    } else {
        matches!(family.as_symbol_name(), Some("ipv4"))
    };
    let include_ipv6 = if family.is_nil() {
        true
    } else {
        matches!(family.as_symbol_name(), Some("ipv6"))
    };
    if !family.is_nil() && !include_ipv4 && !include_ipv6 {
        return Err(signal(
            "error",
            vec![Value::string("Unsupported address family")],
        ));
    }

    let mut entries = Vec::new();
    if let Some(host_entries) = host_interface_snapshot() {
        for entry in host_entries.into_iter().rev() {
            let include = match entry.family {
                NetworkAddressFamily::Ipv4 => include_ipv4,
                NetworkAddressFamily::Ipv6 => include_ipv6,
            };
            if !include {
                continue;
            }

            if full {
                entries.push(Value::list(vec![
                    Value::string(entry.name),
                    entry.address,
                    entry.list_broadcast,
                    entry.netmask,
                ]));
            } else {
                entries.push(Value::cons(Value::string(entry.name), entry.address));
            }
        }
    }

    if entries.is_empty() {
        if include_ipv6 {
            entries.push(interface_entry("lo", loopback_ipv6_address(), full));
        }
        if include_ipv4 {
            entries.push(interface_entry("lo", loopback_ipv4_address(), full));
        }
    }
    Ok(Value::list(entries))
}

/// (network-interface-info IFNAME) -> interface-info-or-nil
pub(crate) fn builtin_network_interface_info(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("network-interface-info", &args, 1)?;
    let ifname_raw = expect_string_strict(&args[0])?;
    // Match C-string interface-name handling: embedded NUL truncates lookup.
    let ifname = ifname_raw.split('\0').next().unwrap_or_default();
    // Emacs applies IFNAMSIZ-style byte limits, not character counts.
    if ifname.len() >= 16 {
        return Err(signal(
            "error",
            vec![Value::string("interface name too long")],
        ));
    }

    if let Some(host_entries) = host_interface_snapshot() {
        let mut first_match: Option<HostInterfaceEntry> = None;
        let mut ipv4_match: Option<HostInterfaceEntry> = None;

        for entry in host_entries {
            if entry.name != ifname {
                continue;
            }
            if first_match.is_none() {
                first_match = Some(entry.clone());
            }
            if entry.family == NetworkAddressFamily::Ipv4 {
                ipv4_match = Some(entry);
                break;
            }
        }

        if let Some(entry) = ipv4_match.or(first_match) {
            return Ok(Value::list(vec![
                entry.address,
                entry.info_broadcast,
                entry.netmask,
                entry.hwaddr.unwrap_or(Value::Nil),
                entry.flags,
            ]));
        }
    }

    if ifname == "lo" {
        return Ok(Value::list(vec![
            loopback_ipv4_address(),
            loopback_ipv4_broadcast(),
            loopback_ipv4_netmask(),
            loopback_hwaddr(),
            loopback_flags(),
        ]));
    }

    Ok(Value::Nil)
}

/// (network-lookup-address-info NAME &optional FAMILY HINTS) -> address-list
pub(crate) fn builtin_network_lookup_address_info(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("network-lookup-address-info", &args, 1)?;
    if args.len() > 3 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("network-lookup-address-info"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let name = expect_string_strict(&args[0])?;

    let family = args.get(1).cloned().unwrap_or(Value::Nil);
    let hints = args.get(2).cloned().unwrap_or(Value::Nil);
    if !hints.is_nil() {
        return Err(signal(
            "error",
            vec![Value::string("Unsupported hints value")],
        ));
    }

    let lookup_family = if family.is_nil() {
        None
    } else if matches!(family.as_symbol_name(), Some("ipv4")) {
        Some(NetworkAddressFamily::Ipv4)
    } else if matches!(family.as_symbol_name(), Some("ipv6")) {
        Some(NetworkAddressFamily::Ipv6)
    } else {
        return Err(signal("error", vec![Value::string("Unsupported family")]));
    };
    let entries = resolve_network_lookup_addresses(&name, lookup_family);
    Ok(Value::list(entries))
}

/// (signal-names) -> list-of-signal-name-strings
pub(crate) fn builtin_signal_names(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("signal-names", &args, 0)?;
    let names = vec![
        "RTMAX", "RTMAX-1", "RTMAX-2", "RTMAX-3", "RTMAX-4", "RTMAX-5", "RTMAX-6", "RTMAX-7",
        "RTMAX-8", "RTMAX-9", "RTMAX-10", "RTMAX-11", "RTMAX-12", "RTMAX-13", "RTMAX-14",
        "RTMIN+15", "RTMIN+14", "RTMIN+13", "RTMIN+12", "RTMIN+11", "RTMIN+10", "RTMIN+9",
        "RTMIN+8", "RTMIN+7", "RTMIN+6", "RTMIN+5", "RTMIN+4", "RTMIN+3", "RTMIN+2", "RTMIN+1",
        "RTMIN", "SYS", "PWR", "POLL", "WINCH", "PROF", "VTALRM", "XFSZ", "XCPU", "URG", "TTOU",
        "TTIN", "TSTP", "STOP", "CONT", "CHLD", "STKFLT", "TERM", "ALRM", "PIPE", "USR2", "SEGV",
        "USR1", "KILL", "FPE", "BUS", "ABRT", "TRAP", "ILL", "QUIT", "INT", "HUP", "EXIT",
    ];
    Ok(Value::list(
        names.into_iter().map(Value::string).collect::<Vec<_>>(),
    ))
}

/// (list-system-processes) -> process-id-list
pub(crate) fn builtin_list_system_processes(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("list-system-processes", &args, 0)?;

    let mut pids: Vec<i64> = std::fs::read_dir("/proc")
        .ok()
        .into_iter()
        .flat_map(|entries| entries.filter_map(Result::ok))
        .filter_map(|entry| entry.file_name().to_string_lossy().parse::<i64>().ok())
        .collect();
    pids.sort_unstable();
    Ok(Value::list(pids.into_iter().map(Value::Int).collect()))
}

/// (num-processors &optional QUERY) -> integer
pub(crate) fn builtin_num_processors(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 1 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("num-processors"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let count = std::thread::available_parallelism()
        .map(|n| n.get() as i64)
        .unwrap_or(1);
    Ok(Value::Int(count))
}

/// (list-processes &optional QUERY-ONLY BUFFER) -> nil
pub(crate) fn builtin_list_processes(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("list-processes"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    Ok(Value::Nil)
}

/// (list-processes--refresh) -> row-spec
pub(crate) fn builtin_list_processes_refresh(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("list-processes--refresh", &args, 0)?;
    let spacer = Value::string_with_text_properties(
        " ",
        vec![StringTextPropertyRun {
            start: 0,
            end: 1,
            plist: Value::list(vec![
                Value::symbol("display"),
                Value::list(vec![
                    Value::symbol("space"),
                    Value::keyword(":align-to"),
                    Value::list(vec![
                        Value::symbol("+"),
                        Value::symbol("header-line-indent-width"),
                        Value::Int(0),
                    ]),
                ]),
            ]),
        }],
    );
    Ok(Value::list(vec![
        Value::string(""),
        Value::symbol("header-line-indent"),
        spacer,
    ]))
}

/// (make-network-process &rest ARGS) -> process-or-nil
pub(crate) fn builtin_make_network_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.is_empty() {
        return Ok(Value::Nil);
    }

    let mut name: Option<String> = None;
    let mut service: Option<Value> = None;
    let mut server = false;

    let mut i = 0usize;
    while i < args.len() {
        let key = &args[i];
        let value = args.get(i + 1).cloned().unwrap_or(Value::Nil);
        let Some(key_name) = keyword_name(key) else {
            i += 1;
            continue;
        };
        match key_name {
            ":name" => {
                name = Some(expect_process_name_string(&value)?);
            }
            ":service" => {
                service = Some(value);
            }
            ":server" => {
                server = value.is_truthy();
            }
            _ => {}
        }
        i += 2;
    }

    let Some(name) = name else {
        return Err(signal(
            "error",
            vec![Value::string("Missing :name keyword parameter")],
        ));
    };

    let service = service.unwrap_or(Value::Nil);
    if service.is_nil() {
        return Err(signal_wrong_type_string(Value::Nil));
    }
    if !server {
        return Err(signal(
            "file-error",
            vec![
                Value::string("make client process failed"),
                Value::string("Connection refused"),
                Value::keyword(":name"),
                Value::string(name),
                Value::keyword(":service"),
                service,
            ],
        ));
    }

    let id = eval.processes.create_process_with_kind(
        name,
        None,
        "network".to_string(),
        Vec::new(),
        ProcessKind::Network,
    );
    let current_thread = eval
        .threads
        .thread_handle(eval.threads.current_thread_id())
        .unwrap_or(Value::Nil);
    if let Some(proc) = eval.processes.get_mut(id) {
        proc.thread = current_thread;
    }
    Ok(Value::Int(id as i64))
}

/// (make-pipe-process &rest ARGS) -> process-or-nil
pub(crate) fn builtin_make_pipe_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.is_empty() {
        return Ok(Value::Nil);
    }

    let mut name: Option<String> = None;
    let mut buffer_name: Option<Option<String>> = None;

    let mut i = 0usize;
    while i < args.len() {
        let key = &args[i];
        let value = args.get(i + 1).cloned().unwrap_or(Value::Nil);
        let Some(key_name) = keyword_name(key) else {
            i += 1;
            continue;
        };
        match key_name {
            ":name" => {
                name = Some(expect_process_name_string(&value)?);
            }
            ":buffer" => {
                buffer_name = Some(parse_make_process_buffer(eval, &value)?);
            }
            _ => {}
        }
        i += 2;
    }

    let Some(name) = name else {
        return Err(signal(
            "error",
            vec![Value::string("Missing :name keyword parameter")],
        ));
    };

    let resolved_buffer_name = match buffer_name {
        Some(explicit) => explicit,
        None => {
            if eval.buffers.find_buffer_by_name(&name).is_none() {
                let _ = eval.buffers.create_buffer(&name);
            }
            Some(name.clone())
        }
    };

    let id = eval.processes.create_process_with_kind(
        name,
        resolved_buffer_name,
        "pipe".to_string(),
        Vec::new(),
        ProcessKind::Pipe,
    );
    let current_thread = eval
        .threads
        .thread_handle(eval.threads.current_thread_id())
        .unwrap_or(Value::Nil);
    if let Some(proc) = eval.processes.get_mut(id) {
        proc.thread = current_thread;
    }
    Ok(Value::Int(id as i64))
}

/// (make-serial-process &rest ARGS) -> process-or-nil
pub(crate) fn builtin_make_serial_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.is_empty() {
        return Ok(Value::Nil);
    }

    let mut name: Option<String> = None;
    let mut port: Option<String> = None;
    let mut speed: Option<Value> = None;

    let mut i = 0usize;
    while i < args.len() {
        let key = &args[i];
        let value = args.get(i + 1).cloned().unwrap_or(Value::Nil);
        let Some(key_name) = keyword_name(key) else {
            i += 1;
            continue;
        };
        match key_name {
            ":name" => {
                name = Some(expect_process_name_string(&value)?);
            }
            ":port" => {
                if value.is_nil() {
                    port = None;
                } else {
                    port = Some(expect_string_strict(&value)?);
                }
            }
            ":speed" => {
                speed = Some(value);
            }
            _ => {}
        }
        i += 2;
    }

    if port.is_none() {
        return Err(signal("error", vec![Value::string("No port specified")]));
    }
    if speed.is_none() {
        return Err(signal("error", vec![Value::string(":speed not specified")]));
    }

    let id = eval.processes.create_process_with_kind(
        name.unwrap_or_else(|| "serial".to_string()),
        None,
        "serial".to_string(),
        Vec::new(),
        ProcessKind::Serial,
    );
    Ok(Value::Int(id as i64))
}

/// (serial-process-configure &rest ARGS) -> nil
pub(crate) fn builtin_serial_process_configure(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    let mut process_id: Option<ProcessId> = None;
    let mut i = 0usize;
    while i < args.len() {
        let key = &args[i];
        let Some(key_name) = keyword_name(key) else {
            i += 1;
            continue;
        };
        let value = args.get(i + 1).cloned().unwrap_or(Value::Nil);
        match key_name {
            ":process" => {
                if value.is_nil() {
                    process_id = None;
                } else {
                    process_id = Some(resolve_process_or_missing_error(eval, &value)?);
                }
            }
            ":name" => match value {
                Value::Str(name) => {
                    let name_str = with_heap(|h| h.get_string(name).clone());
                    process_id = Some(
                        eval.processes
                            .find_by_name(&name_str)
                            .ok_or_else(|| signal_process_does_not_exist(&name_str))?,
                    );
                }
                other => return Err(signal_wrong_type_processp(other)),
            },
            _ => {}
        }
        i += 2;
    }

    let id = match process_id {
        Some(id) => id,
        None => resolve_optional_process_or_current_buffer(eval, None)?,
    };
    let proc = eval
        .processes
        .get(id)
        .ok_or_else(|| signal_wrong_type_processp(Value::Int(id as i64)))?;
    if proc.kind != ProcessKind::Serial {
        return Err(signal("error", vec![Value::string("Not a serial process")]));
    }
    Ok(Value::Nil)
}

/// (set-network-process-option PROCESS OPTION VALUE &optional NO-ERROR) -> nil
pub(crate) fn builtin_set_network_process_option(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() < 3 || args.len() > 4 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("set-network-process-option"),
                Value::Int(args.len() as i64),
            ],
        ));
    }

    let id = resolve_live_process_or_wrong_type(eval, &args[0])?;
    let proc = eval.processes.get(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    if args[1].as_symbol_name().is_none() {
        return Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("symbolp"), args[1]],
        ));
    }
    if proc.kind != ProcessKind::Network {
        return Err(signal(
            "error",
            vec![Value::string("Process is not a network process")],
        ));
    }
    if args.get(3).is_some_and(Value::is_truthy) {
        return Ok(Value::Nil);
    }
    Err(signal(
        "error",
        vec![Value::string("Unknown or unsupported option")],
    ))
}

/// (start-process NAME BUFFER PROGRAM &rest ARGS) -> process-id
pub(crate) fn builtin_start_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("start-process", &args, 3)?;
    let name = expect_process_name_string(&args[0])?;
    let buffer = parse_make_process_buffer(eval, &args[1])?;
    let program = if args[2].is_nil() {
        "nil".to_string()
    } else {
        expect_string_strict(&args[2])?
    };
    let proc_args: Vec<String> = args[3..]
        .iter()
        .map(expect_string_strict)
        .collect::<Result<Vec<_>, _>>()?;

    let id = eval
        .processes
        .create_process(name, buffer, program, proc_args);
    Ok(Value::Int(id as i64))
}

/// (start-process-shell-command NAME BUFFER COMMAND) -> process-id
pub(crate) fn builtin_start_process_shell_command(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("start-process-shell-command", &args, 3)?;
    let name = expect_process_name_string(&args[0])?;
    let buffer = parse_make_process_buffer(eval, &args[1])?;
    let command = expect_string_strict(&args[2])?;
    let id = eval.processes.create_process(
        name,
        buffer,
        "sh".to_string(),
        vec!["-c".to_string(), command],
    );
    Ok(Value::Int(id as i64))
}

/// (start-file-process NAME BUFFER PROGRAM &rest PROGRAM-ARGS) -> process-id
pub(crate) fn builtin_start_file_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("start-file-process", &args, 3)?;
    let name = expect_process_name_string(&args[0])?;
    let buffer = parse_make_process_buffer(eval, &args[1])?;
    let program = if args[2].is_nil() {
        "nil".to_string()
    } else {
        expect_string_strict(&args[2])?
    };
    let proc_args = parse_string_args_strict(&args[3..])?;
    let id = eval
        .processes
        .create_process(name, buffer, program, proc_args);
    Ok(Value::Int(id as i64))
}

/// (start-file-process-shell-command NAME BUFFER COMMAND) -> process-id
pub(crate) fn builtin_start_file_process_shell_command(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("start-file-process-shell-command", &args, 3)?;
    let name = expect_process_name_string(&args[0])?;
    let buffer = parse_make_process_buffer(eval, &args[1])?;
    let command = expect_string_strict(&args[2])?;
    let id = eval.processes.create_process(
        name,
        buffer,
        "sh".to_string(),
        vec!["-c".to_string(), command],
    );
    Ok(Value::Int(id as i64))
}

/// (call-process PROGRAM &optional INFILE DESTINATION DISPLAY &rest ARGS)
///
/// Runs the command synchronously using `std::process::Command`, captures
/// output.  Returns the exit code as an integer.
pub(crate) fn builtin_call_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("call-process", &args, 1)?;
    let program = expect_string_strict(&args[0])?;
    let infile = parse_optional_infile(&args, 1)?;
    let destination = args.get(2).unwrap_or(&Value::Nil);
    let cmd_args = if args.len() > 4 {
        parse_string_args_strict(&args[4..])?
    } else {
        Vec::new()
    };

    // DISPLAY (arg index 3): ignored in this implementation.
    run_process_command(eval, &program, infile, destination, &cmd_args)
}

/// (call-process-shell-command COMMAND &optional INFILE DESTINATION DISPLAY &rest ARGS)
pub(crate) fn builtin_call_process_shell_command(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("call-process-shell-command", &args, 1)?;
    let command = sequence_value_to_env_string(&args[0])?;
    let infile = parse_optional_infile(&args, 1)?;
    let destination = args.get(2).unwrap_or(&Value::Nil);
    let cmd_args = if args.len() > 4 {
        parse_sequence_args(&args[4..])?
    } else {
        Vec::new()
    };
    let shell_command = shell_command_with_args(&command, &cmd_args);
    let shell_args = vec!["-c".to_string(), shell_command];

    // DISPLAY (arg index 3): ignored in this implementation.
    run_process_command(eval, "sh", infile, destination, &shell_args)
}

/// (process-file PROGRAM &optional INFILE DESTINATION DISPLAY &rest ARGS)
pub(crate) fn builtin_process_file(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("process-file", &args, 1)?;
    let program = expect_string_strict(&args[0])?;
    let infile = parse_optional_infile(&args, 1)?;
    let destination = args.get(2).unwrap_or(&Value::Nil);
    let cmd_args = if args.len() > 4 {
        parse_string_args_strict(&args[4..])?
    } else {
        Vec::new()
    };
    run_process_command(eval, &program, infile, destination, &cmd_args)
}

/// (process-file-shell-command COMMAND &optional INFILE DESTINATION DISPLAY &rest ARGS)
pub(crate) fn builtin_process_file_shell_command(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("process-file-shell-command", &args, 1)?;
    let command = sequence_value_to_env_string(&args[0])?;
    let infile = parse_optional_infile(&args, 1)?;
    let destination = args.get(2).unwrap_or(&Value::Nil);
    let cmd_args = if args.len() > 4 {
        parse_sequence_args(&args[4..])?
    } else {
        Vec::new()
    };
    let shell_command = shell_command_with_args(&command, &cmd_args);
    let shell_args = vec!["-c".to_string(), shell_command];

    // DISPLAY (arg index 3): ignored in this implementation.
    run_process_command(eval, "sh", infile, destination, &shell_args)
}

/// (process-lines PROGRAM &rest ARGS) -> list of lines
pub(crate) fn builtin_process_lines(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("process-lines", &args, 1)?;
    let program = expect_string_strict(&args[0])?;
    let cmd_args = parse_string_args_strict(&args[1..])?;
    let (status, stdout) = run_process_capture_output(&program, &cmd_args)?;
    if status != 0 {
        return Err(signal_process_lines_status_error(&program, status));
    }
    Ok(parse_output_lines(&stdout))
}

/// (process-lines-ignore-status PROGRAM &rest ARGS) -> list of lines
pub(crate) fn builtin_process_lines_ignore_status(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("process-lines-ignore-status", &args, 1)?;
    let program = expect_string_strict(&args[0])?;
    let cmd_args = parse_string_args_strict(&args[1..])?;
    let (_, stdout) = run_process_capture_output(&program, &cmd_args)?;
    Ok(parse_output_lines(&stdout))
}

/// (process-lines-handling-status PROGRAM STATUS-HANDLER &rest ARGS) -> list of lines
pub(crate) fn builtin_process_lines_handling_status(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("process-lines-handling-status", &args, 2)?;
    let program = expect_string_strict(&args[0])?;
    let status_handler = args[1];
    let cmd_args = parse_string_args_strict(&args[2..])?;
    let (status, stdout) = run_process_capture_output(&program, &cmd_args)?;
    let lines = parse_output_lines(&stdout);

    if !status_handler.is_nil() {
        let _ = eval.apply(status_handler, vec![Value::Int(status as i64)])?;
    } else if status != 0 {
        return Err(signal_process_lines_status_error(&program, status));
    }

    Ok(lines)
}

/// (call-process-region START END PROGRAM &optional DELETE DESTINATION DISPLAY &rest ARGS)
///
/// Pipes buffer region from START to END through PROGRAM.
pub(crate) fn builtin_call_process_region(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("call-process-region", &args, 3)?;
    let program = expect_string_strict(&args[2])?;

    let delete = args.len() > 3 && args[3].is_truthy();
    let destination = if args.len() > 4 {
        &args[4]
    } else {
        &Value::Nil
    };
    let destination_spec = parse_call_process_destination(eval, destination)?;
    // DISPLAY (arg index 5): ignored.

    let cmd_args = if args.len() > 6 {
        parse_string_args_strict(&args[6..])?
    } else {
        Vec::new()
    };

    // START semantics:
    // - nil => use whole buffer contents, ignore END
    // - string => use that string as stdin, ignore END
    // - integer/marker => use region START..END
    let region_text = match &args[0] {
        Value::Nil => {
            let (text, maybe_delete_range) = {
                let buf = eval
                    .buffers
                    .current_buffer()
                    .ok_or_else(|| signal("error", vec![Value::string("No current buffer")]))?;
                let len = buf.text.len();
                (buf.text.text_range(0, len), (0usize, len))
            };
            if delete {
                let buf = eval
                    .buffers
                    .current_buffer_mut()
                    .ok_or_else(|| signal("error", vec![Value::string("No current buffer")]))?;
                buf.delete_region(maybe_delete_range.0, maybe_delete_range.1);
            }
            text
        }
        Value::Str(s) => {
            if delete {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("integer-or-marker-p"), args[0]],
                ));
            }
            with_heap(|h| h.get_string(*s).clone())
        }
        _ => {
            let start = expect_int_or_marker(&args[0])?;
            let end = expect_int_or_marker(&args[1])?;
            let (text, region_beg, region_end) = {
                let buf = eval
                    .buffers
                    .current_buffer()
                    .ok_or_else(|| signal("error", vec![Value::string("No current buffer")]))?;
                let (region_beg, region_end) = checked_region_bytes(buf, start, end)?;
                (
                    buf.text.text_range(region_beg, region_end),
                    region_beg,
                    region_end,
                )
            };

            if delete {
                let buf = eval
                    .buffers
                    .current_buffer_mut()
                    .ok_or_else(|| signal("error", vec![Value::string("No current buffer")]))?;
                buf.delete_region(region_beg, region_end);
            }

            text
        }
    };

    use std::io::Write;
    if destination_spec.no_wait {
        let mut command = Command::new(&program);
        command
            .args(&cmd_args)
            .stdin(Stdio::piped())
            .stdout(Stdio::null());
        match destination_spec.stderr {
            StderrTarget::Discard | StderrTarget::ToStdoutTarget => {
                command.stderr(Stdio::null());
            }
            StderrTarget::File => {
                let path = destination_spec.stderr_file.as_ref().ok_or_else(|| {
                    signal("error", vec![Value::string("Missing stderr file target")])
                })?;
                let file = OpenOptions::new()
                    .create(true)
                    .truncate(true)
                    .write(true)
                    .open(path)
                    .map_err(|e| signal_process_io("Writing process output", Some(path), e))?;
                command.stderr(Stdio::from(file));
            }
        };

        let mut child = command
            .spawn()
            .map_err(|e| signal_process_io("Searching for program", Some(&program), e))?;

        if let Some(mut stdin) = child.stdin.take() {
            let _ = stdin.write_all(region_text.as_bytes());
        }

        std::thread::spawn(move || {
            let _ = child.wait();
        });

        return Ok(Value::Nil);
    }

    let mut child = Command::new(&program)
        .args(&cmd_args)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| signal_process_io("Searching for program", Some(&program), e))?;

    if let Some(mut stdin) = child.stdin.take() {
        let _ = stdin.write_all(region_text.as_bytes());
    }

    let output = child
        .wait_with_output()
        .map_err(|e| signal_process_io("Process error", None, e))?;

    let exit_code = output.status.code().unwrap_or(-1);
    route_captured_output(eval, &destination_spec, &output.stdout, &output.stderr)?;
    Ok(Value::Int(exit_code as i64))
}

/// (delete-process PROCESS) -> nil
pub(crate) fn builtin_delete_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 1 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("delete-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let id = if let Some(process) = args.first() {
        if process.is_nil() {
            resolve_optional_process_or_current_buffer(eval, args.first())?
        } else {
            resolve_process_or_missing_error_any(eval, process)?
        }
    } else {
        resolve_optional_process_or_current_buffer(eval, args.first())?
    };
    eval.processes.delete_process(id);
    Ok(Value::Nil)
}

/// (continue-process &optional PROCESS CURRENT-GROUP) -> process-or-nil
pub(crate) fn builtin_continue_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("continue-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let (id, ret) = resolve_optional_process_with_explicit_return(eval, args.first())?;
    if let Some(proc) = eval.processes.get_mut(id) {
        proc.status = ProcessStatus::Run;
    }
    Ok(ret)
}

/// (interrupt-process &optional PROCESS CURRENT-GROUP) -> process-or-nil
pub(crate) fn builtin_interrupt_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("interrupt-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let (id, ret) = resolve_optional_process_with_explicit_return(eval, args.first())?;
    if let Some(proc) = eval.processes.get_mut(id) {
        proc.status = ProcessStatus::Signal(2);
    }
    Ok(ret)
}

/// (kill-process &optional PROCESS CURRENT-GROUP) -> process-or-nil
pub(crate) fn builtin_kill_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![Value::symbol("kill-process"), Value::Int(args.len() as i64)],
        ));
    }
    let (id, ret) = resolve_optional_process_with_explicit_return(eval, args.first())?;
    if let Some(proc) = eval.processes.get_mut(id) {
        proc.status = ProcessStatus::Signal(9);
    }
    Ok(ret)
}

/// (signal-process PROCESS SIGNAL &optional CURRENT-GROUP) -> int-or-nil
pub(crate) fn builtin_signal_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("signal-process", &args, 2)?;
    if args.len() > 3 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("signal-process"),
                Value::Int(args.len() as i64),
            ],
        ));
    }

    if let Some(process) = args.first() {
        if !process.is_nil() && is_stale_process_id_designator(eval, process) {
            return Ok(Value::Int(-1));
        }
    }

    let signal_num = parse_signal_number(&args[1])?;
    match resolve_signal_process_target(eval, args.first())? {
        SignalProcessTarget::Process(id) => {
            if let Some(proc) = eval.processes.get_mut(id) {
                proc.status = ProcessStatus::Signal(signal_num);
            }
            Ok(Value::Int(0))
        }
        SignalProcessTarget::MissingNamedProcess => Ok(Value::Nil),
        SignalProcessTarget::Pid(pid) => Ok(Value::Int(if pid_exists(pid) { 0 } else { -1 })),
    }
}

/// (stop-process &optional PROCESS CURRENT-GROUP) -> process-or-nil
pub(crate) fn builtin_stop_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![Value::symbol("stop-process"), Value::Int(args.len() as i64)],
        ));
    }
    let (id, ret) = resolve_optional_process_with_explicit_return(eval, args.first())?;
    if let Some(proc) = eval.processes.get_mut(id) {
        proc.status = ProcessStatus::Stop;
    }
    Ok(ret)
}

/// (quit-process &optional PROCESS CURRENT-GROUP) -> process-or-nil
pub(crate) fn builtin_quit_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![Value::symbol("quit-process"), Value::Int(args.len() as i64)],
        ));
    }
    let (id, ret) = resolve_optional_process_with_explicit_return(eval, args.first())?;
    let _ = eval.processes.get(id);
    Ok(ret)
}

/// (process-attributes PID) -> alist-or-nil
pub(crate) fn builtin_process_attributes(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-attributes", &args, 1)?;
    let pid = match &args[0] {
        Value::Int(n) => *n,
        Value::Char(c) => *c as i64,
        _ => return Err(signal_wrong_type_numberp(args[0])),
    };
    if !pid_exists(pid) {
        return Ok(Value::Nil);
    }

    let mut attrs = Vec::new();
    if let Some((euid, egid)) = parse_effective_ids_from_proc_status(pid) {
        attrs.push(Value::cons(
            Value::symbol("group"),
            Value::string(lookup_group_name(egid).unwrap_or_else(|| egid.to_string())),
        ));
        attrs.push(Value::cons(Value::symbol("egid"), Value::Int(egid as i64)));
        attrs.push(Value::cons(
            Value::symbol("user"),
            Value::string(lookup_user_name(euid).unwrap_or_else(|| euid.to_string())),
        ));
        attrs.push(Value::cons(Value::symbol("euid"), Value::Int(euid as i64)));
    }

    let stat = parse_proc_stat_snapshot(pid).unwrap_or_else(|| ProcStatSnapshot::fallback(pid));
    attrs.push(Value::cons(Value::symbol("comm"), Value::string(stat.comm)));
    attrs.push(Value::cons(Value::symbol("state"), Value::string(stat.state)));
    attrs.push(Value::cons(Value::symbol("ppid"), Value::Int(stat.ppid)));
    attrs.push(Value::cons(Value::symbol("pgrp"), Value::Int(stat.pgrp)));
    attrs.push(Value::cons(Value::symbol("sess"), Value::Int(stat.sess)));
    attrs.push(Value::cons(Value::symbol("tpgid"), Value::Int(stat.tpgid)));
    attrs.push(Value::cons(Value::symbol("minflt"), Value::Int(stat.minflt)));
    attrs.push(Value::cons(Value::symbol("majflt"), Value::Int(stat.majflt)));
    attrs.push(Value::cons(Value::symbol("cminflt"), Value::Int(stat.cminflt)));
    attrs.push(Value::cons(Value::symbol("cmajflt"), Value::Int(stat.cmajflt)));
    attrs.push(Value::cons(
        Value::symbol("utime"),
        time_list_from_ticks(stat.utime_ticks, clock_ticks_per_second()),
    ));
    attrs.push(Value::cons(
        Value::symbol("stime"),
        time_list_from_ticks(stat.stime_ticks, clock_ticks_per_second()),
    ));
    let total_ticks = stat.utime_ticks.saturating_add(stat.stime_ticks);
    attrs.push(Value::cons(
        Value::symbol("time"),
        time_list_from_ticks(total_ticks, clock_ticks_per_second()),
    ));
    attrs.push(Value::cons(
        Value::symbol("cutime"),
        time_list_from_ticks(stat.cutime_ticks, clock_ticks_per_second()),
    ));
    attrs.push(Value::cons(
        Value::symbol("cstime"),
        time_list_from_ticks(stat.cstime_ticks, clock_ticks_per_second()),
    ));
    let total_child_ticks = stat.cutime_ticks.saturating_add(stat.cstime_ticks);
    attrs.push(Value::cons(
        Value::symbol("ctime"),
        time_list_from_ticks(total_child_ticks, clock_ticks_per_second()),
    ));
    attrs.push(Value::cons(Value::symbol("pri"), Value::Int(stat.pri)));
    attrs.push(Value::cons(Value::symbol("nice"), Value::Int(stat.nice)));
    attrs.push(Value::cons(Value::symbol("thcount"), Value::Int(stat.thcount)));
    let hz = clock_ticks_per_second();
    let start_epoch_time = parse_proc_boot_time_secs().map(|boot_secs| {
        let (start_rel_secs, start_rel_usecs) = ticks_to_secs_usecs(stat.start_ticks, hz);
        (boot_secs.saturating_add(start_rel_secs), start_rel_usecs)
    });
    let (start_secs, start_usecs) = start_epoch_time.unwrap_or((0, 0));
    attrs.push(Value::cons(
        Value::symbol("start"),
        time_list_from_secs_usecs(start_secs, start_usecs),
    ));
    attrs.push(Value::cons(Value::symbol("vsize"), Value::Int(stat.vsize)));
    attrs.push(Value::cons(Value::symbol("rss"), Value::Int(stat.rss)));
    let elapsed = match (now_epoch_secs_usecs(), start_epoch_time) {
        (Some(now), Some(start)) => nonnegative_time_diff(now, start),
        _ => (0, 0),
    };
    attrs.push(Value::cons(
        Value::symbol("etime"),
        time_list_from_secs_usecs(elapsed.0, elapsed.1),
    ));
    let elapsed_secs = elapsed.0 as f64 + (elapsed.1 as f64 / 1_000_000.0);
    let total_cpu_secs = if hz > 0 {
        (total_ticks as f64) / (hz as f64)
    } else {
        0.0
    };
    let pcpu = if elapsed_secs > 0.0 {
        (total_cpu_secs * 100.0) / elapsed_secs
    } else {
        0.0
    };
    attrs.push(Value::cons(
        Value::symbol("pcpu"),
        Value::Float(if pcpu.is_finite() { pcpu.max(0.0) } else { 0.0 }),
    ));
    let pmem = parse_total_memory_kb()
        .filter(|mem_total_kb| *mem_total_kb > 0)
        .map(|mem_total_kb| (stat.rss as f64 * 100.0) / mem_total_kb as f64)
        .unwrap_or(0.0);
    attrs.push(Value::cons(
        Value::symbol("pmem"),
        Value::Float(if pmem.is_finite() { pmem.max(0.0) } else { 0.0 }),
    ));
    attrs.push(Value::cons(
        Value::symbol("args"),
        Value::string(parse_proc_cmdline(pid)),
    ));
    attrs.push(Value::cons(
        Value::symbol("ttname"),
        Value::string(stat.ttname),
    ));

    Ok(Value::list(attrs))
}

/// (make-process &rest ARGS) -> process-or-nil
pub(crate) fn builtin_make_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.is_empty() {
        return Ok(Value::Nil);
    }

    let mut name: Option<String> = None;
    let mut buffer_name: Option<Option<String>> = None;
    let mut command: Option<Vec<String>> = None;

    let mut i = 0usize;
    while i < args.len() {
        let key = &args[i];
        let value = args.get(i + 1).cloned().unwrap_or(Value::Nil);
        let key_name = match key {
            Value::Keyword(k) => Some(resolve_sym(*k)),
            Value::Symbol(id) if resolve_sym(*id).starts_with(':') => Some(resolve_sym(*id)),
            _ => None,
        };
        match key_name {
            Some(":name") => match value {
                Value::Str(s) => name = Some(with_heap(|h| h.get_string(s).clone())),
                _ => {
                    return Err(signal(
                        "error",
                        vec![Value::string(":name value not a string")],
                    ))
                }
            },
            Some(":buffer") => buffer_name = Some(parse_make_process_buffer(eval, &value)?),
            Some(":command") => command = Some(parse_make_process_command(&value)?),
            _ => {}
        }
        i += 2;
    }

    let Some(name) = name else {
        return Err(signal(
            "error",
            vec![Value::string("Missing :name keyword parameter")],
        ));
    };

    let command = command.unwrap_or_default();
    let (program, argv) = if command.is_empty() {
        (String::new(), Vec::new())
    } else {
        (command[0].clone(), command[1..].to_vec())
    };
    let id = eval
        .processes
        .create_process(name, buffer_name.unwrap_or(None), program, argv);
    Ok(Value::Int(id as i64))
}

/// (process-send-string PROCESS STRING) -> nil
pub(crate) fn builtin_process_send_string(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-send-string", &args, 2)?;
    let input = expect_string_strict(&args[1])?;
    if let Value::Int(n) = args[0] {
        if n >= 0 && is_stale_process_id_designator(eval, &args[0]) {
            return Err(signal_process_not_running(eval, n as ProcessId));
        }
    }
    let id = resolve_process_or_missing_error(eval, &args[0])?;
    if !eval.processes.send_input(id, &input) {
        return Err(signal("error", vec![Value::string("Process not found")]));
    }
    Ok(Value::Nil)
}

/// (process-status PROCESS) -> symbol
pub(crate) fn builtin_process_status(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-status", &args, 1)?;
    let Some(id) = resolve_process_for_status(eval, &args[0])? else {
        return Ok(Value::Nil);
    };
    match eval.processes.get_any(id) {
        Some(proc) => match proc.status {
            ProcessStatus::Run => match proc.kind {
                ProcessKind::Network => Ok(Value::symbol("listen")),
                ProcessKind::Pipe => Ok(Value::symbol("open")),
                _ => Ok(Value::symbol("run")),
            },
            ProcessStatus::Stop => Ok(Value::symbol("stop")),
            ProcessStatus::Exit(_) => Ok(Value::symbol("exit")),
            ProcessStatus::Signal(_) => match proc.kind {
                ProcessKind::Real => Ok(Value::symbol("signal")),
                _ => Ok(Value::symbol("closed")),
            },
        },
        None => Ok(Value::Nil),
    }
}

/// (process-exit-status PROCESS) -> integer
pub(crate) fn builtin_process_exit_status(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-exit-status", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval
        .processes
        .get_any(id)
        .ok_or_else(|| signal_wrong_type_processp(args[0]))?;
    match proc.status {
        ProcessStatus::Exit(code) => Ok(Value::Int(code as i64)),
        ProcessStatus::Signal(sig) => {
            if proc.kind == ProcessKind::Real {
                Ok(Value::Int(sig as i64))
            } else {
                Ok(Value::Int(0))
            }
        }
        _ => Ok(Value::Int(0)),
    }
}

/// (process-list) -> list of process ids
pub(crate) fn builtin_process_list(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-list", &args, 0)?;
    let ids = eval.processes.list_processes();
    let values: Vec<Value> = ids.iter().map(|id| Value::Int(*id as i64)).collect();
    Ok(Value::list(values))
}

/// (process-name PROCESS) -> string
pub(crate) fn builtin_process_name(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-name", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    match eval.processes.get_any(id) {
        Some(proc) => Ok(Value::string(proc.name.clone())),
        None => Err(signal_wrong_type_processp(args[0])),
    }
}

/// (process-buffer PROCESS) -> string or nil
pub(crate) fn builtin_process_buffer(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-buffer", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    match eval.processes.get_any(id) {
        Some(proc) => match &proc.buffer_name {
            Some(name) => Ok(
                eval.buffers
                    .find_buffer_by_name(name)
                    .or_else(|| eval.buffers.find_dead_buffer_by_name(name))
                    .map(Value::Buffer)
                    .unwrap_or(Value::Nil),
            ),
            None => Ok(Value::Nil),
        },
        None => Err(signal_wrong_type_processp(args[0])),
    }
}

/// (process-coding-system PROCESS) -> (decode . encode)
pub(crate) fn builtin_process_coding_system(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-coding-system", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(Value::cons(
        proc.coding_decode,
        proc.coding_encode,
    ))
}

/// (process-datagram-address PROCESS) -> address-or-nil
pub(crate) fn builtin_process_datagram_address(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-datagram-address", &args, 1)?;
    let _id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    Ok(Value::Nil)
}

/// (process-inherit-coding-system-flag PROCESS) -> bool
pub(crate) fn builtin_process_inherit_coding_system_flag(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-inherit-coding-system-flag", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(Value::bool(proc.inherit_coding_system_flag))
}

/// (set-process-buffer PROCESS BUFFER) -> BUFFER
pub(crate) fn builtin_set_process_buffer(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-buffer", &args, 2)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let next_buffer_name = match &args[1] {
        Value::Nil => None,
        Value::Buffer(buffer_id) => Some(
            eval.buffers
                .get(*buffer_id)
                .ok_or_else(|| signal("error", vec![Value::string("Selecting deleted buffer")]))?
                .name
                .clone(),
        ),
        _ => return Err(signal_wrong_type_bufferp(args[1])),
    };
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.buffer_name = next_buffer_name;
    Ok(args[1])
}

/// (set-process-coding-system PROCESS &optional DECODING ENCODING) -> nil
pub(crate) fn builtin_set_process_coding_system(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("set-process-coding-system", &args, 1)?;
    if args.len() > 3 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("set-process-coding-system"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    if let Some(coding) = args.get(1) {
        proc.coding_decode = *coding;
        proc.coding_encode = args.get(2).cloned().unwrap_or(*coding);
    }
    Ok(Value::Nil)
}

/// (set-buffer-process-coding-system DECODING ENCODING) -> nil
pub(crate) fn builtin_set_buffer_process_coding_system(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-buffer-process-coding-system", &args, 2)?;
    let id = resolve_optional_process_or_current_buffer(eval, None)?;
    let proc = eval.processes.get_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), Value::Int(id as i64)],
        )
    })?;
    proc.coding_decode = args[0];
    proc.coding_encode = args[1];
    Ok(Value::Nil)
}

/// (set-process-datagram-address PROCESS ADDRESS) -> nil
pub(crate) fn builtin_set_process_datagram_address(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-datagram-address", &args, 2)?;
    let _id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    Ok(Value::Nil)
}

/// (set-process-inherit-coding-system-flag PROCESS FLAG) -> FLAG
pub(crate) fn builtin_set_process_inherit_coding_system_flag(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-inherit-coding-system-flag", &args, 2)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.inherit_coding_system_flag = args[1].is_truthy();
    Ok(args[1])
}

/// (set-process-thread PROCESS THREAD) -> thread-or-nil
pub(crate) fn builtin_set_process_thread(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-thread", &args, 2)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let value = if args[1].is_nil() {
        Value::Nil
    } else if eval.threads.thread_id_from_handle(&args[1]).is_some() {
        args[1]
    } else {
        return Err(signal_wrong_type_threadp(args[1]));
    };
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.thread = value;
    Ok(value)
}

/// (set-process-window-size PROCESS COLS ROWS) -> t
pub(crate) fn builtin_set_process_window_size(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-window-size", &args, 3)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let cols = expect_integer(&args[1])?;
    let rows = expect_integer(&args[2])?;
    let is_live = eval.processes.get(id).is_some();
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.window_cols = Some(cols);
    proc.window_rows = Some(rows);
    Ok(if is_live { Value::True } else { Value::Nil })
}

/// (process-kill-buffer-query-function) -> bool
pub(crate) fn builtin_process_kill_buffer_query_function(args: Vec<Value>) -> EvalResult {
    expect_args("process-kill-buffer-query-function", &args, 0)?;
    Ok(Value::True)
}

/// (process-menu-delete-process) -> nil
pub(crate) fn builtin_process_menu_delete_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-menu-delete-process", &args, 0)?;
    let current_buffer_name = eval
        .buffers
        .current_buffer()
        .map(|buffer| buffer.name.clone())
        .ok_or_else(|| signal("error", vec![Value::string("No current buffer")]))?;
    if eval
        .processes
        .find_by_buffer_name(&current_buffer_name)
        .is_some()
    {
        return Err(signal(
            "error",
            vec![Value::string(
                "Buffer does not seem to be associated with any file",
            )],
        ));
    }
    let _ = resolve_optional_process_or_current_buffer(eval, None)?;
    Ok(Value::Nil)
}

/// (process-menu-visit-buffer LINE) -> nil
pub(crate) fn builtin_process_menu_visit_buffer(
    _eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-menu-visit-buffer", &args, 1)?;
    let _line = expect_int_or_marker(&args[0])?;
    Err(signal(
        "wrong-type-argument",
        vec![Value::symbol("stringp"), Value::Nil],
    ))
}

/// (process-menu-mode) -> nil
pub(crate) fn builtin_process_menu_mode(args: Vec<Value>) -> EvalResult {
    expect_args("process-menu-mode", &args, 0)?;
    Ok(Value::Nil)
}

/// (process-tty-name PROCESS &optional STREAM) -> string-or-nil
pub(crate) fn builtin_process_tty_name(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("process-tty-name", &args, 1)?;
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("process-tty-name"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    let stream = args.get(1).cloned().unwrap_or(Value::Nil);
    let tty_value = || {
        proc.tty_name
            .as_ref()
            .map_or(Value::Nil, Value::string)
    };

    match stream {
        Value::Nil => Ok(tty_value()),
        Value::Symbol(sym) if resolve_sym(sym) == "stdin" => {
            if proc.tty_stdin {
                Ok(tty_value())
            } else {
                Ok(Value::Nil)
            }
        }
        Value::Symbol(sym) if resolve_sym(sym) == "stdout" => {
            if proc.tty_stdout {
                Ok(tty_value())
            } else {
                Ok(Value::Nil)
            }
        }
        Value::Symbol(sym) if resolve_sym(sym) == "stderr" => {
            if proc.tty_stderr {
                Ok(tty_value())
            } else {
                Ok(Value::Nil)
            }
        }
        other => Err(signal("error", vec![Value::string("Unknown stream"), other])),
    }
}

/// (process-mark PROCESS) -> marker
pub(crate) fn builtin_process_mark(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-mark", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(super::marker::make_marker_value(
        proc.buffer_name.as_deref(),
        None,
        false,
    ))
}

/// (process-type PROCESS) -> symbol
pub(crate) fn builtin_process_type(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-type", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(Value::symbol(match proc.kind {
        ProcessKind::Real => "real",
        ProcessKind::Network => "network",
        ProcessKind::Pipe => "pipe",
        ProcessKind::Serial => "serial",
    }))
}

/// (process-thread PROCESS) -> object-or-nil
pub(crate) fn builtin_process_thread(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-thread", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(proc.thread)
}

/// (process-send-region PROCESS START END) -> nil
pub(crate) fn builtin_process_send_region(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-send-region", &args, 3)?;

    if let Value::Int(n) = args[0] {
        if n >= 0 && is_stale_process_id_designator(eval, &args[0]) {
            let _ = expect_int_or_marker(&args[1])?;
            let _ = expect_int_or_marker(&args[2])?;
            return Err(signal_process_not_running(eval, n as ProcessId));
        }
    }

    let id = resolve_optional_process_or_current_buffer(eval, Some(&args[0]))?;
    let start = expect_int_or_marker(&args[1])?;
    let end = expect_int_or_marker(&args[2])?;

    let region_text = {
        let buf = eval
            .buffers
            .current_buffer()
            .ok_or_else(|| signal("error", vec![Value::string("No current buffer")]))?;
        let (region_beg, region_end) = checked_region_bytes(buf, start, end)?;
        buf.text.text_range(region_beg, region_end)
    };

    if !eval.processes.send_input(id, &region_text) {
        return Err(signal("error", vec![Value::string("Process not found")]));
    }
    Ok(Value::Nil)
}

/// (process-send-eof &optional PROCESS) -> process-or-nil
pub(crate) fn builtin_process_send_eof(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 1 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("process-send-eof"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    if let Some(process) = args.first() {
        if !process.is_nil() {
            if let Value::Int(n) = process {
                if *n >= 0 && is_stale_process_id_designator(eval, process) {
                    return Err(signal_process_not_running(eval, *n as ProcessId));
                }
            }
            let _id = resolve_process_or_missing_error(eval, process)?;
            return Ok(*process);
        }
    }
    let _id = resolve_optional_process_or_current_buffer(eval, args.first())?;
    Ok(Value::Nil)
}

/// (process-running-child-p &optional PROCESS) -> bool
pub(crate) fn builtin_process_running_child_p(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 1 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("process-running-child-p"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    if let Some(process) = args.first() {
        if let Value::Int(n) = process {
            if *n >= 0 && is_stale_process_id_designator(eval, process) {
                return Err(signal_process_not_active(eval, *n as ProcessId));
            }
        }
    }
    let _id = resolve_optional_process_or_current_buffer(eval, args.first())?;
    Ok(Value::Nil)
}

/// (accept-process-output &optional PROCESS SECONDS MILLISECS JUST-THIS-ONE) -> bool
///
/// Batch/runtime compatibility path: validates arguments, then returns nil.
pub(crate) fn builtin_accept_process_output(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    if args.len() > 4 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("accept-process-output"),
                Value::Int(args.len() as i64),
            ],
        ));
    }

    if let Some(process) = args.first() {
        if !process.is_nil() && resolve_live_process_designator(eval, process).is_none() {
            if is_stale_process_id_designator(eval, process) {
                return Ok(Value::Nil);
            }
            return Err(signal(
                "wrong-type-argument",
                vec![Value::symbol("processp"), *process],
            ));
        }
    }

    if let Some(seconds) = args.get(1) {
        if let Some(milliseconds) = args.get(2) {
            if !milliseconds.is_nil() && !matches!(milliseconds, Value::Int(_)) {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("fixnump"), *milliseconds],
                ));
            }
            if milliseconds.is_nil() {
                if !seconds.is_nil() && !seconds.is_number() {
                    return Err(signal(
                        "wrong-type-argument",
                        vec![Value::symbol("numberp"), *seconds],
                    ));
                }
            } else if !seconds.is_nil() && !matches!(seconds, Value::Int(_)) {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("fixnump"), *seconds],
                ));
            }
        } else if !seconds.is_nil() && !seconds.is_number() {
            return Err(signal(
                "wrong-type-argument",
                vec![Value::symbol("numberp"), *seconds],
            ));
        }
    }

    Ok(Value::Nil)
}

/// (get-process NAME) -> process-or-nil
pub(crate) fn builtin_get_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("get-process", &args, 1)?;
    let name = expect_string_strict(&args[0])?;
    match eval.processes.find_by_name(&name) {
        Some(id) => Ok(Value::Int(id as i64)),
        None => Ok(Value::Nil),
    }
}

/// (get-buffer-process BUFFER-OR-NAME) -> process-or-nil
pub(crate) fn builtin_get_buffer_process(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("get-buffer-process", &args, 1)?;
    let Some(buffer_name) = resolve_buffer_name_for_process_lookup(eval, &args[0])? else {
        return Ok(Value::Nil);
    };
    match eval.processes.find_by_buffer_name(&buffer_name) {
        Some(id) => Ok(Value::Int(id as i64)),
        None => Ok(Value::Nil),
    }
}

/// (processp OBJECT) -> bool
pub(crate) fn builtin_processp(eval: &mut super::eval::Evaluator, args: Vec<Value>) -> EvalResult {
    expect_args("processp", &args, 1)?;
    Ok(Value::bool(match &args[0] {
        Value::Int(n) if *n >= 0 => eval.processes.get_any(*n as ProcessId).is_some(),
        _ => false,
    }))
}

/// (process-live-p PROCESS) -> list-or-nil
pub(crate) fn builtin_process_live_p(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-live-p", &args, 1)?;
    let Some(id) = resolve_live_process_designator(eval, &args[0]) else {
        return Ok(Value::Nil);
    };
    let proc = eval.processes.get(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(process_live_status_value(&proc.status, &proc.kind))
}

/// (process-id PROCESS) -> integer
pub(crate) fn builtin_process_id(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-id", &args, 1)?;
    let id = match &args[0] {
        Value::Int(n) if *n >= 0 => {
            let id = *n as ProcessId;
            if eval.processes.get_any(id).is_some() {
                id
            } else {
                return Err(signal_wrong_type_processp(args[0]));
            }
        }
        _ => return Err(signal_wrong_type_processp(args[0])),
    };
    let proc = eval
        .processes
        .get_any(id)
        .ok_or_else(|| signal_wrong_type_processp(args[0]))?;
    if proc.kind == ProcessKind::Real {
        Ok(Value::Int(id as i64))
    } else {
        Ok(Value::Nil)
    }
}

/// (process-query-on-exit-flag PROCESS) -> bool
pub(crate) fn builtin_process_query_on_exit_flag(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-query-on-exit-flag", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(Value::bool(proc.query_on_exit_flag))
}

/// (set-process-query-on-exit-flag PROCESS FLAG) -> FLAG
pub(crate) fn builtin_set_process_query_on_exit_flag(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-query-on-exit-flag", &args, 2)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let flag = args[1].is_truthy();
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.query_on_exit_flag = flag;
    Ok(args[1])
}

/// (process-command PROCESS) -> list
pub(crate) fn builtin_process_command(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-command", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    if proc.kind != ProcessKind::Real || proc.command.is_empty() {
        return Ok(Value::Nil);
    }
    let mut items = Vec::with_capacity(proc.args.len() + 1);
    items.push(Value::string(proc.command.clone()));
    items.extend(proc.args.iter().cloned().map(Value::string));
    Ok(Value::list(items))
}

/// (process-contact PROCESS &optional KEY NO-BLOCK) -> value
pub(crate) fn builtin_process_contact(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("process-contact", &args, 1)?;
    if args.len() > 3 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![
                Value::symbol("process-contact"),
                Value::Int(args.len() as i64),
            ],
        ));
    }
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    let key = args.get(1).cloned().unwrap_or(Value::Nil);
    match proc.kind {
        ProcessKind::Network => {
            let port = 40000_i64 + (proc.id % 20000) as i64;
            let local = Value::vector(vec![
                Value::Int(127),
                Value::Int(0),
                Value::Int(0),
                Value::Int(1),
                Value::Int(port),
            ]);
            if key.is_nil() {
                Ok(Value::list(vec![Value::Nil, Value::Int(port)]))
            } else if key == Value::True {
                Ok(Value::list(vec![
                    Value::keyword(":name"),
                    Value::string(proc.name.clone()),
                    Value::keyword(":server"),
                    Value::True,
                    Value::keyword(":service"),
                    Value::Int(port),
                    Value::keyword(":local"),
                    local,
                ]))
            } else {
                match key {
                    Value::Keyword(k) if resolve_sym(k) == ":name" => Ok(Value::string(proc.name.clone())),
                    Value::Keyword(k) if resolve_sym(k) == ":server" => Ok(Value::True),
                    Value::Keyword(k) if resolve_sym(k) == ":service" => Ok(Value::Int(port)),
                    Value::Keyword(k) if resolve_sym(k) == ":local" => Ok(local),
                    _ => Ok(Value::Nil),
                }
            }
        }
        ProcessKind::Pipe => {
            if key.is_nil() {
                Ok(Value::True)
            } else if key == Value::True {
                Ok(Value::list(vec![
                    Value::keyword(":name"),
                    Value::string(proc.name.clone()),
                ]))
            } else {
                match key {
                    Value::Keyword(k) if resolve_sym(k) == ":name" => Ok(Value::string(proc.name.clone())),
                    _ => Ok(Value::Nil),
                }
            }
        }
        _ => Ok(Value::True),
    }
}

/// (process-filter PROCESS) -> function
pub(crate) fn builtin_process_filter(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-filter", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(proc.filter)
}

/// (set-process-filter PROCESS FILTER) -> FILTER
pub(crate) fn builtin_set_process_filter(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-filter", &args, 2)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let stored = if args[1].is_nil() {
        Value::symbol(DEFAULT_PROCESS_FILTER_SYMBOL)
    } else {
        args[1]
    };
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.filter = stored;
    Ok(stored)
}

/// (process-sentinel PROCESS) -> function
pub(crate) fn builtin_process_sentinel(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-sentinel", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(proc.sentinel)
}

/// (set-process-sentinel PROCESS SENTINEL) -> SENTINEL
pub(crate) fn builtin_set_process_sentinel(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-sentinel", &args, 2)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let stored = if args[1].is_nil() {
        Value::symbol(DEFAULT_PROCESS_SENTINEL_SYMBOL)
    } else {
        args[1]
    };
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.sentinel = stored;
    Ok(stored)
}

/// (process-plist PROCESS) -> plist
pub(crate) fn builtin_process_plist(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-plist", &args, 1)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    Ok(proc.plist)
}

/// (set-process-plist PROCESS PLIST) -> plist
pub(crate) fn builtin_set_process_plist(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("set-process-plist", &args, 2)?;
    if !args[1].is_list() {
        return Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("listp"), args[1]],
        ));
    }
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.plist = args[1];
    Ok(proc.plist)
}

/// (process-put PROCESS PROP VALUE) -> plist
pub(crate) fn builtin_process_put(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-put", &args, 3)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let current_plist = eval
        .processes
        .get_any(id)
        .ok_or_else(|| {
            signal(
                "wrong-type-argument",
                vec![Value::symbol("processp"), args[0]],
            )
        })?
        .plist;
    let new_plist =
        super::builtins::builtin_plist_put(vec![current_plist, args[1], args[2]])?;
    let proc = eval.processes.get_any_mut(id).ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("processp"), args[0]],
        )
    })?;
    proc.plist = new_plist;
    Ok(new_plist)
}

/// (process-get PROCESS PROP) -> value
pub(crate) fn builtin_process_get(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_args("process-get", &args, 2)?;
    let id = resolve_process_or_wrong_type_any(eval, &args[0])?;
    let plist = eval
        .processes
        .get_any(id)
        .ok_or_else(|| {
            signal(
                "wrong-type-argument",
                vec![Value::symbol("processp"), args[0]],
            )
        })?
        .plist;
    super::builtins::builtin_plist_get(vec![plist, args[1]])
}

// ---------------------------------------------------------------------------
// Builtins (pure  no evaluator needed)
// ---------------------------------------------------------------------------

/// (shell-command-to-string COMMAND) -> string
///
/// Runs COMMAND via the system shell and returns captured stdout.
pub(crate) fn builtin_shell_command_to_string(args: Vec<Value>) -> EvalResult {
    expect_args("shell-command-to-string", &args, 1)?;
    let command = expect_string(&args[0])?;

    let shell = std::env::var("SHELL").unwrap_or_else(|_| "/bin/sh".to_string());

    let output = Command::new(&shell)
        .arg("-c")
        .arg(&command)
        .output()
        .map_err(|e| signal_process_io("Shell command failed", Some(&shell), e))?;

    let stdout = String::from_utf8_lossy(&output.stdout).into_owned();
    Ok(Value::string(stdout))
}

fn getenv_impl(name: &str, args: &[Value]) -> EvalResult {
    expect_min_args(name, args, 1)?;
    if args.len() > 2 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![Value::symbol(name), Value::Int(args.len() as i64)],
        ));
    }
    if let Some(frame) = args.get(1) {
        if !frame.is_nil() {
            return Err(signal(
                "wrong-type-argument",
                vec![Value::symbol("framep"), *frame],
            ));
        }
    }
    let name = expect_string_strict(&args[0])?;
    match std::env::var(&name) {
        Ok(val) => Ok(Value::string(val)),
        Err(_) => Ok(Value::Nil),
    }
}

/// (getenv VARIABLE) -> string or nil
pub(crate) fn builtin_getenv(args: Vec<Value>) -> EvalResult {
    getenv_impl("getenv", &args)
}

/// (getenv-internal VARIABLE &optional FRAME) -> string or nil
pub(crate) fn builtin_getenv_internal(args: Vec<Value>) -> EvalResult {
    getenv_impl("getenv-internal", &args)
}

/// (setenv VARIABLE &optional VALUE) -> string or nil
///
/// Sets the environment variable VARIABLE to VALUE.  If VALUE is nil
/// or omitted, removes the variable.
pub(crate) fn builtin_setenv(args: Vec<Value>) -> EvalResult {
    expect_min_args("setenv", &args, 1)?;
    if args.len() > 3 {
        return Err(signal(
            "wrong-number-of-arguments",
            vec![Value::symbol("setenv"), Value::Int(args.len() as i64)],
        ));
    }
    let name = expect_string_strict(&args[0])?;

    if args.len() > 1 && !args[1].is_nil() {
        let env_value = if args.len() > 2 && args[2].is_truthy() {
            let substituted =
                super::fileio::builtin_substitute_in_file_name(vec![args[1]])?;
            expect_string_strict(&substituted)?
        } else {
            sequence_value_to_env_string(&args[1])?
        };
        // Safety: this is single-threaded for the Elisp VM, so setting env
        // vars is acceptable.
        unsafe {
            std::env::set_var(&name, &env_value);
        }
        Ok(args[1])
    } else {
        unsafe {
            std::env::remove_var(&name);
        }
        Ok(Value::Nil)
    }
}

/// (set-binary-mode STREAM MODE) -> t
///
/// Batch/runtime compatibility path. Accepts stdin/stdout/stderr symbols.
pub(crate) fn builtin_set_binary_mode(args: Vec<Value>) -> EvalResult {
    expect_args("set-binary-mode", &args, 2)?;
    let stream = args[0].as_symbol_name().ok_or_else(|| {
        signal(
            "wrong-type-argument",
            vec![Value::symbol("symbolp"), args[0]],
        )
    })?;

    match stream {
        "stdin" | "stdout" | "stderr" => Ok(Value::True),
        _ => Err(signal(
            "error",
            vec![Value::string("unsupported stream"), args[0]],
        )),
    }
}

impl GcTrace for ProcessManager {
    fn trace_roots(&self, roots: &mut Vec<Value>) {
        for process in self.processes.values().chain(self.deleted_processes.values()) {
            roots.push(process.filter);
            roots.push(process.sentinel);
            roots.push(process.plist);
            roots.push(process.coding_decode);
            roots.push(process.coding_encode);
            roots.push(process.thread);
        }
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use crate::elisp::{format_eval_result, parse_forms, Evaluator};

    fn eval_one(src: &str) -> String {
        let forms = parse_forms(src).expect("parse");
        let mut ev = Evaluator::new();
        let result = ev.eval_expr(&forms[0]);
        format_eval_result(&result)
    }

    fn eval_all(src: &str) -> Vec<String> {
        let forms = parse_forms(src).expect("parse");
        let mut ev = Evaluator::new();
        ev.eval_forms(&forms)
            .iter()
            .map(format_eval_result)
            .collect()
    }

    /// Find the path of a binary, trying /bin, /usr/bin, and PATH lookup.
    fn find_bin(name: &str) -> String {
        for dir in &["/bin", "/usr/bin", "/run/current-system/sw/bin"] {
            let path = format!("{}/{}", dir, name);
            if std::path::Path::new(&path).exists() {
                return path;
            }
        }
        // Fallback: try to find via `which`
        if let Ok(output) = std::process::Command::new("which").arg(name).output() {
            if output.status.success() {
                return String::from_utf8_lossy(&output.stdout).trim().to_string();
            }
        }
        // Last resort: return the bare name and let Command search PATH
        name.to_string()
    }

    fn tmp_file(label: &str) -> String {
        let nonce = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .expect("time should be monotonic")
            .as_nanos();
        format!("/tmp/neovm-{label}-{}-{nonce}.txt", std::process::id())
    }

    // -- ProcessManager unit tests ------------------------------------------

    #[test]
    fn process_manager_create_and_query() {
        let mut pm = ProcessManager::new();
        let id = pm.create_process(
            "test".into(),
            Some("*test*".into()),
            "/bin/echo".into(),
            vec!["hello".into()],
        );
        assert!(id > 0);
        assert!(pm.get(id).is_some());
        assert_eq!(pm.get(id).unwrap().name, "test");
        assert_eq!(pm.get(id).unwrap().command, "/bin/echo");
        assert_eq!(pm.process_status(id), Some(&ProcessStatus::Run));
    }

    #[test]
    fn process_manager_kill() {
        let mut pm = ProcessManager::new();
        let id = pm.create_process("p".into(), None, "prog".into(), vec![]);
        assert!(pm.kill_process(id));
        assert_eq!(pm.process_status(id), Some(&ProcessStatus::Signal(9)));
    }

    #[test]
    fn process_manager_delete() {
        let mut pm = ProcessManager::new();
        let id = pm.create_process("p".into(), None, "prog".into(), vec![]);
        assert!(pm.delete_process(id));
        assert!(pm.get(id).is_none());
    }

    #[test]
    fn process_manager_send_input() {
        let mut pm = ProcessManager::new();
        let id = pm.create_process("p".into(), None, "prog".into(), vec![]);
        assert!(pm.send_input(id, "hello "));
        assert!(pm.send_input(id, "world"));
        assert_eq!(pm.get(id).unwrap().stdin_queue, "hello world");
    }

    #[test]
    fn process_manager_find_by_name() {
        let mut pm = ProcessManager::new();
        let id = pm.create_process("my-proc".into(), None, "prog".into(), vec![]);
        assert_eq!(pm.find_by_name("my-proc"), Some(id));
        assert_eq!(pm.find_by_name("nonexistent"), None);
    }

    #[test]
    fn process_manager_list() {
        let mut pm = ProcessManager::new();
        let id1 = pm.create_process("a".into(), None, "p".into(), vec![]);
        let id2 = pm.create_process("b".into(), None, "q".into(), vec![]);
        let ids = pm.list_processes();
        assert!(ids.contains(&id1));
        assert!(ids.contains(&id2));
        assert_eq!(ids.len(), 2);
    }

    #[test]
    fn process_manager_env() {
        let mut pm = ProcessManager::new();
        pm.setenv("NEOVM_TEST_VAR".into(), Some("hello".into()));
        assert_eq!(pm.getenv("NEOVM_TEST_VAR"), Some("hello".into()));
        pm.setenv("NEOVM_TEST_VAR".into(), None);
        assert_eq!(pm.getenv("NEOVM_TEST_VAR"), None);
    }

    // -- Elisp-level tests --------------------------------------------------

    #[test]
    fn start_process_and_query() {
        let echo = find_bin("echo");
        let results = eval_all(&format!(
            r#"(start-process "my-proc" nil "{echo}" "hello")
               (process-status 1)
               (process-name 1)
               (process-buffer 1)"#,
        ));
        assert_eq!(results[0], "OK 1");
        assert_eq!(results[1], "OK run");
        assert_eq!(results[2], r#"OK "my-proc""#);
        assert_eq!(results[3], "OK nil");
    }

    #[test]
    fn start_process_with_buffer() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(start-process "p" "*output*" "{cat}")
               (bufferp (process-buffer 1))
               (equal (buffer-name (process-buffer 1)) "*output*")"#,
        ));
        assert_eq!(results[1], "OK t");
        assert_eq!(results[2], "OK t");
    }

    #[test]
    fn start_process_buffer_name_program_and_arg_contracts_match_oracle() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (let ((p (start-process "neo-sp-contract-buffer" (current-buffer) "{cat}")))
                   (unwind-protect
                       (list (processp p)
                             (null (condition-case err (process-send-eof nil) (error err)))
                             (null (condition-case err (process-running-child-p nil) (error err))))
                     (ignore-errors (delete-process p)))))
               (condition-case err (start-process 'neo-sp-contract-name nil "{cat}") (error err))
               (condition-case err (start-process t nil "{cat}") (error err))
               (condition-case err (start-process nil nil "{cat}") (error err))
               (condition-case err (start-process "neo-sp-contract-buf-symbol" 'x "{cat}") (error err))
               (condition-case err (start-process "neo-sp-contract-buf-t" t "{cat}") (error err))
               (condition-case err (start-process "neo-sp-contract-buf-int" 1 "{cat}") (error err))
               (condition-case err (start-process "neo-sp-contract-prog-symbol" nil 'cat) (error err))
               (condition-case err (start-process "neo-sp-contract-prog-t" nil t) (error err))
               (processp (start-process "neo-sp-contract-prog-nil" nil nil))
               (condition-case err (start-process "neo-sp-contract-arg-symbol" nil "{cat}" 'a) (error err))
               (condition-case err (start-process "neo-sp-contract-arg-t" nil "{cat}" t) (error err))
               (condition-case err (start-process "neo-sp-contract-arg-nil" nil "{cat}" nil) (error err))
               (condition-case err (start-process "neo-sp-contract-arg-int" nil "{cat}" 1) (error err))"#,
        ));
        assert_eq!(results[0], "OK (t t t)");
        assert_eq!(results[1], r#"OK (error ":name value not a string")"#);
        assert_eq!(results[2], r#"OK (error ":name value not a string")"#);
        assert_eq!(results[3], r#"OK (error ":name value not a string")"#);
        assert_eq!(results[4], "OK (wrong-type-argument stringp x)");
        assert_eq!(results[5], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[6], "OK (wrong-type-argument stringp 1)");
        assert_eq!(results[7], "OK (wrong-type-argument stringp cat)");
        assert_eq!(results[8], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[9], "OK t");
        assert_eq!(results[10], "OK (wrong-type-argument stringp a)");
        assert_eq!(results[11], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[12], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[13], "OK (wrong-type-argument stringp 1)");
    }

    #[test]
    fn call_process_and_start_file_process_string_contracts_match_oracle() {
        let echo = find_bin("echo");
        let results = eval_all(&format!(
            r#"(condition-case err (call-process nil) (error err))
               (condition-case err (call-process t) (error err))
               (condition-case err (call-process 'foo) (error err))
               (condition-case err (call-process "{echo}" nil nil nil 'x) (error err))
               (condition-case err (call-process "{echo}" nil nil nil t) (error err))
               (condition-case err (call-process "{echo}" nil nil nil nil) (error err))
               (with-temp-buffer
                 (insert "x")
                 (condition-case err (call-process-region (point-min) (point-min) nil) (error err)))
               (with-temp-buffer
                 (insert "x")
                 (condition-case err (call-process-region (point-min) (point-min) t) (error err)))
               (with-temp-buffer
                 (insert "x")
                 (condition-case err (call-process-region (point-min) (point-min) 'foo) (error err)))
               (with-temp-buffer
                 (insert "x")
                 (condition-case err (call-process-region (point-min) (point-min) "{echo}" nil nil nil 'x) (error err)))
               (with-temp-buffer
                 (insert "x")
                 (condition-case err (call-process-region (point-min) (point-min) "{echo}" nil nil nil t) (error err)))
               (with-temp-buffer
                 (insert "x")
                 (condition-case err (call-process-region (point-min) (point-min) "{echo}" nil nil nil nil) (error err)))
               (condition-case err (start-file-process "neo-sfp-contract-arg-symbol" nil "{echo}" 'x) (error err))
               (condition-case err (start-file-process "neo-sfp-contract-arg-t" nil "{echo}" t) (error err))
               (condition-case err (start-file-process "neo-sfp-contract-arg-nil" nil "{echo}" nil) (error err))
               (condition-case err (start-file-process "neo-sfp-contract-program-symbol" nil 'echo) (error err))
               (condition-case err (start-file-process "neo-sfp-contract-program-t" nil t) (error err))
               (let ((p (start-file-process "neo-sfp-contract-program-nil" nil nil)))
                 (unwind-protect (processp p) (ignore-errors (delete-process p))))"#,
        ));

        assert_eq!(results[0], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[1], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[2], "OK (wrong-type-argument stringp foo)");
        assert_eq!(results[3], "OK (wrong-type-argument stringp x)");
        assert_eq!(results[4], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[5], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[6], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[7], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[8], "OK (wrong-type-argument stringp foo)");
        assert_eq!(results[9], "OK (wrong-type-argument stringp x)");
        assert_eq!(results[10], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[11], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[12], "OK (wrong-type-argument stringp x)");
        assert_eq!(results[13], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[14], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[15], "OK (wrong-type-argument stringp echo)");
        assert_eq!(results[16], "OK (wrong-type-argument stringp t)");
        assert_eq!(results[17], "OK t");
    }

    #[test]
    fn delete_process_removes() {
        let echo = find_bin("echo");
        let results = eval_all(&format!(
            r#"(start-process "p" nil "{echo}")
               (delete-process 1)
               (process-list)"#,
        ));
        assert_eq!(results[2], "OK nil");
    }

    #[test]
    fn process_send_string_test() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(start-process "p" nil "{cat}")
               (process-send-string 1 "hello")"#,
        ));
        assert_eq!(results[1], "OK nil");
    }

    #[test]
    fn process_exit_status_initial() {
        let echo = find_bin("echo");
        let results = eval_all(&format!(
            r#"(start-process "p" nil "{echo}")
               (process-exit-status 1)"#,
        ));
        assert_eq!(results[1], "OK 0");
    }

    #[test]
    fn process_list_test() {
        let echo = find_bin("echo");
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(start-process "a" nil "{echo}")
               (start-process "b" nil "{cat}")
               (process-list)"#,
        ));
        // Process list contains two entries.  Order may vary.
        let list_str = &results[2];
        assert!(list_str.contains("1"));
        assert!(list_str.contains("2"));
    }

    #[test]
    fn call_process_echo() {
        let echo = find_bin("echo");
        // call-process with echo, inserting into current buffer
        let results = eval_all(&format!(
            r#"(get-buffer-create "cp-test")
               (set-buffer "cp-test")
               (call-process "{echo}" nil t nil "hello" "world")
               (buffer-string)"#,
        ));
        // Exit code should be 0.
        assert_eq!(results[2], "OK 0");
        // Buffer should contain "hello world\n".
        assert_eq!(results[3], r#"OK "hello world\n""#);
    }

    #[test]
    fn call_process_no_destination() {
        let echo = find_bin("echo");
        // call-process with nil destination discards output
        let results = eval_all(&format!(
            r#"(get-buffer-create "cp-nil")
               (set-buffer "cp-nil")
               (call-process "{echo}" nil nil nil "hello")
               (buffer-string)"#,
        ));
        assert_eq!(results[2], "OK 0");
        assert_eq!(results[3], r#"OK """#);
    }

    #[test]
    fn call_process_infile_feeds_stdin() {
        let cat = find_bin("cat");
        let infile = tmp_file("cp-infile");
        std::fs::write(&infile, "infile-data").expect("write infile");
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (list
                   (call-process "{cat}" "{infile}" t nil)
                   (buffer-string)))"#
        ));
        assert_eq!(results[0], r#"OK (0 "infile-data")"#);
        let _ = std::fs::remove_file(&infile);
    }

    #[test]
    fn call_process_destination_buffer_name_inserts_there() {
        let echo = find_bin("echo");
        let results = eval_all(&format!(
            r#"(get-buffer-create "cp-src")
               (get-buffer-create "cp-dst")
               (set-buffer "cp-src")
               (erase-buffer)
               (set-buffer "cp-dst")
               (erase-buffer)
               (set-buffer "cp-src")
               (call-process "{echo}" nil "cp-dst" nil "hello")
               (list
                 (with-current-buffer "cp-src" (buffer-string))
                 (with-current-buffer "cp-dst" (buffer-string)))"#,
        ));
        assert_eq!(results[7], "OK 0");
        assert_eq!(results[8], r#"OK ("" "hello\n")"#);
    }

    #[test]
    fn call_process_file_destination_collects_stdout_and_stderr() {
        let sh = find_bin("sh");
        let out = tmp_file("cp-file");
        let _ = std::fs::remove_file(&out);
        let results = eval_all(&format!(
            r#"(call-process "{sh}" nil '(:file "{out}") nil "-c" "echo out; echo err >&2")
               (with-temp-buffer (insert-file-contents "{out}") (buffer-string))"#
        ));
        assert_eq!(results[0], "OK 0");
        assert!(results[1].contains("out"));
        assert!(results[1].contains("err"));
        let _ = std::fs::remove_file(&out);
    }

    #[test]
    fn call_process_pair_destination_splits_stderr_to_file() {
        let sh = find_bin("sh");
        let out = tmp_file("cp-pair-out");
        let err = tmp_file("cp-pair-err");
        let _ = std::fs::remove_file(&out);
        let _ = std::fs::remove_file(&err);
        let results = eval_all(&format!(
            r#"(call-process "{sh}" nil '((:file "{out}") "{err}") nil "-c" "echo out; echo err >&2")
               (with-temp-buffer (insert-file-contents "{out}") (buffer-string))
               (with-temp-buffer (insert-file-contents "{err}") (buffer-string))"#
        ));
        assert_eq!(results[0], "OK 0");
        assert!(results[1].contains("out"));
        assert!(!results[1].contains("err"));
        assert!(results[2].contains("err"));
        let _ = std::fs::remove_file(&out);
        let _ = std::fs::remove_file(&err);
    }

    #[test]
    fn call_process_integer_destination_returns_nil() {
        let echo = find_bin("echo");
        // Any integer destination behaves like 0: discard and return nil.
        let results = eval_all(&format!(
            r#"(get-buffer-create "cp-int")
               (set-buffer "cp-int")
               (call-process "{echo}" nil 2 nil "hello")
               (buffer-string)"#,
        ));
        assert_eq!(results[2], "OK nil");
        assert_eq!(results[3], r#"OK """#);
    }

    #[test]
    fn call_process_false() {
        let false_bin = find_bin("false");
        // false exits with code 1
        let result = eval_one(&format!(r#"(call-process "{false_bin}")"#));
        assert_eq!(result, "OK 1");
    }

    #[test]
    fn call_process_region_test() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(get-buffer-create "cpr-test")
               (set-buffer "cpr-test")
               (insert "hello world")
               (call-process-region 1 12 "{cat}" nil t)
               (buffer-string)"#,
        ));
        // exit code 0
        assert_eq!(results[3], "OK 0");
        // Buffer should contain original text plus piped output
        assert!(results[4].contains("hello world"));
    }

    #[test]
    fn call_process_region_destination_buffer_name_inserts_there() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(get-buffer-create "cpr-src")
               (get-buffer-create "cpr-dst")
               (with-current-buffer "cpr-src" (erase-buffer) (insert "abc"))
               (with-current-buffer "cpr-dst" (erase-buffer))
               (with-current-buffer "cpr-src"
                 (call-process-region (point-min) (point-max) "{cat}" nil "cpr-dst" nil))
               (list
                 (with-current-buffer "cpr-src" (buffer-string))
                 (with-current-buffer "cpr-dst" (buffer-string)))"#,
        ));
        assert_eq!(results[4], "OK 0");
        assert_eq!(results[5], r#"OK ("abc" "abc")"#);
    }

    #[test]
    fn call_process_region_file_destination_writes_file() {
        let cat = find_bin("cat");
        let out = tmp_file("cpr-file");
        let _ = std::fs::remove_file(&out);
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (insert "abc")
                 (call-process-region (point-min) (point-max) "{cat}" nil '(:file "{out}") nil))
               (with-temp-buffer (insert-file-contents "{out}") (buffer-string))"#
        ));
        assert_eq!(results[0], "OK 0");
        assert_eq!(results[1], r#"OK "abc""#);
        let _ = std::fs::remove_file(&out);
    }

    #[test]
    fn call_process_region_start_nil_uses_whole_buffer() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (insert "abc")
                 (list (call-process-region nil nil "{cat}" nil t nil)
                       (buffer-string)))"#
        ));
        assert_eq!(results[0], r#"OK (0 "abcabc")"#);
    }

    #[test]
    fn call_process_region_start_string_uses_string_input() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (insert "abc")
                 (list (call-process-region "xyz" nil "{cat}" nil t nil)
                       (buffer-string)))"#
        ));
        assert_eq!(results[0], r#"OK (0 "abcxyz")"#);
    }

    #[test]
    fn call_process_region_start_string_with_delete_signals_wrong_type() {
        let cat = find_bin("cat");
        let result = eval_one(&format!(
            r#"(condition-case err
                   (call-process-region "xyz" nil "{cat}" t t nil)
                 (error (car err)))"#
        ));
        assert_eq!(result, "OK wrong-type-argument");
    }

    #[test]
    fn call_process_region_accepts_marker_positions() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (insert "abcdef")
                 (goto-char 3)
                 (let ((m (copy-marker (point))))
                   (list (call-process-region m (point-max) "{cat}" nil t nil)
                         (buffer-string))))"#
        ));
        assert_eq!(results[0], r#"OK (0 "abcdefcdef")"#);
    }

    #[test]
    fn call_process_region_reversed_bounds_are_accepted() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (insert "abc")
                 (list (call-process-region (point-max) (point-min) "{cat}" nil t nil)
                       (buffer-string)))"#
        ));
        assert_eq!(results[0], r#"OK (0 "abcabc")"#);
    }

    #[test]
    fn call_process_region_reversed_bounds_with_delete_delete_region() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(with-temp-buffer
                 (insert "abc")
                 (list (call-process-region (point-max) (point-min) "{cat}" t t nil)
                       (buffer-string)))"#
        ));
        assert_eq!(results[0], r#"OK (0 "abc")"#);
    }

    #[test]
    fn call_process_region_negative_start_signals_args_out_of_range() {
        let cat = find_bin("cat");
        let result = eval_one(&format!(
            r#"(with-temp-buffer
                 (insert "abc")
                 (condition-case err
                     (call-process-region -1 2 "{cat}" nil t nil)
                   (error (car err))))"#
        ));
        assert_eq!(result, "OK args-out-of-range");
    }

    #[test]
    fn call_process_region_huge_end_signals_args_out_of_range() {
        let cat = find_bin("cat");
        let result = eval_one(&format!(
            r#"(with-temp-buffer
                 (insert "abc")
                 (condition-case err
                     (call-process-region 1 999999 "{cat}" nil t nil)
                   (error (car err))))"#
        ));
        assert_eq!(result, "OK args-out-of-range");
    }

    #[test]
    fn call_process_region_integer_destination_returns_nil() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(get-buffer-create "cpr-int")
               (set-buffer "cpr-int")
               (erase-buffer)
               (insert "abc")
               (call-process-region 1 4 "{cat}" nil 3 nil)
               (buffer-string)"#,
        ));
        assert_eq!(results[4], "OK nil");
        assert_eq!(results[5], r#"OK "abc""#);
    }

    #[test]
    fn shell_command_to_string_test() {
        let result = eval_one(r#"(shell-command-to-string "echo -n hello")"#);
        assert_eq!(result, r#"OK "hello""#);
    }

    #[test]
    fn shell_command_to_string_with_pipe() {
        let result = eval_one(r#"(shell-command-to-string "echo hello | tr a-z A-Z")"#);
        assert_eq!(result, r#"OK "HELLO\n""#);
    }

    #[test]
    fn getenv_path() {
        // PATH should always be set
        let result = eval_one(r#"(getenv "PATH")"#);
        assert!(result.starts_with("OK \""));
    }

    #[test]
    fn getenv_nonexistent() {
        let result = eval_one(r#"(getenv "NEOVM_DEFINITELY_NOT_SET_12345")"#);
        assert_eq!(result, "OK nil");
    }

    #[test]
    fn getenv_name_must_be_string() {
        let result = eval_one(r#"(condition-case err (getenv nil) (error err))"#);
        assert_eq!(result, "OK (wrong-type-argument stringp nil)");
    }

    #[test]
    fn getenv_accepts_optional_nil_frame_arg() {
        let result = eval_one(
            r#"(condition-case err
                   (let ((v (getenv "HOME" nil)))
                     (if (stringp v) 'string v))
                 (error err))"#,
        );
        assert_eq!(result, "OK string");
    }

    #[test]
    fn getenv_rejects_non_nil_frame_arg_before_variable_type_check() {
        let result = eval_one(r#"(condition-case err (getenv 1 '(x)) (error err))"#);
        assert_eq!(result, "OK (wrong-type-argument framep (x))");
    }

    #[test]
    fn getenv_rejects_more_than_two_args() {
        let result = eval_one(r#"(condition-case err (getenv "HOME" nil nil) (error (car err)))"#);
        assert_eq!(result, "OK wrong-number-of-arguments");
    }

    #[test]
    fn setenv_and_getenv() {
        let results = eval_all(
            r#"(setenv "NEOVM_TEST_SETENV" "myvalue")
               (getenv "NEOVM_TEST_SETENV")"#,
        );
        assert_eq!(results[0], r#"OK "myvalue""#);
        assert_eq!(results[1], r#"OK "myvalue""#);
    }

    #[test]
    fn setenv_unset() {
        let results = eval_all(
            r#"(setenv "NEOVM_TEST_UNSET" "val")
               (setenv "NEOVM_TEST_UNSET")
               (getenv "NEOVM_TEST_UNSET")"#,
        );
        assert_eq!(results[2], "OK nil");
    }

    #[test]
    fn setenv_name_must_be_string() {
        let result = eval_one(r#"(condition-case err (setenv nil "v") (error err))"#);
        assert_eq!(result, "OK (wrong-type-argument stringp nil)");
    }

    #[test]
    fn setenv_accepts_sequence_value_and_sets_environment() {
        let vector_result = eval_one(
            r#"(let ((old (getenv "NEOVM_TEST_SETENV_SEQ")))
                 (unwind-protect
                     (progn
                       (setenv "NEOVM_TEST_SETENV_SEQ" [118 97 108])
                       (getenv "NEOVM_TEST_SETENV_SEQ"))
                   (setenv "NEOVM_TEST_SETENV_SEQ" old)))"#,
        );
        assert_eq!(vector_result, r#"OK "val""#);

        let list_result = eval_one(
            r#"(let ((old (getenv "NEOVM_TEST_SETENV_SEQ")))
                 (unwind-protect
                     (progn
                       (setenv "NEOVM_TEST_SETENV_SEQ" '(118 97 108))
                       (getenv "NEOVM_TEST_SETENV_SEQ"))
                   (setenv "NEOVM_TEST_SETENV_SEQ" old)))"#,
        );
        assert_eq!(list_result, r#"OK "val""#);
    }

    #[test]
    fn setenv_substitute_flag_controls_expansion_and_requires_string() {
        let unsubstituted = eval_one(
            r#"(let ((old (getenv "NEOVM_TEST_SETENV_SEQ")))
                 (unwind-protect
                     (progn
                       (setenv "NEOVM_TEST_SETENV_SEQ" "$HOME")
                       (getenv "NEOVM_TEST_SETENV_SEQ"))
                   (setenv "NEOVM_TEST_SETENV_SEQ" old)))"#,
        );
        assert_eq!(unsubstituted, r#"OK "$HOME""#);

        let substituted = eval_one(
            r#"(let ((old (getenv "NEOVM_TEST_SETENV_SEQ")))
                 (unwind-protect
                     (progn
                       (setenv "NEOVM_TEST_SETENV_SEQ" "$HOME" t)
                       (getenv "NEOVM_TEST_SETENV_SEQ"))
                   (setenv "NEOVM_TEST_SETENV_SEQ" old)))"#,
        );
        assert!(substituted.starts_with("OK \""));
        assert_ne!(substituted, r#"OK "$HOME""#);

        let type_err = eval_one(
            r#"(condition-case err (setenv "NEOVM_TEST_SETENV_SEQ" [118 97 108] t) (error err))"#,
        );
        assert_eq!(type_err, "OK (wrong-type-argument stringp [118 97 108])");
    }

    #[test]
    fn setenv_rejects_non_sequence_value() {
        let result =
            eval_one(r#"(condition-case err (setenv "NEOVM_TEST_SETENV_SEQ" 1) (error err))"#);
        assert_eq!(result, "OK (wrong-type-argument sequencep 1)");
    }

    #[test]
    fn setenv_rejects_too_many_args() {
        let result = eval_one(
            r#"(condition-case err (setenv "NEOVM_TEST_SETENV_SEQ" "v" nil nil) (error (car err)))"#,
        );
        assert_eq!(result, "OK wrong-number-of-arguments");
    }

    #[test]
    fn set_binary_mode_stream_contract_matches_oracle() {
        let results = eval_all(
            r#"(condition-case err (set-binary-mode 'stdin t) (error err))
               (condition-case err (set-binary-mode 'stdout nil) (error err))
               (condition-case err (set-binary-mode 'stderr t) (error err))
               (condition-case err (set-binary-mode 'foo t) (error err))
               (condition-case err (set-binary-mode nil t) (error err))
               (condition-case err (set-binary-mode t t) (error err))
               (condition-case err (set-binary-mode 1 t) (error err))"#,
        );
        assert_eq!(results[0], "OK t");
        assert_eq!(results[1], "OK t");
        assert_eq!(results[2], "OK t");
        assert_eq!(results[3], r#"OK (error "unsupported stream" foo)"#);
        assert_eq!(results[4], r#"OK (error "unsupported stream" nil)"#);
        assert_eq!(results[5], r#"OK (error "unsupported stream" t)"#);
        assert_eq!(results[6], "OK (wrong-type-argument symbolp 1)");
    }

    #[test]
    fn call_process_bad_program() {
        let result = eval_one(r#"(call-process "/nonexistent/program_xyz")"#);
        assert!(result.contains("ERR"));
    }

    #[test]
    fn call_process_bad_program_signals_file_missing() {
        let result = eval_one(
            r#"(condition-case err (call-process "/nonexistent/program_xyz") (error (car err)))"#,
        );
        assert_eq!(result, "OK file-missing");
    }

    #[test]
    fn call_process_missing_infile_signals_file_missing() {
        let cat = find_bin("cat");
        let result = eval_one(&format!(
            r#"(condition-case err (call-process "{cat}" "/nonexistent/neovm-process-infile") (error (car err)))"#
        ));
        assert_eq!(result, "OK file-missing");
    }

    #[test]
    fn call_process_region_bad_program_signals_file_missing() {
        let result = eval_one(
            r#"(condition-case err (call-process-region 1 1 "/nonexistent/program_xyz") (error (car err)))"#,
        );
        assert_eq!(result, "OK file-missing");
    }

    #[test]
    fn call_process_symbol_destination_signals_wrong_type_argument() {
        let echo = find_bin("echo");
        let result = eval_one(&format!(
            r#"(condition-case err (call-process "{echo}" nil 'foo nil "x") (error err))"#
        ));
        assert_eq!(result, "OK (wrong-type-argument stringp foo)");
    }

    #[test]
    fn call_process_bad_stderr_target_signals_wrong_type_argument() {
        let echo = find_bin("echo");
        let result = eval_one(&format!(
            r#"(condition-case err (call-process "{echo}" nil '(t 99) nil "x") (error err))"#
        ));
        assert_eq!(result, "OK (wrong-type-argument stringp 99)");
    }

    #[test]
    fn process_status_wrong_arg_type() {
        let result = eval_one(r#"(process-status 999)"#);
        assert!(result.contains("ERR"));
    }

    #[test]
    fn start_process_multiple_args() {
        let echo = find_bin("echo");
        let results = eval_all(&format!(
            r#"(start-process "echo" nil "{echo}" "a" "b" "c")
               (process-name 1)"#,
        ));
        assert_eq!(results[0], "OK 1");
        assert_eq!(results[1], r#"OK "echo""#);
    }

    #[test]
    fn process_runtime_introspection_controls() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(let ((p (start-process "proc-introspect" nil "{cat}")))
                 (list
                  (processp p)
                  (equal (process-live-p p) '(run open listen connect stop))
                  (integerp (process-id p))
                  (process-contact p t)
                  (process-filter p)
                  (set-process-filter p nil)
                  (set-process-filter p 'ignore)
                  (process-filter p)
                  (process-sentinel p)
                  (set-process-sentinel p nil)
                  (set-process-sentinel p 'ignore)
                  (process-sentinel p)
                  (set-process-plist p '(a 1))
                  (process-get p 'a)
                  (process-put p 'k 2)
                  (process-get p 'k)
                  (process-query-on-exit-flag p)
                  (set-process-query-on-exit-flag p nil)
                  (process-query-on-exit-flag p)
                  (delete-process p)
                  (process-live-p p)))"#,
        ));
        assert_eq!(
            results[0],
            "OK (t t t t internal-default-process-filter internal-default-process-filter ignore ignore internal-default-process-sentinel internal-default-process-sentinel ignore ignore (a 1 k 2) 1 (a 1 k 2) 2 t nil nil nil nil)"
        );
    }

    #[test]
    fn process_contact_keyword_matrix_for_network_and_pipe() {
        let result = eval_one(
            r#"(list
                (let ((p (make-network-process :name "neo-contact-key-net" :server t :service 0)))
                  (unwind-protect
                      (let ((port (process-contact p :service))
                            (local (process-contact p :local)))
                        (list
                         (stringp (process-contact p :name))
                         (eq (process-contact p :server) t)
                         (integerp port)
                         (and (vectorp local)
                              (= (length local) 5)
                              (= (aref local 0) 127)
                              (= (aref local 4) port))
                         (null (process-contact p :remote))
                         (null (process-contact p :coding))
                         (null (process-contact p :foo))))
                    (ignore-errors (delete-process p))))
                (let ((p (make-pipe-process :name "neo-contact-key-pipe")))
                  (unwind-protect
                      (list
                       (stringp (process-contact p :name))
                       (null (process-contact p :server))
                       (null (process-contact p :service))
                       (null (process-contact p :local))
                       (null (process-contact p :remote))
                       (null (process-contact p :coding))
                       (null (process-contact p :foo)))
                    (ignore-errors (delete-process p)))))"#,
        );
        assert_eq!(result, "OK ((t t t t t t t) (t t t t t t t))");
    }

    #[test]
    fn process_stale_mutator_matrix_matches_oracle() {
        let cat = find_bin("cat");
        let result = eval_one(&format!(
            r#"(let ((p (start-process "proc-stale-mutator" nil "{cat}")))
                 (unwind-protect
                     (progn
                       (delete-process p)
                       (list
                        (set-process-filter p 'ignore)
                        (set-process-sentinel p 'ignore)
                        (set-process-plist p '(a 1))
                        (process-put p 'k 2)
                        (set-process-query-on-exit-flag p nil)
                        (set-process-buffer p nil)
                        (set-process-coding-system p 'utf-8-unix)
                        (set-process-inherit-coding-system-flag p t)
                        (set-process-thread p nil)
                        (set-process-window-size p 10 20)
                        (set-process-datagram-address p nil)))
                   (ignore-errors (delete-process p))))"#,
        ));
        assert_eq!(result, "OK (ignore ignore (a 1 k 2) (a 1 k 2) nil nil nil t nil nil nil)");
    }

    #[test]
    fn process_stale_control_matrix_matches_oracle() {
        let cat = find_bin("cat");
        let result = eval_one(&format!(
            r#"(let ((p (start-process "proc-stale-control" nil "{cat}")))
                 (unwind-protect
                     (progn
                       (delete-process p)
                       (list
                        (condition-case err (continue-process p) (error (car err)))
                        (condition-case err (interrupt-process p) (error (car err)))
                        (condition-case err (kill-process p) (error (car err)))
                        (condition-case err (stop-process p) (error (car err)))
                        (condition-case err (quit-process p) (error (car err)))
                        (let ((rv (signal-process p 0)))
                          (or (eq rv 0) (eq rv -1)))
                        (set-process-query-on-exit-flag p nil)
                        (process-query-on-exit-flag p)
                        (process-live-p p)
                        (process-status p)
                        (process-exit-status p)))
                   (ignore-errors (delete-process p))))"#,
        ));
        assert_eq!(result, "OK (error error error error error t nil nil nil signal 9)");
    }

    #[test]
    fn process_attributes_runtime_shape_matches_oracle() {
        let result = eval_one(
            r#"(let ((attrs (process-attributes (emacs-pid))))
                 (list
                  (listp attrs)
                  (null (assq 'pid attrs))
                  (let ((pair (assq 'user attrs)))
                    (and (consp pair) (stringp (cdr pair))))
                  (let ((pair (assq 'group attrs)))
                    (and (consp pair) (stringp (cdr pair))))
                  (let ((pair (assq 'euid attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'egid attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'comm attrs)))
                    (and (consp pair) (stringp (cdr pair))))
                  (let ((pair (assq 'state attrs)))
                    (and (consp pair) (stringp (cdr pair))))
                  (let ((pair (assq 'ppid attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'pgrp attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'sess attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'tpgid attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'minflt attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'majflt attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'cminflt attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'cmajflt attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'pri attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'nice attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'thcount attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'vsize attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'rss attrs)))
                    (and (consp pair) (integerp (cdr pair))))
                  (let ((pair (assq 'ttname attrs)))
                    (and (consp pair) (stringp (cdr pair))))
                  (process-attributes -1)
                  (condition-case err (process-attributes 'x) (error err))
                  (process-attributes 999999999)))"#,
        );
        assert_eq!(
            result,
            "OK (t t t t t t t t t t t t t t t t t t t t t t nil (wrong-type-argument numberp x) nil)"
        );
    }

    #[test]
    fn process_attributes_timing_memory_shape_matches_oracle() {
        let result = eval_one(
            r#"(let ((attrs (process-attributes (emacs-pid))))
                 (list
                  (let ((pair (assq 'utime attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'stime attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'time attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'cutime attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'cstime attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'ctime attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'start attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'etime attrs)))
                    (and (consp pair) (consp (cdr pair))))
                  (let ((pair (assq 'pcpu attrs)))
                    (and (consp pair) (floatp (cdr pair))))
                  (let ((pair (assq 'pmem attrs)))
                    (and (consp pair) (floatp (cdr pair))))
                  (let ((pair (assq 'args attrs)))
                    (and (consp pair) (stringp (cdr pair))))
                  (null (assq 'pid attrs))))"#,
        );
        assert_eq!(result, "OK (t t t t t t t t t t t t)");
    }

    #[test]
    fn accept_process_output_and_get_process_runtime_surface() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(condition-case err (accept-process-output) (error err))
               (condition-case err (accept-process-output nil 0.01) (error err))
               (condition-case err (accept-process-output 1) (error err))
               (condition-case err (accept-process-output nil "x") (error err))
               (let ((p (start-process "proc-get-probe" nil "{cat}")))
                 (list
                  (processp (get-process "proc-get-probe"))
                  (eq p (get-process "proc-get-probe"))
                  (accept-process-output p 0.0)
                  (delete-process p)
                  (accept-process-output p 0.0)
                  (get-process "proc-get-probe")))
               (condition-case err (get-process 'proc-get-probe) (error err))"#,
        ));
        assert_eq!(results[0], "OK nil");
        assert_eq!(results[1], "OK nil");
        assert_eq!(results[2], "OK (wrong-type-argument processp 1)");
        assert_eq!(results[3], r#"OK (wrong-type-argument numberp "x")"#);
        assert_eq!(results[4], "OK (t t nil nil nil nil)");
        assert_eq!(
            results[5],
            "OK (wrong-type-argument stringp proc-get-probe)"
        );
    }

    #[test]
    fn accept_process_output_millis_contract_matches_oracle() {
        let results = eval_all(
            r#"(condition-case err (accept-process-output nil 0.1 "x") (error err))
               (condition-case err (accept-process-output nil nil "x") (error err))
               (condition-case err (accept-process-output nil 1 "x") (error err))
               (condition-case err (accept-process-output nil 0.1 nil) (error err))
               (condition-case err (accept-process-output nil 0.1 0) (error err))
               (condition-case err (accept-process-output nil 1 2) (error err))"#,
        );
        assert_eq!(results[0], r#"OK (wrong-type-argument fixnump "x")"#);
        assert_eq!(results[1], r#"OK (wrong-type-argument fixnump "x")"#);
        assert_eq!(results[2], r#"OK (wrong-type-argument fixnump "x")"#);
        assert_eq!(results[3], "OK nil");
        assert_eq!(results[4], "OK (wrong-type-argument fixnump 0.1)");
        assert_eq!(results[5], "OK nil");
    }

    #[test]
    fn process_mark_type_thread_send_and_running_child_runtime_surface() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(let ((p (start-process "proc-mark-type-thread-send" nil "{cat}")))
                 (unwind-protect
                     (list
                      (processp p)
                      (eq (process-type p) 'real)
                      (not (processp (process-thread p)))
                      (markerp (process-mark p))
                      (marker-buffer (process-mark p))
                      (marker-position (process-mark p))
                      (process-running-child-p p)
                      (processp (process-send-eof p))
                      (with-temp-buffer
                        (insert "abc")
                        (process-send-region p (point-min) (point-max)))
                      (delete-process p)
                      (process-live-p p))
                   (ignore-errors (delete-process p))))
               (condition-case err (process-send-eof) (error (car err)))
               (condition-case err (process-running-child-p) (error (car err)))
               (condition-case err (process-mark 'x) (error err))
               (condition-case err (process-type 'x) (error err))
               (condition-case err (process-thread 'x) (error err))
               (condition-case err (process-send-region 'x 1 1) (error err))
               (condition-case err (process-send-eof 'x) (error err))
               (condition-case err (process-running-child-p 'x) (error err))
               (condition-case err (process-send-eof nil nil) (error (car err)))
               (condition-case err (process-running-child-p nil nil) (error (car err)))"#,
        ));
        assert_eq!(results[0], "OK (t t t t nil nil nil t nil nil nil)");
        assert_eq!(results[1], "OK error");
        assert_eq!(results[2], "OK error");
        assert_eq!(results[3], "OK (wrong-type-argument processp x)");
        assert_eq!(results[4], "OK (wrong-type-argument processp x)");
        assert_eq!(results[5], "OK (wrong-type-argument processp x)");
        assert_eq!(results[6], "OK (wrong-type-argument processp x)");
        assert_eq!(results[7], "OK (wrong-type-argument processp x)");
        assert_eq!(results[8], "OK (wrong-type-argument processp x)");
        assert_eq!(results[9], "OK wrong-number-of-arguments");
        assert_eq!(results[10], "OK wrong-number-of-arguments");
    }

    #[test]
    fn process_coding_tty_and_kill_buffer_query_runtime_surface() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(let ((p (start-process "proc-coding-tty-query" nil "{cat}")))
                 (unwind-protect
                     (list
                      (equal (process-coding-system p) '(utf-8-unix . utf-8-unix))
                      (process-datagram-address p)
                      (process-inherit-coding-system-flag p)
                      (process-kill-buffer-query-function)
                      (stringp (process-tty-name p))
                      (stringp (process-tty-name p 'stdin))
                      (stringp (process-tty-name p 'stdout))
                      (stringp (process-tty-name p 'stderr))
                      (condition-case err (process-tty-name p 0) (error err))
                      (let ((pp (make-pipe-process :name "proc-coding-tty-query-pipe")))
                        (unwind-protect
                            (list
                             (null (process-tty-name pp))
                             (null (process-tty-name pp nil))
                             (null (process-tty-name pp 'stdin))
                             (null (process-tty-name pp 'stdout))
                             (null (process-tty-name pp 'stderr)))
                          (ignore-errors (delete-process pp))))
                      (let ((np (make-network-process :name "proc-coding-tty-query-network" :server t :service 0)))
                        (unwind-protect
                            (list
                             (null (process-tty-name np))
                             (null (process-tty-name np nil))
                             (null (process-tty-name np 'stdin))
                             (null (process-tty-name np 'stdout))
                             (null (process-tty-name np 'stderr)))
                          (ignore-errors (delete-process np))))
                      (delete-process p)
                      (process-live-p p))
                   (ignore-errors (delete-process p))))
               (condition-case err (process-coding-system 'x) (error err))
               (condition-case err (process-datagram-address 'x) (error err))
               (condition-case err (process-inherit-coding-system-flag 'x) (error err))
               (condition-case err (process-tty-name 'x) (error err))
               (condition-case err (process-tty-name nil) (error err))
               (condition-case err (process-tty-name 'x t) (error err))
               (condition-case err (process-kill-buffer-query-function nil) (error (car err)))
               (condition-case err (process-coding-system) (error (car err)))
               (condition-case err (process-datagram-address) (error (car err)))
               (condition-case err (process-inherit-coding-system-flag) (error (car err)))
               (condition-case err (process-tty-name) (error (car err)))"#,
        ));
        assert_eq!(
            results[0],
            "OK (t nil nil t t t t t (error \"Unknown stream\" 0) (t t t t t) (t t t t t) nil nil)"
        );
        assert_eq!(results[1], "OK (wrong-type-argument processp x)");
        assert_eq!(results[2], "OK (wrong-type-argument processp x)");
        assert_eq!(results[3], "OK (wrong-type-argument processp x)");
        assert_eq!(results[4], "OK (wrong-type-argument processp x)");
        assert_eq!(results[5], "OK (wrong-type-argument processp nil)");
        assert_eq!(results[6], "OK (wrong-type-argument processp x)");
        assert_eq!(results[7], "OK wrong-number-of-arguments");
        assert_eq!(results[8], "OK wrong-number-of-arguments");
        assert_eq!(results[9], "OK wrong-number-of-arguments");
        assert_eq!(results[10], "OK wrong-number-of-arguments");
        assert_eq!(results[11], "OK wrong-number-of-arguments");
    }

    #[test]
    fn process_file_lines_shell_and_menu_runtime_surface() {
        let echo = find_bin("echo");
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(mapcar (lambda (s)
                         (list s
                               (fboundp s)
                               (subrp (symbol-function s))
                               (subr-arity (symbol-function s))
                               (commandp s)))
                       '(process-file
                         process-file-shell-command
                         process-lines
                         process-lines-ignore-status
                         process-lines-handling-status
                         process-menu-delete-process
                         process-menu-visit-buffer
                         process-menu-mode))
               (with-temp-buffer
                 (list (process-file "{echo}" nil t nil "hi")
                       (string-prefix-p "hi" (buffer-string))))
               (condition-case err (process-file nil nil t nil) (error err))
               (with-temp-buffer
                 (list (process-file-shell-command "echo hi" nil t nil)
                       (string-prefix-p "hi" (buffer-string))))
               (condition-case err (process-file-shell-command 1 nil t nil) (error err))
               (process-lines "{echo}" "hello")
               (condition-case err (process-lines "sh" "-c" "exit 5") (error err))
               (process-lines-ignore-status "sh" "-c" "echo hi; exit 5")
               (let ((x nil))
                 (list
                  (process-lines-handling-status "sh" (lambda (&rest args) (setq x args)) "-c" "exit 9")
                  x))
               (condition-case err (process-lines-handling-status "echo" "hello") (error err))
               (condition-case err
                   (let ((b (get-buffer-create "pmenu-test")))
                     (with-current-buffer b
                       (let ((p (start-process "pmenu-proc" "pmenu-test" "{cat}")))
                         (list (processp p) (process-menu-delete-process) (process-live-p p)))))
                 (error err))
               (with-temp-buffer
                 (condition-case err
                     (process-menu-delete-process)
                   (error (and (eq (car err) 'error)
                               (string-match-p "has no process" (cadr err))
                               t))))
               (condition-case err (process-menu-visit-buffer nil) (error err))
               (condition-case err (process-menu-visit-buffer 1) (error err))
               (process-menu-mode)"#,
        ));
        assert_eq!(
            results[0],
            "OK ((process-file t t (1 . many) nil) (process-file-shell-command t t (1 . many) nil) (process-lines t t (1 . many) nil) (process-lines-ignore-status t t (1 . many) nil) (process-lines-handling-status t t (2 . many) nil) (process-menu-delete-process t t (0 . 0) t) (process-menu-visit-buffer t t (1 . 1) nil) (process-menu-mode t t (0 . 0) t))"
        );
        assert_eq!(results[1], "OK (0 t)");
        assert_eq!(results[2], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[3], "OK (0 t)");
        assert_eq!(results[4], "OK (wrong-type-argument sequencep 1)");
        assert_eq!(results[5], r#"OK ("hello")"#);
        assert_eq!(results[6], r#"OK (error "sh exited with status 5")"#);
        assert_eq!(results[7], r#"OK ("hi")"#);
        assert_eq!(results[8], "OK (nil (9))");
        assert_eq!(results[9], r#"OK (invalid-function "hello")"#);
        assert_eq!(
            results[10],
            r#"OK (error "Buffer does not seem to be associated with any file")"#
        );
        assert_eq!(results[11], "OK t");
        assert_eq!(
            results[12],
            "OK (wrong-type-argument integer-or-marker-p nil)"
        );
        assert_eq!(results[13], "OK (wrong-type-argument stringp nil)");
        assert_eq!(results[14], "OK nil");
    }

    #[test]
    fn process_shell_wrappers_quit_and_buffer_coding_runtime_surface() {
        let cat = find_bin("cat");
        let results = eval_all(&format!(
            r#"(mapcar (lambda (s)
                         (list s
                               (fboundp s)
                               (subrp (symbol-function s))
                               (subr-arity (symbol-function s))
                               (commandp s)))
                       '(call-process-shell-command
                         start-process-shell-command
                         start-file-process
                         start-file-process-shell-command
                         quit-process
                         set-buffer-process-coding-system))
               (list
                (call-process-shell-command "echo hi")
                (call-process-shell-command nil)
                (condition-case err (call-process-shell-command 1) (error err))
                (condition-case err (call-process-shell-command) (error (car err))))
               (list
                (let ((p (start-process-shell-command "proc-spc-ok" nil "echo hi")))
                  (unwind-protect
                      (processp p)
                    (ignore-errors (delete-process p))))
                (condition-case err (start-process-shell-command nil nil "echo hi") (error err))
                (condition-case err (start-process-shell-command "proc-spc-e" nil nil) (error err))
                (condition-case err (start-process-shell-command "proc-spc-e2" nil 1) (error err))
                (let ((p (start-file-process "proc-sfp-ok" nil nil)))
                  (unwind-protect
                      (processp p)
                    (ignore-errors (delete-process p))))
                (condition-case err (start-file-process nil nil "{cat}") (error err))
                (let ((p (start-file-process-shell-command "proc-sfpsc-ok" nil "echo hi")))
                  (unwind-protect
                      (processp p)
                    (ignore-errors (delete-process p))))
                (condition-case err (start-file-process-shell-command nil nil "echo hi") (error err))
                (condition-case err (start-file-process-shell-command "proc-sfpsc-e" nil nil) (error err)))
               (list
                (let ((p (start-process "proc-quit-id" nil "{cat}")))
                  (unwind-protect
                      (list (eq (quit-process p) p) (process-live-p p))
                    (ignore-errors (delete-process p))))
                (let ((p (start-process "proc-quit-name" nil "{cat}")))
                  (unwind-protect
                      (equal (quit-process "proc-quit-name") "proc-quit-name")
                    (ignore-errors (delete-process p))))
                (with-temp-buffer
                  (let ((p (start-process "proc-quit-current" (buffer-name (current-buffer)) "{cat}")))
                    (unwind-protect
                        (eq (quit-process nil) nil)
                      (ignore-errors (delete-process p)))))
                (condition-case err (quit-process "__missing-neovm-proc__") (error err))
                (condition-case err (quit-process 'x) (error err))
                (condition-case err (quit-process 1 nil nil) (error (car err))))
               (with-temp-buffer
                 (let ((p (start-process "proc-buffer-coding" (buffer-name (current-buffer)) "{cat}")))
                   (unwind-protect
                       (list
                        (set-buffer-process-coding-system 'utf-8-unix 'binary)
                        (equal (process-coding-system p) '(utf-8-unix . binary)))
                     (ignore-errors (delete-process p)))))
               (with-temp-buffer
                 (condition-case err
                     (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix)
                   (error (car err))))"#
        ));

        assert_eq!(
            results[0],
            "OK ((call-process-shell-command t t (1 . many) nil) (start-process-shell-command t t (3 . 3) nil) (start-file-process t t (3 . many) nil) (start-file-process-shell-command t t (3 . 3) nil) (quit-process t t (0 . 2) nil) (set-buffer-process-coding-system t t (2 . 2) t))"
        );
        assert_eq!(
            results[1],
            "OK (0 0 (wrong-type-argument sequencep 1) wrong-number-of-arguments)"
        );
        assert_eq!(
            results[2],
            "OK (t (error \":name value not a string\") (wrong-type-argument stringp nil) (wrong-type-argument stringp 1) t (error \":name value not a string\") t (error \":name value not a string\") (wrong-type-argument stringp nil))"
        );
        assert_eq!(
            results[3],
            "OK ((t (run open listen connect stop)) t t (error \"Process __missing-neovm-proc__ does not exist\") (wrong-type-argument processp x) wrong-number-of-arguments)"
        );
        assert_eq!(results[4], "OK (nil t)");
        assert_eq!(results[5], "OK error");
    }

    #[test]
    fn process_list_network_serial_runtime_surface() {
        let results = eval_all(
            r#"(mapcar (lambda (s)
                         (list s
                               (fboundp s)
                               (subrp (symbol-function s))
                               (subr-arity (symbol-function s))
                               (commandp s)))
                       '(list-system-processes
                         num-processors
                         list-processes
                         list-processes--refresh
                         make-network-process
                         make-pipe-process
                         make-serial-process
                         serial-process-configure
                         set-network-process-option))
               (let ((n0 (num-processors))
                     (n1 (num-processors t)))
                 (list
                  (listp (list-system-processes))
                  (integerp (car (list-system-processes)))
                  (not (null (member (emacs-pid) (list-system-processes))))
                  (condition-case err (list-system-processes nil) (error (car err)))
                  (integerp n0)
                  (integerp n1)
                  (> n0 0)
                  (= n0 n1)
                  (condition-case err (num-processors 1 2) (error (car err)))
                  (list-processes)
                  (list-processes nil)
                  (list-processes t)
                  (list-processes nil nil)
                  (list-processes nil t)
                  (condition-case err (list-processes nil nil nil) (error (car err)))
                  (listp (list-processes--refresh))
                  (equal (car (list-processes--refresh)) "")
                  (condition-case err (list-processes--refresh nil) (error (car err)))))
               (list
                (make-network-process)
                (condition-case err (make-network-process :name "np") (error err))
                (condition-case err (make-network-process :name 1) (error err))
                (condition-case err (make-network-process :service 80) (error err))
                (let ((p (make-network-process :name "np-server" :server t :service 0)))
                  (unwind-protect
                      (processp p)
                    (ignore-errors (delete-process p))))
                (make-pipe-process)
                (let ((p (make-pipe-process :name "pp")))
                  (unwind-protect
                      (processp p)
                    (ignore-errors (delete-process p))))
                (condition-case err (make-pipe-process :name 1) (error err))
                (make-serial-process)
                (condition-case err (make-serial-process :name "sp" :port t :speed 9600) (error err))
                (condition-case err (make-serial-process :name "sp" :port 1 :speed 9600) (error err))
                (condition-case err (make-serial-process :name "sp") (error err))
                (condition-case err (make-serial-process :name "sp" :port "/tmp/no-port") (error err))
                (with-temp-buffer
                  (condition-case err (serial-process-configure) (error (car err))))
                (with-temp-buffer
                  (let ((p (start-process "serial-cfg-proc" nil "cat")))
                    (unwind-protect
                        (condition-case err (serial-process-configure p) (error (car err)))
                      (ignore-errors (delete-process p)))))
                (condition-case err (set-network-process-option) (error (car err)))
                (condition-case err (set-network-process-option 1 :foo 1) (error err))
                (let ((p (start-process "netopt-real" nil "cat")))
                  (unwind-protect
                      (condition-case err (set-network-process-option p :foo 1) (error err))
                    (ignore-errors (delete-process p))))
                (let ((p (make-network-process :name "netopt-network" :server t :service 0)))
                  (unwind-protect
                      (condition-case err (set-network-process-option p :foo 1) (error err))
                    (ignore-errors (delete-process p)))))"#,
        );

        assert_eq!(
            results[0],
            "OK ((list-system-processes t t (0 . 0) nil) (num-processors t t (0 . 1) nil) (list-processes t t (0 . 2) t) (list-processes--refresh t t (0 . 0) nil) (make-network-process t t (0 . many) nil) (make-pipe-process t t (0 . many) nil) (make-serial-process t t (0 . many) nil) (serial-process-configure t t (0 . many) nil) (set-network-process-option t t (3 . 4) nil))"
        );
        assert_eq!(
            results[1],
            "OK (t t t wrong-number-of-arguments t t t t wrong-number-of-arguments nil nil nil nil nil wrong-number-of-arguments t t wrong-number-of-arguments)"
        );
        assert_eq!(
            results[2],
            "OK (nil (wrong-type-argument stringp nil) (error \":name value not a string\") (error \"Missing :name keyword parameter\") t nil t (error \":name value not a string\") nil (wrong-type-argument stringp t) (wrong-type-argument stringp 1) (error \"No port specified\") (error \":speed not specified\") error error wrong-number-of-arguments (wrong-type-argument processp 1) (error \"Process is not a network process\") (error \"Unknown or unsupported option\"))"
        );
    }

    #[test]
    fn list_processes_refresh_returns_propertized_spacer() {
        let result = eval_one(r#"(list-processes--refresh)"#);
        assert_eq!(
            result,
            r##"OK ("" header-line-indent #(" " 0 1 (display (space :align-to (+ header-line-indent-width 0)))))"##
        );
    }

    #[test]
    fn process_helper_wrapper_runtime_surface() {
        let results = eval_all(
            r#"(mapcar (lambda (s)
                         (list s
                               (fboundp s)
                               (subrp (symbol-function s))
                               (subr-arity (symbol-function s))
                               (commandp s)))
                       '(backquote-delay-process
                         backquote-process
                         clone-process
                         internal-default-interrupt-process
                         internal-default-process-filter
                         internal-default-process-sentinel
                         internal-default-signal-process
                         isearch-process-search-char
                         isearch-process-search-string
                         minibuffer--sort-preprocess-history
                         print--preprocess
                         syntax-propertize--in-process-p
                         tooltip-process-prompt-regexp
                         window--adjust-process-windows
                         window--process-window-list
                         window-adjust-process-window-size
                         window-adjust-process-window-size-largest
                         window-adjust-process-window-size-smallest))
               (list
                (backquote-delay-process nil nil)
                (backquote-process nil)
                (backquote-process nil nil)
                (condition-case err (clone-process nil) (error err))
                (with-temp-buffer
                  (condition-case err (internal-default-interrupt-process) (error (car err))))
                (with-temp-buffer
                  (condition-case err (internal-default-signal-process nil 9) (error (car err))))
                (condition-case err (internal-default-process-filter nil "x") (error err))
                (condition-case err (internal-default-process-sentinel nil "x") (error err))
                (minibuffer--sort-preprocess-history nil)
                (print--preprocess nil)
                (syntax-propertize--in-process-p)
                (condition-case err (tooltip-process-prompt-regexp "x") (error err))
                (window--adjust-process-windows)
                (window--process-window-list)
                (window-adjust-process-window-size nil nil)
                (window-adjust-process-window-size-largest nil nil)
                (window-adjust-process-window-size-smallest nil nil)
                (condition-case err (backquote-delay-process nil) (error err))
                (condition-case err (backquote-process) (error err))
                (condition-case err (internal-default-interrupt-process nil nil nil) (error err))
                (condition-case err (internal-default-signal-process) (error err))
                (condition-case err (internal-default-process-filter nil) (error err))
                (condition-case err (minibuffer--sort-preprocess-history) (error err))
                (condition-case err (window-adjust-process-window-size nil) (error err))
                (condition-case err (isearch-process-search-char) (error err))
                (condition-case err (isearch-process-search-string "x") (error err)))"#,
        );

        assert_eq!(
            results[0],
            "OK ((backquote-delay-process t t (2 . 2) nil) (backquote-process t t (1 . 2) nil) (clone-process t t (1 . 2) nil) (internal-default-interrupt-process t t (0 . 2) nil) (internal-default-process-filter t t (2 . 2) nil) (internal-default-process-sentinel t t (2 . 2) nil) (internal-default-signal-process t t (2 . 3) nil) (isearch-process-search-char t t (1 . 2) nil) (isearch-process-search-string t t (2 . 2) nil) (minibuffer--sort-preprocess-history t t (1 . 1) nil) (print--preprocess t t (1 . 1) nil) (syntax-propertize--in-process-p t t (0 . 0) nil) (tooltip-process-prompt-regexp t t (1 . 1) nil) (window--adjust-process-windows t t (0 . 0) nil) (window--process-window-list t t (0 . 0) nil) (window-adjust-process-window-size t t (2 . 2) nil) (window-adjust-process-window-size-largest t t (2 . 2) nil) (window-adjust-process-window-size-smallest t t (2 . 2) nil))"
        );
        assert_eq!(
            results[1],
            "OK ((0 quote (nil)) (0) (0) (wrong-type-argument processp nil) error error (wrong-type-argument processp nil) (wrong-type-argument processp nil) nil nil nil (wrong-type-argument processp \"x\") nil nil nil nil nil (wrong-number-of-arguments backquote-delay-process 1) (wrong-number-of-arguments backquote-process 0) (wrong-number-of-arguments internal-default-interrupt-process 3) (wrong-number-of-arguments internal-default-signal-process 0) (wrong-number-of-arguments internal-default-process-filter 1) (wrong-number-of-arguments minibuffer--sort-preprocess-history 0) (wrong-number-of-arguments window-adjust-process-window-size 1) (wrong-number-of-arguments isearch-process-search-char 0) (wrong-number-of-arguments isearch-process-search-string 1))"
        );
    }

    #[test]
    fn minibuffer_sort_preprocess_history_sequence_contract() {
        let results = eval_all(
            r#"(minibuffer--sort-preprocess-history nil)
               (minibuffer--sort-preprocess-history "")
               (minibuffer--sort-preprocess-history [97])
               (minibuffer--sort-preprocess-history '(97))
               (condition-case err (minibuffer--sort-preprocess-history 1) (error err))
               (condition-case err (minibuffer--sort-preprocess-history) (error err))"#,
        );

        assert_eq!(results[0], "OK nil");
        assert_eq!(results[1], "OK nil");
        assert_eq!(results[2], "OK nil");
        assert_eq!(results[3], "OK nil");
        assert_eq!(results[4], "OK (wrong-type-argument sequencep 1)");
        assert_eq!(
            results[5],
            "OK (wrong-number-of-arguments minibuffer--sort-preprocess-history 0)"
        );
    }

    #[test]
    fn window_adjust_process_window_size_requires_list_window() {
        let results = eval_all(
            r#"(condition-case err (window-adjust-process-window-size 1 2) (error err))
               (condition-case err (window-adjust-process-window-size-largest 1 2) (error err))
               (condition-case err (window-adjust-process-window-size-smallest 1 2) (error err))
               (window-adjust-process-window-size nil nil)
               (window-adjust-process-window-size-largest nil nil)
               (window-adjust-process-window-size-smallest nil nil)"#,
        );

        assert_eq!(results[0], "OK (wrong-type-argument listp 2)");
        assert_eq!(results[1], "OK (wrong-type-argument listp 2)");
        assert_eq!(results[2], "OK (wrong-type-argument listp 2)");
        assert_eq!(results[3], "OK nil");
        assert_eq!(results[4], "OK nil");
        assert_eq!(results[5], "OK nil");
    }

    #[test]
    fn network_interface_broadcast_derivation_helpers() {
        let ipv4_address = int_vector(&[192, 168, 1, 30, 0]);
        let ipv4_netmask = int_vector(&[255, 255, 255, 0, 0]);
        let ipv4_raw = int_vector(&[0, 0, 0, 0, 0]);
        assert_eq!(
            derive_network_interface_list_broadcast(
                NetworkAddressFamily::Ipv4,
                &ipv4_address,
                &ipv4_netmask,
                &ipv4_raw,
            ),
            int_vector(&[192, 168, 1, 255, 0])
        );
        assert_eq!(
            derive_network_interface_info_broadcast(
                NetworkAddressFamily::Ipv4,
                &ipv4_address,
                &ipv4_address,
            ),
            int_vector(&[0, 0, 0, 0, 0])
        );
        let ipv4_nontrivial_raw = int_vector(&[172, 17, 255, 255, 0]);
        assert_eq!(
            derive_network_interface_info_broadcast(
                NetworkAddressFamily::Ipv4,
                &int_vector(&[172, 17, 0, 1, 0]),
                &ipv4_nontrivial_raw,
            ),
            ipv4_nontrivial_raw
        );

        let ipv6_address = int_vector(&[9224, 33287, 9568, 22592, 60060, 9727, 65190, 14566, 0]);
        let ipv6_netmask = int_vector(&[65535, 65535, 65535, 65535, 0, 0, 0, 0, 0]);
        assert_eq!(
            derive_network_interface_list_broadcast(
                NetworkAddressFamily::Ipv6,
                &ipv6_address,
                &ipv6_netmask,
                &int_vector(&[0, 0, 0, 0, 0, 0, 0, 0, 0]),
            ),
            int_vector(&[9224, 33287, 9568, 22592, 65535, 65535, 65535, 65535, 0])
        );
    }

    #[test]
    fn network_lookup_literal_family_filtering_helpers() {
        let loopback_v4 = int_vector(&[127, 0, 0, 1, 0]);
        let loopback_v6 = int_vector(&[0, 0, 0, 0, 0, 0, 0, 1, 0]);

        let v4_any = resolve_network_lookup_addresses("127.0.0.1", None);
        let v4_only =
            resolve_network_lookup_addresses("127.0.0.1", Some(NetworkAddressFamily::Ipv4));
        let v4_rejected =
            resolve_network_lookup_addresses("127.0.0.1", Some(NetworkAddressFamily::Ipv6));
        assert!(!v4_any.is_empty());
        assert_eq!(v4_any, v4_only);
        assert_eq!(v4_any[0], loopback_v4);
        assert!(v4_rejected.is_empty());

        let v6_any = resolve_network_lookup_addresses("::1", None);
        let v6_only = resolve_network_lookup_addresses("::1", Some(NetworkAddressFamily::Ipv6));
        let v6_rejected = resolve_network_lookup_addresses("::1", Some(NetworkAddressFamily::Ipv4));
        assert_eq!(v6_any, v6_only);
        if let Some(first) = v6_any.first() {
            assert_eq!(first, &loopback_v6);
        }
        assert!(v6_rejected.is_empty());
    }

    #[test]
    fn network_lookup_embedded_nul_normalizes_like_c_strings() {
        let plain = resolve_network_lookup_addresses("abc", None);
        let embedded_nul = resolve_network_lookup_addresses("abc\0def", None);
        assert_eq!(embedded_nul, plain);

        let empty = resolve_network_lookup_addresses("", None);
        let nul_only = resolve_network_lookup_addresses("\0", None);
        assert_eq!(nul_only, empty);
    }

    #[test]
    fn process_network_interface_and_signal_runtime_surface() {
        let results = eval_all(
            r#"(mapcar (lambda (s)
                         (let ((fn (and (fboundp s) (symbol-function s))))
                           (list s
                                 (fboundp s)
                                 (and fn (subrp fn))
                                 (and fn (subr-arity fn))
                                 (commandp s))))
                       '(process-connection
                         format-network-address
                         network-interface-list
                         network-interface-info
                         network-lookup-address-info
                         signal-names))
               (let* ((ifname (or (and (fboundp 'network-interface-list)
                                       (stringp (caar (network-interface-list)))
                                       (caar (network-interface-list)))
                                  "lo")))
                 (list
                  (format-network-address [127 0 0 1 80])
                  (format-network-address [127 0 0 1 80] t)
                  (format-network-address [0 0 0 0 0 0 0 1 80])
                  (format-network-address [0 0 0 0 0 0 0 1 80] t)
                  (format-network-address "x")
                  (format-network-address nil)
                  (format-network-address [1])
                  (format-network-address [127 0 0 1 65536])
                  (format-network-address [0 0 0 0 0 0 0 1 65536])
                  (condition-case err (format-network-address) (error err))
                  (listp (network-interface-list))
                  (consp (car (network-interface-list)))
                  (stringp (caar (network-interface-list)))
                  (vectorp (cdar (network-interface-list)))
                  (listp (network-interface-list nil))
                  (let ((entry (car (network-interface-list t))))
                    (and (listp entry)
                         (= (length entry) 4)
                         (vectorp (nth 1 entry))
                         (vectorp (nth 2 entry))
                         (vectorp (nth 3 entry))))
                  (let* ((entries (network-interface-list t))
                         (ok t))
                    (while (and ok entries)
                      (let* ((entry (car entries))
                             (addr (nth 1 entry))
                             (bc (nth 2 entry))
                             (mask (nth 3 entry))
                             (len (length addr))
                             (limit (if (= len 5) 4 8))
                             (bits-mask (if (= len 5) #xff #xffff))
                             (idx 0)
                             (vals nil))
                        (while (< idx limit)
                          (setq vals
                                (append vals
                                        (list (logand bits-mask
                                                      (logior (aref addr idx)
                                                              (lognot (aref mask idx)))))))
                          (setq idx (1+ idx)))
                        (setq vals (append vals '(0)))
                        (setq ok (equal bc (apply #'vector vals))))
                      (setq entries (cdr entries)))
                    ok)
                  (condition-case err (network-interface-list nil nil nil) (error err))
                  (condition-case err (network-interface-list nil t) (error err))
                  (let* ((entries (network-interface-list t 'ipv4))
                         (ok t))
                    (while (and ok entries)
                      (let* ((entry (car entries))
                             (addr (nth 1 entry)))
                        (setq ok (and (vectorp addr) (= (length addr) 5))))
                      (setq entries (cdr entries)))
                    ok)
                  (let* ((entries (network-interface-list t 'ipv6))
                         (ok t))
                    (while (and ok entries)
                      (let* ((entry (car entries))
                             (addr (nth 1 entry)))
                        (setq ok (and (vectorp addr) (= (length addr) 9))))
                      (setq entries (cdr entries)))
                    ok)
                  (let* ((entries (network-interface-list nil 'ipv4))
                         (ok t))
                    (while (and ok entries)
                      (let* ((entry (car entries))
                             (addr (cdr entry)))
                        (setq ok (and (vectorp addr) (= (length addr) 5))))
                      (setq entries (cdr entries)))
                    ok)
                  (let* ((entries (network-interface-list nil 'ipv6))
                         (ok t))
                    (while (and ok entries)
                      (let* ((entry (car entries))
                             (addr (cdr entry)))
                        (setq ok (and (vectorp addr) (= (length addr) 9))))
                      (setq entries (cdr entries)))
                    ok)
                  (let ((info (network-interface-info ifname)))
                    (and (listp info)
                         (= (length info) 5)
                         (vectorp (car info))
                         (vectorp (nth 1 info))
                         (vectorp (nth 2 info))
                         (or (null (nth 3 info))
                             (consp (nth 3 info)))
                         (listp (nth 4 info))))
                  (let ((lo-info (network-interface-info "lo")))
                    (and (listp lo-info)
                         (= (length lo-info) 5)
                         (vectorp (car lo-info))
                         (vectorp (nth 1 lo-info))
                         (vectorp (nth 2 lo-info))))
                  (let* ((ifname (car (car (network-interface-list nil 'ipv4))))
                         (info (and ifname (network-interface-info ifname)))
                         (entries (network-interface-list nil 'ipv4))
                         (found nil))
                    (while entries
                      (let ((entry (car entries)))
                        (if (and (equal (car entry) ifname)
                                 (equal (cdr entry) (car info)))
                            (setq found t)))
                      (setq entries (cdr entries)))
                    (or (null ifname) found))
                  (let* ((info (network-interface-info ifname))
                         (addr (car info))
                         (bc (nth 1 info))
                         (mask (nth 2 info))
                         (len (length addr)))
                    (and (or (= len 5) (= len 9))
                         (= (length bc) len)
                         (= (length mask) len)))
                  (let* ((lo-info (network-interface-info "lo"))
                         (addr (car lo-info))
                         (bc (nth 1 lo-info))
                         (mask (nth 2 lo-info)))
                    (and (= (length addr) (length bc))
                         (= (length addr) (length mask))))
                  (equal (network-interface-info (concat "lo" (string 0) "x"))
                         (network-interface-info "lo"))
                  (condition-case err (network-interface-info nil) (error err))
                  (condition-case err (network-interface-info "abcdefghijklmnop") (error err))
                  (condition-case err (network-interface-info (concat "abcdefghijklmnop" (string 0))) (error err))
                  (condition-case err (network-interface-info (concat "aaaaaaaaaaaaaa" (string 233))) (error err))
                  (null (network-interface-info (concat "aaaaaaaaaaaaa" (string 233))))
                  (listp (network-lookup-address-info "localhost"))
                  (vectorp (car (network-lookup-address-info "localhost")))
                  (listp (network-lookup-address-info "localhost" 'ipv4))
                  (vectorp (car (network-lookup-address-info "localhost" 'ipv6)))
                  (let* ((v4-any (network-lookup-address-info "127.0.0.1"))
                         (v4-only (network-lookup-address-info "127.0.0.1" 'ipv4)))
                    (and (equal v4-any v4-only)
                         (consp v4-only)
                         (equal (car v4-only) [127 0 0 1 0])))
                  (null (network-lookup-address-info "127.0.0.1" 'ipv6))
                  (let* ((v6-any (network-lookup-address-info "::1"))
                         (v6-only (network-lookup-address-info "::1" 'ipv6)))
                    (and (equal v6-any v6-only)
                         (or (null v6-only)
                             (equal (car v6-only) [0 0 0 0 0 0 0 1 0]))))
                  (null (network-lookup-address-info "::1" 'ipv4))
                  (let* ((entries (network-lookup-address-info "localhost" 'ipv4))
                         (ok t))
                    (while (and ok entries)
                      (setq ok (= (length (car entries)) 5))
                      (setq entries (cdr entries)))
                    ok)
                  (let* ((entries (network-lookup-address-info "localhost" 'ipv6))
                         (ok t))
                    (while (and ok entries)
                      (setq ok (= (length (car entries)) 9))
                      (setq entries (cdr entries)))
                    ok)
                  (equal (network-lookup-address-info (concat "abc" (string 0) "def"))
                         (network-lookup-address-info "abc"))
                  (equal (network-lookup-address-info (string 0))
                         (network-lookup-address-info ""))
                  (condition-case err (network-lookup-address-info "localhost" t) (error err))
                  (condition-case err (network-lookup-address-info "localhost" 'ipv4 t) (error err))
                  (condition-case err (network-lookup-address-info 1) (error err))
                  (listp (signal-names))
                  (stringp (car (signal-names)))
                  (not (null (member "KILL" (signal-names))))
                  (condition-case err (signal-names nil) (error err))
                  (condition-case err (process-connection nil) (error err))))"#,
        );

        assert_eq!(
            results[0],
            "OK ((process-connection nil nil nil nil) (format-network-address t t (1 . 2) nil) (network-interface-list t t (0 . 2) nil) (network-interface-info t t (1 . 1) nil) (network-lookup-address-info t t (1 . 3) nil) (signal-names t t (0 . 0) nil))"
        );
        assert_eq!(
            results[1],
            "OK (\"127.0.0.1:80\" \"127.0.0.1\" \"[0:0:0:0:0:0:0:1]:80\" \"0:0:0:0:0:0:0:1\" \"x\" nil nil nil nil (wrong-number-of-arguments format-network-address 0) t t t t t t t (wrong-number-of-arguments network-interface-list 3) (error \"Unsupported address family\") t t t t t t t t t t (wrong-type-argument stringp nil) (error \"interface name too long\") (error \"interface name too long\") (error \"interface name too long\") t t t t t t t t t t t t t (error \"Unsupported family\") (error \"Unsupported hints value\") (wrong-type-argument stringp 1) t t t (wrong-number-of-arguments signal-names 1) (void-function process-connection))"
        );
    }
}
