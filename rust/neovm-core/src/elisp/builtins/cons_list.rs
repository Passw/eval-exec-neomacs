use super::*;

// ===========================================================================
// Cons / List operations
// ===========================================================================

pub(crate) fn builtin_cons(args: Vec<Value>) -> EvalResult {
    expect_args("cons", &args, 2)?;
    Ok(Value::cons(args[0], args[1]))
}

fn car_value(value: &Value) -> Result<Value, Flow> {
    match value {
        Value::Nil => Ok(Value::Nil),
        Value::Cons(cell) => Ok(with_heap(|h| h.cons_car(*cell))),
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("listp"), *value],
        )),
    }
}

fn cdr_value(value: &Value) -> Result<Value, Flow> {
    match value {
        Value::Nil => Ok(Value::Nil),
        Value::Cons(cell) => Ok(with_heap(|h| h.cons_cdr(*cell))),
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("listp"), *value],
        )),
    }
}

pub(crate) fn builtin_car(args: Vec<Value>) -> EvalResult {
    expect_args("car", &args, 1)?;
    car_value(&args[0])
}

pub(crate) fn builtin_cdr(args: Vec<Value>) -> EvalResult {
    expect_args("cdr", &args, 1)?;
    cdr_value(&args[0])
}

fn apply_cxr(mut value: Value, ops: &[u8]) -> EvalResult {
    for op in ops {
        value = match op {
            b'a' => car_value(&value)?,
            b'd' => cdr_value(&value)?,
            _ => unreachable!("invalid cxr op"),
        };
    }
    Ok(value)
}

pub(crate) fn builtin_caar(args: Vec<Value>) -> EvalResult {
    expect_args("caar", &args, 1)?;
    apply_cxr(args[0], b"aa")
}

pub(crate) fn builtin_cadr(args: Vec<Value>) -> EvalResult {
    expect_args("cadr", &args, 1)?;
    apply_cxr(args[0], b"da")
}

pub(crate) fn builtin_cdar(args: Vec<Value>) -> EvalResult {
    expect_args("cdar", &args, 1)?;
    apply_cxr(args[0], b"ad")
}

pub(crate) fn builtin_cddr(args: Vec<Value>) -> EvalResult {
    expect_args("cddr", &args, 1)?;
    apply_cxr(args[0], b"dd")
}

pub(crate) fn builtin_caaar(args: Vec<Value>) -> EvalResult {
    expect_args("caaar", &args, 1)?;
    apply_cxr(args[0], b"aaa")
}

pub(crate) fn builtin_caadr(args: Vec<Value>) -> EvalResult {
    expect_args("caadr", &args, 1)?;
    apply_cxr(args[0], b"daa")
}

pub(crate) fn builtin_cadar(args: Vec<Value>) -> EvalResult {
    expect_args("cadar", &args, 1)?;
    apply_cxr(args[0], b"ada")
}

pub(crate) fn builtin_caddr(args: Vec<Value>) -> EvalResult {
    expect_args("caddr", &args, 1)?;
    apply_cxr(args[0], b"dda")
}

pub(crate) fn builtin_cdaar(args: Vec<Value>) -> EvalResult {
    expect_args("cdaar", &args, 1)?;
    apply_cxr(args[0], b"aad")
}

pub(crate) fn builtin_cdadr(args: Vec<Value>) -> EvalResult {
    expect_args("cdadr", &args, 1)?;
    apply_cxr(args[0], b"dad")
}

pub(crate) fn builtin_cddar(args: Vec<Value>) -> EvalResult {
    expect_args("cddar", &args, 1)?;
    apply_cxr(args[0], b"add")
}

pub(crate) fn builtin_cdddr(args: Vec<Value>) -> EvalResult {
    expect_args("cdddr", &args, 1)?;
    apply_cxr(args[0], b"ddd")
}

pub(crate) fn builtin_cadddr(args: Vec<Value>) -> EvalResult {
    expect_args("cadddr", &args, 1)?;
    apply_cxr(args[0], b"ddda")
}

pub(crate) fn builtin_cddddr(args: Vec<Value>) -> EvalResult {
    expect_args("cddddr", &args, 1)?;
    apply_cxr(args[0], b"dddd")
}

pub(crate) fn builtin_caaaar(args: Vec<Value>) -> EvalResult {
    expect_args("caaaar", &args, 1)?;
    apply_cxr(args[0], b"aaaa")
}

pub(crate) fn builtin_caaadr(args: Vec<Value>) -> EvalResult {
    expect_args("caaadr", &args, 1)?;
    apply_cxr(args[0], b"daaa")
}

pub(crate) fn builtin_caadar(args: Vec<Value>) -> EvalResult {
    expect_args("caadar", &args, 1)?;
    apply_cxr(args[0], b"adaa")
}

pub(crate) fn builtin_caaddr(args: Vec<Value>) -> EvalResult {
    expect_args("caaddr", &args, 1)?;
    apply_cxr(args[0], b"ddaa")
}

pub(crate) fn builtin_cadaar(args: Vec<Value>) -> EvalResult {
    expect_args("cadaar", &args, 1)?;
    apply_cxr(args[0], b"aada")
}

pub(crate) fn builtin_cadadr(args: Vec<Value>) -> EvalResult {
    expect_args("cadadr", &args, 1)?;
    apply_cxr(args[0], b"dada")
}

pub(crate) fn builtin_caddar(args: Vec<Value>) -> EvalResult {
    expect_args("caddar", &args, 1)?;
    apply_cxr(args[0], b"adda")
}

pub(crate) fn builtin_cdaaar(args: Vec<Value>) -> EvalResult {
    expect_args("cdaaar", &args, 1)?;
    apply_cxr(args[0], b"aaad")
}

pub(crate) fn builtin_cdaadr(args: Vec<Value>) -> EvalResult {
    expect_args("cdaadr", &args, 1)?;
    apply_cxr(args[0], b"daad")
}

pub(crate) fn builtin_cdadar(args: Vec<Value>) -> EvalResult {
    expect_args("cdadar", &args, 1)?;
    apply_cxr(args[0], b"adad")
}

pub(crate) fn builtin_cdaddr(args: Vec<Value>) -> EvalResult {
    expect_args("cdaddr", &args, 1)?;
    apply_cxr(args[0], b"ddad")
}

pub(crate) fn builtin_cddaar(args: Vec<Value>) -> EvalResult {
    expect_args("cddaar", &args, 1)?;
    apply_cxr(args[0], b"aadd")
}

pub(crate) fn builtin_cddadr(args: Vec<Value>) -> EvalResult {
    expect_args("cddadr", &args, 1)?;
    apply_cxr(args[0], b"dadd")
}

pub(crate) fn builtin_cdddar(args: Vec<Value>) -> EvalResult {
    expect_args("cdddar", &args, 1)?;
    apply_cxr(args[0], b"addd")
}

pub(crate) fn builtin_car_safe(args: Vec<Value>) -> EvalResult {
    expect_args("car-safe", &args, 1)?;
    match &args[0] {
        Value::Cons(cell) => Ok(with_heap(|h| h.cons_car(*cell))),
        _ => Ok(Value::Nil),
    }
}

pub(crate) fn builtin_cdr_safe(args: Vec<Value>) -> EvalResult {
    expect_args("cdr-safe", &args, 1)?;
    match &args[0] {
        Value::Cons(cell) => Ok(with_heap(|h| h.cons_cdr(*cell))),
        _ => Ok(Value::Nil),
    }
}

pub(crate) fn builtin_setcar(args: Vec<Value>) -> EvalResult {
    expect_args("setcar", &args, 2)?;
    match &args[0] {
        Value::Cons(cell) => {
            with_heap_mut(|h| h.set_car(*cell, args[1]));
            Ok(args[1])
        }
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("consp"), args[0]],
        )),
    }
}

pub(crate) fn builtin_setcdr(args: Vec<Value>) -> EvalResult {
    expect_args("setcdr", &args, 2)?;
    match &args[0] {
        Value::Cons(cell) => {
            with_heap_mut(|h| h.set_cdr(*cell, args[1]));
            Ok(args[1])
        }
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("consp"), args[0]],
        )),
    }
}

pub(crate) fn builtin_list(args: Vec<Value>) -> EvalResult {
    Ok(Value::list(args))
}

pub(crate) fn builtin_length(args: Vec<Value>) -> EvalResult {
    expect_args("length", &args, 1)?;
    match &args[0] {
        Value::Nil => Ok(Value::Int(0)),
        Value::Cons(_) => match list_length(&args[0]) {
            Some(n) => Ok(Value::Int(n as i64)),
            None => Err(signal(
                "wrong-type-argument",
                vec![Value::symbol("listp"), args[0]],
            )),
        },
        Value::Str(id) => Ok(Value::Int(with_heap(|h| storage_char_len(h.get_string(*id))) as i64)),
        Value::Vector(v) => Ok(Value::Int(vector_sequence_length(&args[0], *v))),
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), args[0]],
        )),
    }
}

fn vector_sequence_length(sequence: &Value, vector: ObjId) -> i64 {
    super::chartable::bool_vector_length(sequence)
        .or_else(|| super::chartable::char_table_length(sequence))
        .unwrap_or_else(|| with_heap(|h| h.vector_len(vector)) as i64)
}

fn sequence_length_less_than(sequence: &Value, target: i64) -> Result<bool, Flow> {
    match sequence {
        Value::Nil => Ok(0 < target),
        Value::Str(id) => Ok((with_heap(|h| storage_char_len(h.get_string(*id))) as i64) < target),
        Value::Vector(v) => Ok(vector_sequence_length(sequence, *v) < target),
        Value::Cons(_) => {
            if target <= 0 {
                return Ok(false);
            }
            let mut remaining = target;
            let mut cursor = *sequence;
            while remaining > 0 {
                match cursor {
                    Value::Cons(cell) => {
                        cursor = with_heap(|h| h.cons_cdr(cell));
                        remaining -= 1;
                    }
                    _ => return Ok(true),
                }
            }
            Ok(false)
        }
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), *other],
        )),
    }
}

fn sequence_length_equal(sequence: &Value, target: i64) -> Result<bool, Flow> {
    match sequence {
        Value::Nil => Ok(target == 0),
        Value::Str(id) => Ok((with_heap(|h| storage_char_len(h.get_string(*id))) as i64) == target),
        Value::Vector(v) => Ok(vector_sequence_length(sequence, *v) == target),
        Value::Cons(_) => {
            if target < 0 {
                return Ok(false);
            }
            let mut remaining = target;
            let mut cursor = *sequence;
            while remaining > 0 {
                match cursor {
                    Value::Cons(cell) => {
                        cursor = with_heap(|h| h.cons_cdr(cell));
                        remaining -= 1;
                    }
                    _ => return Ok(false),
                }
            }
            Ok(!matches!(cursor, Value::Cons(_)))
        }
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), *other],
        )),
    }
}

fn sequence_length_greater_than(sequence: &Value, target: i64) -> Result<bool, Flow> {
    match sequence {
        Value::Nil => Ok(0 > target),
        Value::Str(id) => Ok((with_heap(|h| storage_char_len(h.get_string(*id))) as i64) > target),
        Value::Vector(v) => Ok(vector_sequence_length(sequence, *v) > target),
        Value::Cons(_) => {
            if target < 0 {
                return Ok(true);
            }
            if target == i64::MAX {
                return Ok(false);
            }
            let mut remaining = target + 1;
            let mut cursor = *sequence;
            while remaining > 0 {
                match cursor {
                    Value::Cons(cell) => {
                        cursor = with_heap(|h| h.cons_cdr(cell));
                        remaining -= 1;
                    }
                    _ => return Ok(false),
                }
            }
            Ok(true)
        }
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), *other],
        )),
    }
}

pub(crate) fn builtin_length_lt(args: Vec<Value>) -> EvalResult {
    expect_args("length<", &args, 2)?;
    let target = expect_fixnum(&args[1])?;
    Ok(Value::bool(sequence_length_less_than(&args[0], target)?))
}

pub(crate) fn builtin_length_eq(args: Vec<Value>) -> EvalResult {
    expect_args("length=", &args, 2)?;
    let target = expect_fixnum(&args[1])?;
    Ok(Value::bool(sequence_length_equal(&args[0], target)?))
}

pub(crate) fn builtin_length_gt(args: Vec<Value>) -> EvalResult {
    expect_args("length>", &args, 2)?;
    let target = expect_fixnum(&args[1])?;
    Ok(Value::bool(sequence_length_greater_than(&args[0], target)?))
}

pub(crate) fn builtin_nth(args: Vec<Value>) -> EvalResult {
    expect_args("nth", &args, 2)?;
    let n = expect_int(&args[0])?;
    let tail = nthcdr_impl(n, args[1])?;
    match tail {
        Value::Cons(cell) => Ok(with_heap(|h| h.cons_car(cell))),
        Value::Nil => Ok(Value::Nil),
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("listp"), other],
        )),
    }
}

fn nthcdr_impl(n: i64, list: Value) -> EvalResult {
    if n <= 0 {
        return Ok(list);
    }

    let mut cursor = list;
    for _ in 0..(n as usize) {
        match cursor {
            Value::Cons(cell) => {
                cursor = with_heap(|h| h.cons_cdr(cell));
            }
            Value::Nil => return Ok(Value::Nil),
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), list],
                ))
            }
        }
    }
    Ok(cursor)
}

pub(crate) fn builtin_nthcdr(args: Vec<Value>) -> EvalResult {
    expect_args("nthcdr", &args, 2)?;
    let n = expect_int(&args[0])?;
    nthcdr_impl(n, args[1])
}

pub(crate) fn builtin_append(args: Vec<Value>) -> EvalResult {
    fn extend_from_proper_list(out: &mut Vec<Value>, list: &Value) -> Result<(), Flow> {
        let mut cursor = *list;
        loop {
            match cursor {
                Value::Nil => return Ok(()),
                Value::Cons(cell) => {
                    let pair = read_cons(cell);
                    out.push(pair.car);
                    cursor = pair.cdr;
                }
                tail => {
                    return Err(signal(
                        "wrong-type-argument",
                        vec![Value::symbol("listp"), tail],
                    ))
                }
            }
        }
    }

    if args.is_empty() {
        return Ok(Value::Nil);
    }
    if args.len() == 1 {
        return Ok(args[0]);
    }

    // Collect all elements from all lists except the last, then use last as tail
    let mut elements: Vec<Value> = Vec::new();
    for arg in &args[..args.len() - 1] {
        match arg {
            Value::Nil => {}
            Value::Cons(_) => extend_from_proper_list(&mut elements, arg)?,
            Value::Vector(v) => {
                elements.extend(with_heap(|h| h.get_vector(*v).clone()).into_iter())
            }
            Value::Str(id) => {
                let s = with_heap(|h| h.get_string(*id).clone());
                elements.extend(
                    decode_storage_char_codes(&s)
                        .into_iter()
                        .map(|cp| Value::Int(cp as i64)),
                );
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("sequencep"), *arg],
                ))
            }
        }
    }

    let last = &args[args.len() - 1];
    if elements.is_empty() {
        return Ok(*last);
    }

    // Build list with last arg as tail (supports improper lists)
    let tail = *last;
    Ok(elements
        .into_iter()
        .rev()
        .fold(tail, |acc, item| Value::cons(item, acc)))
}

pub(crate) fn builtin_reverse(args: Vec<Value>) -> EvalResult {
    expect_args("reverse", &args, 1)?;
    match &args[0] {
        Value::Nil => Ok(Value::Nil),
        Value::Cons(_) => {
            let items = list_to_vec(&args[0]).ok_or_else(|| {
                signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), args[0]],
                )
            })?;
            let mut reversed = items;
            reversed.reverse();
            Ok(Value::list(reversed))
        }
        Value::Vector(v) => {
            let mut items = with_heap(|h| h.get_vector(*v).clone());
            items.reverse();
            Ok(Value::vector(items))
        }
        Value::Str(id) => {
            let s = with_heap(|h| h.get_string(*id).clone());
            let reversed: String = s.chars().rev().collect();
            Ok(Value::string(reversed))
        }
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), args[0]],
        )),
    }
}

pub(crate) fn builtin_nreverse(args: Vec<Value>) -> EvalResult {
    fn dotted_list_prefix(list: &Value) -> Option<Value> {
        let mut cursor = *list;
        let mut prefix = Vec::new();
        loop {
            match cursor {
                Value::Cons(cell) => {
                    let pair = read_cons(cell);
                    prefix.push(pair.car);
                    cursor = pair.cdr;
                }
                Value::Nil => return None,
                _ => return Some(Value::list(prefix)),
            }
        }
    }

    expect_args("nreverse", &args, 1)?;
    match &args[0] {
        Value::Nil => Ok(Value::Nil),
        Value::Cons(_) => {
            // Match Emacs list semantics: reject dotted lists with proper-prefix payload.
            if let Some(prefix) = dotted_list_prefix(&args[0]) {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), prefix],
                ));
            }

            let mut prev = Value::Nil;
            let mut current = args[0];
            loop {
                match current {
                    Value::Nil => return Ok(prev),
                    Value::Cons(cell) => {
                        let next = with_heap(|h| h.cons_cdr(cell));
                        with_heap_mut(|h| h.set_cdr(cell, prev));
                        prev = Value::Cons(cell);
                        current = next;
                    }
                    _ => unreachable!("proper-list check should reject dotted tails"),
                }
            }
        }
        Value::Vector(v) => {
            with_heap_mut(|h| h.get_vector_mut(*v).reverse());
            Ok(args[0])
        }
        Value::Str(_) => builtin_reverse(args),
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("arrayp"), args[0]],
        )),
    }
}

pub(crate) fn builtin_member(args: Vec<Value>) -> EvalResult {
    expect_args("member", &args, 2)?;
    let target = &args[0];
    let list = args[1];
    let mut cursor = list;
    loop {
        match cursor {
            Value::Nil => return Ok(Value::Nil),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                if equal_value(target, &pair.car, 0) {
                    drop(pair);
                    return Ok(Value::Cons(cell));
                }
                cursor = pair.cdr;
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), list],
                ))
            }
        }
    }
}

pub(crate) fn builtin_memq(args: Vec<Value>) -> EvalResult {
    expect_args("memq", &args, 2)?;
    let target = &args[0];
    let list = args[1];
    let mut cursor = list;
    loop {
        match cursor {
            Value::Nil => return Ok(Value::Nil),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                if eq_value(target, &pair.car) {
                    drop(pair);
                    return Ok(Value::Cons(cell));
                }
                cursor = pair.cdr;
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), list],
                ))
            }
        }
    }
}

pub(crate) fn builtin_memql(args: Vec<Value>) -> EvalResult {
    expect_args("memql", &args, 2)?;
    let target = &args[0];
    let list = args[1];
    let mut cursor = list;
    loop {
        match cursor {
            Value::Nil => return Ok(Value::Nil),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                if eql_value(target, &pair.car) {
                    drop(pair);
                    return Ok(Value::Cons(cell));
                }
                cursor = pair.cdr;
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), list],
                ))
            }
        }
    }
}

pub(crate) fn builtin_assoc(args: Vec<Value>) -> EvalResult {
    expect_args("assoc", &args, 2)?;
    let key = &args[0];
    let list = args[1];
    let mut cursor = list;
    loop {
        match cursor {
            Value::Nil => return Ok(Value::Nil),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                if let Value::Cons(ref entry) = pair.car {
                    let entry_pair = read_cons(*entry);
                    if equal_value(key, &entry_pair.car, 0) {
                        return Ok(pair.car);
                    }
                }
                cursor = pair.cdr;
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), list],
                ))
            }
        }
    }
}

pub(crate) fn builtin_assoc_eval(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_range_args("assoc", &args, 2, 3)?;
    let key = &args[0];
    let list = args[1];
    let test_fn = args.get(2).and_then(|value| {
        if value.is_nil() {
            None
        } else {
            Some(*value)
        }
    });
    // Only need GC protection when a test function is provided.
    if test_fn.is_some() {
        let saved = eval.save_temp_roots();
        eval.push_temp_root(*key);
        eval.push_temp_root(list);
        eval.push_temp_root(test_fn.unwrap());
        let result = builtin_assoc_eval_inner(eval, key, list, &test_fn);
        eval.restore_temp_roots(saved);
        return result;
    }
    builtin_assoc_eval_inner(eval, key, list, &test_fn)
}

fn builtin_assoc_eval_inner(
    eval: &mut super::eval::Evaluator,
    key: &Value,
    list: Value,
    test_fn: &Option<Value>,
) -> EvalResult {
    let mut cursor = list;
    loop {
        match cursor {
            Value::Nil => return Ok(Value::Nil),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                if let Value::Cons(ref entry) = pair.car {
                    let entry_pair = read_cons(*entry);
                    let matches = if let Some(test_fn) = test_fn {
                        eval.apply(*test_fn, vec![*key, entry_pair.car])?
                            .is_truthy()
                    } else {
                        equal_value(key, &entry_pair.car, 0)
                    };
                    if matches {
                        return Ok(pair.car);
                    }
                }
                cursor = pair.cdr;
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), list],
                ))
            }
        }
    }
}

pub(crate) fn builtin_assq(args: Vec<Value>) -> EvalResult {
    expect_args("assq", &args, 2)?;
    let key = &args[0];
    let list = args[1];
    let mut cursor = list;
    loop {
        match cursor {
            Value::Nil => return Ok(Value::Nil),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                if let Value::Cons(ref entry) = pair.car {
                    let entry_pair = read_cons(*entry);
                    if eq_value(key, &entry_pair.car) {
                        return Ok(pair.car);
                    }
                }
                cursor = pair.cdr;
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), list],
                ))
            }
        }
    }
}

pub(crate) fn builtin_assq_delete_all(args: Vec<Value>) -> EvalResult {
    expect_args("assq-delete-all", &args, 2)?;
    let key = args[0];
    delete_from_list_in_place(&args[1], |entry| match entry {
        Value::Cons(cell) => {
            let pair = read_cons(*cell);
            eq_value(&key, &pair.car)
        }
        _ => false,
    })
}

pub(crate) fn builtin_assoc_delete_all(args: Vec<Value>) -> EvalResult {
    expect_args("assoc-delete-all", &args, 2)?;
    let key = args[0];
    delete_from_list_in_place(&args[1], |entry| match entry {
        Value::Cons(cell) => {
            let pair = read_cons(*cell);
            equal_value(&key, &pair.car, 0)
        }
        _ => false,
    })
}

pub(crate) fn builtin_assoc_delete_all_eval(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_range_args("assoc-delete-all", &args, 2, 3)?;
    if args.len() < 3 || args[2].is_nil() {
        return builtin_assoc_delete_all(vec![args[0], args[1]]);
    }

    let key = args[0];
    let test_fn = args[2];
    delete_from_list_in_place_result(&args[1], |entry| match entry {
        Value::Cons(cell) => {
            let pair = read_cons(*cell);
            Ok(eval
                .apply(test_fn, vec![key, pair.car])?
                .is_truthy())
        }
        _ => Ok(false),
    })
}

pub(crate) fn builtin_copy_sequence(args: Vec<Value>) -> EvalResult {
    expect_args("copy-sequence", &args, 1)?;
    match &args[0] {
        Value::Nil => Ok(Value::Nil),
        Value::Cons(_) => {
            let mut items = Vec::new();
            let mut cursor = args[0];
            loop {
                match cursor {
                    Value::Nil => break,
                    Value::Cons(cell) => {
                        let pair = read_cons(cell);
                        items.push(pair.car);
                        cursor = pair.cdr;
                    }
                    tail => {
                        return Err(signal(
                            "wrong-type-argument",
                            vec![Value::symbol("listp"), tail],
                        ))
                    }
                }
            }
            Ok(Value::list(items))
        }
        Value::Str(id) => Ok(Value::string(with_heap(|h| h.get_string(*id).clone()))),
        Value::Vector(v) => Ok(Value::vector(with_heap(|h| h.get_vector(*v).clone()))),
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), *other],
        )),
    }
}


// ===========================================================================
// Extended list operations
// ===========================================================================

pub(crate) fn builtin_last(args: Vec<Value>) -> EvalResult {
    expect_min_args("last", &args, 1)?;
    let n = if args.len() > 1 && !args[1].is_nil() {
        expect_number_or_marker(&args[1])?
    } else {
        NumberOrMarker::Int(1)
    };

    match n {
        NumberOrMarker::Int(n) => {
            if n < 0 {
                return Ok(Value::Nil);
            }

            let mut lag = args[0];
            let mut lead = args[0];
            for _ in 0..(n as usize) {
                match lead {
                    Value::Cons(cell) => {
                        lead = with_heap(|h| h.cons_cdr(cell));
                    }
                    _ => return Ok(lag),
                }
            }

            loop {
                match lead {
                    Value::Cons(cell) => {
                        lead = with_heap(|h| h.cons_cdr(cell));
                        lag = match lag {
                            Value::Cons(lag_cell) => with_heap(|h| h.cons_cdr(lag_cell)),
                            _ => unreachable!("lag should be a cons while lead is a cons"),
                        };
                    }
                    _ => return Ok(lag),
                }
            }
        }
        NumberOrMarker::Float(n) => {
            if n < 0.0 {
                return Ok(Value::Nil);
            }

            if let Some(len) = list_length(&args[0]) {
                let remaining = len as f64 - n;
                if remaining > 0.0 {
                    return Err(signal(
                        "wrong-type-argument",
                        vec![Value::symbol("integerp"), Value::Float(remaining)],
                    ));
                }
            }
            Ok(args[0])
        }
    }
}

pub(crate) fn builtin_butlast(args: Vec<Value>) -> EvalResult {
    expect_min_args("butlast", &args, 1)?;
    let n = if args.len() > 1 && !args[1].is_nil() {
        expect_number_or_marker(&args[1])?
    } else {
        NumberOrMarker::Int(1)
    };

    let n_non_positive = match n {
        NumberOrMarker::Int(v) => v <= 0,
        NumberOrMarker::Float(v) => v <= 0.0,
    };
    if n_non_positive {
        return Ok(args[0]);
    }

    match &args[0] {
        Value::Nil | Value::Cons(_) => {}
        Value::Vector(_) | Value::Str(_) => {
            return Err(signal(
                "wrong-type-argument",
                vec![Value::symbol("listp"), args[0]],
            ))
        }
        _ => {
            return Err(signal(
                "wrong-type-argument",
                vec![Value::symbol("sequencep"), args[0]],
            ))
        }
    }

    let mut items = Vec::new();
    let mut cursor = args[0];
    loop {
        match cursor {
            Value::Nil => break,
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                items.push(pair.car);
                cursor = pair.cdr;
            }
            tail => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), tail],
                ))
            }
        }
    }

    match n {
        NumberOrMarker::Int(v) => {
            let keep = items.len().saturating_sub(v as usize);
            Ok(Value::list(items[..keep].to_vec()))
        }
        NumberOrMarker::Float(v) => Err(signal(
            "wrong-type-argument",
            vec![
                Value::symbol("integerp"),
                Value::Float(items.len() as f64 - v),
            ],
        )),
    }
}

fn delete_from_list_in_place_result<F>(seq: &Value, mut should_delete: F) -> Result<Value, Flow>
where
    F: FnMut(&Value) -> Result<bool, Flow>,
{
    let mut probe = *seq;
    loop {
        match probe {
            Value::Nil => break,
            Value::Cons(cell) => {
                probe = with_heap(|h| h.cons_cdr(cell));
            }
            tail => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), tail],
                ))
            }
        }
    }

    let mut head = *seq;
    loop {
        match head {
            Value::Nil => return Ok(Value::Nil),
            Value::Cons(cell) => {
                let remove = {
                    let pair = read_cons(cell);
                    should_delete(&pair.car)?
                };
                if remove {
                    head = with_heap(|h| h.cons_cdr(cell));
                } else {
                    break;
                }
            }
            _ => unreachable!("list shape checked above"),
        }
    }

    let mut prev = match &head {
        Value::Cons(cell) => *cell,
        Value::Nil => return Ok(Value::Nil),
        _ => unreachable!("head must be list"),
    };

    loop {
        let next = with_heap(|h| h.cons_cdr(prev));
        match next {
            Value::Nil => break,
            Value::Cons(next_cell) => {
                let remove = {
                    let pair = read_cons(next_cell);
                    should_delete(&pair.car)?
                };
                if remove {
                    let after = with_heap(|h| h.cons_cdr(next_cell));
                    with_heap_mut(|h| h.set_cdr(prev, after));
                } else {
                    prev = next_cell;
                }
            }
            _ => unreachable!("list shape checked above"),
        }
    }

    Ok(head)
}

fn delete_from_list_in_place<F>(seq: &Value, should_delete: F) -> Result<Value, Flow>
where
    F: Fn(&Value) -> bool,
{
    delete_from_list_in_place_result(seq, |value| Ok(should_delete(value)))
}

pub(crate) fn builtin_delete(args: Vec<Value>) -> EvalResult {
    expect_args("delete", &args, 2)?;
    let elt = &args[0];
    match &args[1] {
        Value::Nil => Ok(Value::Nil),
        Value::Cons(_) => delete_from_list_in_place(&args[1], |item| equal_value(elt, item, 0)),
        Value::Vector(v) => {
            let items = with_heap(|h| h.get_vector(*v).clone());
            let mut changed = false;
            let mut kept = Vec::with_capacity(items.len());
            for item in items.iter() {
                if equal_value(elt, item, 0) {
                    changed = true;
                } else {
                    kept.push(*item);
                }
            }
            if changed {
                Ok(Value::vector(kept))
            } else {
                Ok(args[1])
            }
        }
        Value::Str(id) => {
            let mut changed = false;
            let mut kept = Vec::new();
            let s = with_heap(|h| h.get_string(*id).clone());
            for cp in decode_storage_char_codes(&s) {
                let ch = Value::Int(cp as i64);
                if equal_value(elt, &ch, 0) {
                    changed = true;
                } else {
                    kept.push(ch);
                }
            }
            if !changed {
                return Ok(args[1]);
            }
            builtin_concat(vec![Value::list(kept)])
        }
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), *other],
        )),
    }
}

pub(crate) fn builtin_delq(args: Vec<Value>) -> EvalResult {
    expect_args("delq", &args, 2)?;
    let elt = &args[0];
    match &args[1] {
        Value::Nil => Ok(Value::Nil),
        Value::Cons(_) => delete_from_list_in_place(&args[1], |item| eq_value(elt, item)),
        _ => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("listp"), args[1]],
        )),
    }
}

pub(crate) fn builtin_elt(args: Vec<Value>) -> EvalResult {
    expect_args("elt", &args, 2)?;
    match &args[0] {
        Value::Cons(_) | Value::Nil => builtin_nth(vec![args[1], args[0]]),
        Value::Vector(_) | Value::Str(_) => builtin_aref(vec![args[0], args[1]]),
        other => Err(signal(
            "wrong-type-argument",
            vec![Value::symbol("sequencep"), *other],
        )),
    }
}

pub(crate) fn builtin_nconc(args: Vec<Value>) -> EvalResult {
    if args.is_empty() {
        return Ok(Value::Nil);
    }

    let mut result_head: Option<Value> = None;
    let mut last_cons: Option<Value> = None;

    for (index, arg) in args.iter().enumerate() {
        let is_last = index + 1 == args.len();

        if is_last {
            if let Some(Value::Cons(cell)) = &last_cons {
                with_heap_mut(|h| h.set_cdr(*cell, *arg));
                return Ok(result_head.unwrap_or(*arg));
            }
            return Ok(*arg);
        }

        match arg {
            Value::Nil => continue,
            Value::Cons(head) => {
                if result_head.is_none() {
                    result_head = Some(*arg);
                }
                if let Some(Value::Cons(prev)) = &last_cons {
                    with_heap_mut(|h| h.set_cdr(*prev, *arg));
                }

                let mut tail = *head;
                loop {
                    let next = with_heap(|h| h.cons_cdr(tail));
                    match next {
                        Value::Cons(next_cell) => tail = next_cell,
                        _ => {
                            last_cons = Some(Value::Cons(tail));
                            break;
                        }
                    }
                }
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("consp"), *arg],
                ))
            }
        }
    }

    Ok(result_head.unwrap_or(Value::Nil))
}

pub(crate) fn builtin_alist_get(args: Vec<Value>) -> EvalResult {
    expect_min_args("alist-get", &args, 2)?;
    let key = &args[0];
    let default = args.get(2).cloned().unwrap_or(Value::Nil);
    let _remove = args.get(3); // not used
    let use_equal = args.get(4).is_some_and(|v| v.is_truthy());

    let mut cursor = args[1];
    loop {
        match cursor {
            Value::Nil => return Ok(default),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                let entry = pair.car;
                cursor = pair.cdr;
                drop(pair);

                if let Value::Cons(entry_cell) = entry {
                    let entry_pair = read_cons(entry_cell);
                    let matches = if use_equal {
                        equal_value(key, &entry_pair.car, 0)
                    } else {
                        eq_value(key, &entry_pair.car)
                    };
                    if matches {
                        return Ok(entry_pair.cdr);
                    }
                }
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), args[1]],
                ))
            }
        }
    }
}

pub(crate) fn builtin_alist_get_eval(
    eval: &mut super::eval::Evaluator,
    args: Vec<Value>,
) -> EvalResult {
    expect_min_args("alist-get", &args, 2)?;
    let key = &args[0];
    let default = args.get(2).cloned().unwrap_or(Value::Nil);
    let _remove = args.get(3); // not used
    let test_fn = args.get(4).and_then(|value| {
        if value.is_nil() {
            None
        } else {
            Some(*value)
        }
    });

    let mut cursor = args[1];
    loop {
        match cursor {
            Value::Nil => return Ok(default),
            Value::Cons(cell) => {
                let pair = read_cons(cell);
                let entry = pair.car;
                cursor = pair.cdr;
                drop(pair);

                if let Value::Cons(entry_cell) = entry {
                    let entry_pair = read_cons(entry_cell);
                    let matches = if let Some(test_fn) = &test_fn {
                        eval.apply(*test_fn, vec![*key, entry_pair.car])?
                            .is_truthy()
                    } else {
                        equal_value(key, &entry_pair.car, 0)
                    };
                    if matches {
                        return Ok(entry_pair.cdr);
                    }
                }
            }
            _ => {
                return Err(signal(
                    "wrong-type-argument",
                    vec![Value::symbol("listp"), args[1]],
                ))
            }
        }
    }
}

pub(crate) fn builtin_number_sequence(args: Vec<Value>) -> EvalResult {
    expect_min_args("number-sequence", &args, 1)?;
    let from = expect_int(&args[0])?;
    let to = if args.len() > 1 {
        match &args[1] {
            Value::Nil => return Ok(Value::list(vec![Value::Int(from)])),
            v => expect_int(v)?,
        }
    } else {
        return Ok(Value::list(vec![Value::Int(from)]));
    };
    let step = if args.len() > 2 {
        expect_int(&args[2])?
    } else if from <= to {
        1
    } else {
        -1
    };

    if step == 0 {
        return Err(signal("args-out-of-range", vec![Value::Int(0)]));
    }

    let mut result = Vec::new();
    let mut i = from;
    if step > 0 {
        while i <= to {
            result.push(Value::Int(i));
            i += step;
        }
    } else {
        while i >= to {
            result.push(Value::Int(i));
            i += step;
        }
    }
    Ok(Value::list(result))
}

// ===========================================================================
