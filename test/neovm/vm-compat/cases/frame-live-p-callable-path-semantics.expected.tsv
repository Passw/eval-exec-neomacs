1	(list (fboundp 'frame-live-p) (subr-arity (symbol-function 'frame-live-p)))	OK (t (1 . 1))
2	(let ((f (selected-frame))) (list (not (null (funcall #'frame-live-p f))) (not (null (apply #'frame-live-p (list f)))) (let ((fn (indirect-function 'frame-live-p))) (not (null (funcall fn f)))) (eq (funcall #'frame-live-p f) (frame-live-p f))))	OK (t t t t)
3	(list (condition-case err (funcall #'frame-live-p nil) (error (car err))) (condition-case err (apply #'frame-live-p '(nil)) (error (car err))) (condition-case err (funcall (indirect-function 'frame-live-p) nil) (error (car err))))	OK (nil nil nil)
4	(list (condition-case err (funcall #'frame-live-p 999999) (error (car err))) (condition-case err (apply #'frame-live-p '(999999)) (error (car err))) (condition-case err (funcall (indirect-function 'frame-live-p) 999999) (error (car err))) (condition-case err (funcall #'frame-live-p "x") (error (car err))) (condition-case err (apply #'frame-live-p '(\"x\")) (error (car err))))	OK (nil nil nil nil nil)
5	(list (condition-case err (funcall #'frame-live-p) (error (car err))) (condition-case err (apply #'frame-live-p 'nil) (error (car err))) (condition-case err (funcall #'frame-live-p nil nil) (error (car err))) (condition-case err (apply #'frame-live-p '(nil nil)) (error (car err))))	OK (wrong-number-of-arguments wrong-number-of-arguments wrong-number-of-arguments wrong-number-of-arguments)
