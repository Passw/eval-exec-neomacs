(stringp (documentation 'car))
(stringp (documentation 'cdr))
(stringp (documentation 'if))
(condition-case err (documentation 'vm-doc-missing) (error (car err)))
(progn (fset 'vm-doc-lambda2 (lambda (x) "ldoc" x)) (documentation 'vm-doc-lambda2))
(progn (put 'vm-doc-prop-only2 'function-documentation "pdoc") (documentation 'vm-doc-prop-only2))
(progn (put 'vm-doc-prop-only2 'function-documentation '(identity "pdoc2")) (documentation 'vm-doc-prop-only2))
(progn (put 'vm-doc-prop-only2 'function-documentation 't) (documentation 'vm-doc-prop-only2))
(progn (put 'vm-doc-prop-only2 'function-documentation [1 2]) (documentation 'vm-doc-prop-only2))
(progn (put 'vm-doc-prop-only2 'function-documentation 1.5) (documentation 'vm-doc-prop-only2))
(progn (put 'vm-doc-prop-only2 'function-documentation 9) (documentation 'vm-doc-prop-only2))
(progn (put 'vm-doc-prop-only2 'function-documentation '(1 2)) (condition-case err (documentation 'vm-doc-prop-only2) (error err)))
(progn (put 'vm-doc-prop-only2 'function-documentation 'vm-doc-prop-unbound) (condition-case err (documentation 'vm-doc-prop-only2) (error err)))
(progn (put 'vm-doc-prop-only2 'function-documentation '(progn "pdoc3")) (documentation 'vm-doc-prop-only2 t))
(progn (fset 'vm-doc-alias-target (lambda nil "aliasdoc" nil)) (defalias 'vm-doc-alias 'vm-doc-alias-target) (stringp (documentation 'vm-doc-alias)))
(progn (fset 'vm-doc-alias-builtin 'car) (stringp (documentation 'vm-doc-alias-builtin)))
(condition-case err (documentation 1) (error (car err)))
(stringp (documentation 'car t))
(condition-case err (documentation 'car nil nil) (error (car err)))
(stringp (documentation '(lambda (x) "d" x)))
(documentation '(lambda (x) "d" x))
(documentation '(lambda (x) x))
(documentation [1 2])
(documentation "abc")
(condition-case err (documentation '(macro (x) "md" x)) (error err))
(condition-case err (documentation '(macro)) (error err))
(let ((s (documentation 'car)))
  (list
   (not (null (string-match-p "^Return the car of LIST\\." s)))
   (null (string-match-p "^Built-in function\\.$" s))))
(let ((s (documentation 'cdr)))
  (list
   (not (null (string-match-p "^Return the cdr of LIST\\." s)))
   (null (string-match-p "^Built-in function\\.$" s))))
(let ((s (documentation 'if)))
  (list
   (not (null (string-match-p "^If COND yields non-nil, do THEN, else do ELSE\\.\\.\\." s)))
   (null (string-match-p "^Built-in function\\.$" s))))
(progn
  (fset 'vm-doc-alias-builtin 'car)
  (let ((s (documentation 'vm-doc-alias-builtin)))
    (list
     (not (null (string-match-p "^Return the car of LIST\\." s)))
     (null (string-match-p "^Built-in function\\.$" s)))))
(let ((probes
       '((cons "Create a new cons, give it CAR and CDR as components, and return it.")
         (list "Return a newly created list with specified arguments as elements.")
         (eq "Return t if the two args are the same Lisp object.")
         (equal "Return t if two Lisp objects have similar structure and contents.")
         (length "Return the length of vector, list or string SEQUENCE.")
         (append "Concatenate all the arguments and make the result a list.")
         (mapcar "Apply FUNCTION to each element of SEQUENCE, and make a list of the results.")
         (assoc "Return non-nil if KEY is equal to the car of an element of ALIST.")
         (member "Return non-nil if ELT is an element of LIST.  Comparison done with ‘equal’.")
         (symbol-name "Return SYMBOL’s name, a string."))))
  (mapcar
   (lambda (entry)
     (let* ((sym (car entry))
            (prefix (cadr entry))
            (doc (documentation sym)))
       (list
        sym
        (stringp doc)
        (not (null (string-match-p (concat "^" (regexp-quote prefix)) doc)))
        (null (string-match-p "^Built-in function\\.$" doc)))))
   probes))
