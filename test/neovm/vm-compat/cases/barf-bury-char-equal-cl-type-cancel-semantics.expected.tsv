1	(fboundp 'barf-if-buffer-read-only)	OK t
2	(subrp (symbol-function 'barf-if-buffer-read-only))	OK t
3	(subr-arity (symbol-function 'barf-if-buffer-read-only))	OK (0 . 1)
4	(fboundp 'bury-buffer-internal)	OK t
5	(subrp (symbol-function 'bury-buffer-internal))	OK t
6	(subr-arity (symbol-function 'bury-buffer-internal))	OK (1 . 1)
7	(fboundp 'char-equal)	OK t
8	(subrp (symbol-function 'char-equal))	OK t
9	(subr-arity (symbol-function 'char-equal))	OK (2 . 2)
10	(fboundp 'cl-type-of)	OK t
11	(subrp (symbol-function 'cl-type-of))	OK t
12	(subr-arity (symbol-function 'cl-type-of))	OK (1 . 1)
13	(fboundp 'cancel-kbd-macro-events)	OK t
14	(subrp (symbol-function 'cancel-kbd-macro-events))	OK t
15	(subr-arity (symbol-function 'cancel-kbd-macro-events))	OK (0 . 0)
16	(list 'char-equal-default (char-equal 97 65))	OK (char-equal-default t)
17	(let ((case-fold-search nil)) (list 'char-equal-case-sensitive (char-equal 97 65)))	OK (char-equal-case-sensitive nil)
18	(let ((case-fold-search t)) (list 'char-equal-case-fold (char-equal 97 65)))	OK (char-equal-case-fold t)
19	(condition-case err (char-equal 1 "a") (wrong-type-argument (list 'char-equal-type (car err) (cdr err))))	OK (char-equal-type wrong-type-argument (characterp "a"))
20	(list 'cl-type-of (cl-type-of nil) (cl-type-of t) (cl-type-of 1) (cl-type-of 1.5) (cl-type-of "x") (cl-type-of 'foo) (cl-type-of '(1 . 2)) (cl-type-of [1 2]) (cl-type-of (make-hash-table)) (cl-type-of (symbol-function 'car)) (cl-type-of (lambda (x) x)))	OK (cl-type-of null boolean fixnum float string symbol cons vector hash-table primitive-function interpreted-function)
21	(with-temp-buffer (bury-buffer-internal (current-buffer)))	OK nil
22	(condition-case err (bury-buffer-internal 'x) (wrong-type-argument (list 'bury-buffer-internal-type (car err) (cdr err))))	OK (bury-buffer-internal-type wrong-type-argument (bufferp x))
23	(condition-case err (bury-buffer-internal) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
24	(with-temp-buffer (setq buffer-read-only nil) (barf-if-buffer-read-only))	OK nil
25	(with-temp-buffer (setq buffer-read-only t) (condition-case err (barf-if-buffer-read-only) (buffer-read-only (car err))))	OK buffer-read-only
26	(with-temp-buffer (setq buffer-read-only t) (condition-case err (barf-if-buffer-read-only 0) (args-out-of-range (list 'barf-if-buffer-read-only-range (car err) (cdr err)))))	OK (barf-if-buffer-read-only-range args-out-of-range (0 0))
27	(with-temp-buffer (setq buffer-read-only t) (condition-case err (barf-if-buffer-read-only "x") (wrong-type-argument (list 'barf-if-buffer-read-only-type (car err) (cdr err)))))	OK (barf-if-buffer-read-only-type wrong-type-argument (fixnump "x"))
28	(condition-case err (barf-if-buffer-read-only nil nil) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
29	(cancel-kbd-macro-events)	OK nil
30	(let ((unread-command-events '(97 98))) (list (cancel-kbd-macro-events) unread-command-events))	OK (nil (97 98))
31	(condition-case err (cancel-kbd-macro-events nil) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
