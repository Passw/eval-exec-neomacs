1	(list (fboundp 'window-list-1) (subr-arity (symbol-function 'window-list-1)))	OK (t (0 . 3))
2	(let* ((fn (indirect-function 'window-list-1)) (a (window-list-1)) (b (funcall #'window-list-1 nil nil)) (c (apply #'window-list-1 '(nil nil))) (d (funcall fn nil nil))) (list (listp a) (consp a) (equal a b) (equal b c) (equal b d) (null (memq nil (mapcar #'windowp b)))))	OK (t t t t t t)
3	(let* ((w (selected-window)) (fn (indirect-function 'window-list-1)) (a (funcall #'window-list-1 w nil)) (b (apply #'window-list-1 (list w nil))) (c (funcall fn w nil))) (list (equal a b) (equal a c) (null (memq nil (mapcar #'windowp a)))))	OK (t t t)
4	(let ((w (split-window))) (delete-window w) (list (condition-case err (window-list-1 w nil) (error (car err))) (condition-case err (funcall #'window-list-1 w nil) (error (car err))) (condition-case err (apply #'window-list-1 (list w nil)) (error (car err)))))	OK (wrong-type-argument wrong-type-argument wrong-type-argument)
5	(let ((fn (indirect-function 'window-list-1))) (list (condition-case err (window-list-1 'foo nil) (error (car err))) (condition-case err (funcall #'window-list-1 'foo nil) (error (car err))) (condition-case err (apply #'window-list-1 '(foo nil)) (error (car err))) (condition-case err (funcall fn 'foo nil) (error (car err)))))	OK (wrong-type-argument wrong-type-argument wrong-type-argument wrong-type-argument)
6	(list (and (listp (window-list-1 nil nil t)) (consp (window-list-1 nil nil t))) (and (listp (window-list-1 nil nil 'visible)) (consp (window-list-1 nil nil 'visible))) (and (listp (window-list-1 nil nil 0)) (consp (window-list-1 nil nil 0))) (and (listp (window-list-1 nil nil :bad)) (consp (window-list-1 nil nil :bad))))	OK (t t t t)
