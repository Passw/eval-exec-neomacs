; Basic pcase dispatch and predicate matching
(pcase '(1 2) ((pred listp) 'yes) (_ 'no))
(pcase '(a . b) ('(a . b) 'ok) (_ 'bad))
(pcase 3 ((pred numberp) 'num) (_ 'other))

; pcase-let / pcase-let* bindings
(pcase-let (((pred numberp) 42)) (+ 1 2))
(pcase-let (((and x (pred numberp)) 9)) x)
(pcase-let* (((pred numberp) 5) ((pred numberp) 6)) (+ 7 8))
(condition-case err (pcase [1 2 3] ([a b c] (+ a b c))) (error err))
(condition-case err (pcase-let (([a b] [1 2])) (list a b)) (error err))
(condition-case err (pcase-let* (([a b] [1 2])) (list a b)) (error err))
(condition-case err (pcase [1 2 3] (`[,a ,b ,c] (+ a b c))) (error err))
(condition-case err (pcase 1 ((quote) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((quote 1 2 3) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((pred) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((pred integerp 2) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((guard) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((guard t 2) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((app) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((app car) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((app car x y) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((let) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((let x) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((let x 2 3) x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((foo bar) 'x) (_ 'y)) (error err))
(condition-case err (pcase-let (((foo bar) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((foo bar) 1)) 'ok) (error err))
(condition-case err (pcase 1 (((1 2) 3) 'x) (_ 'y)) (error err))
(condition-case err (pcase-let ((((1 2) 3) 1)) 'ok) (error err))
(condition-case err (pcase-let* ((((1 2) 3) 1)) 'ok) (error err))

; dotted-list pattern head behavior
(condition-case err (pcase '(1 . 2) ((a . b) (list a b)) (_ 'no)) (error err))
(condition-case err (pcase-let (((a . b) '(1 . 2))) (list a b)) (error err))
(condition-case err (pcase-let* (((a . b) '(1 . 2))) (list a b)) (error err))

; (or) requires at least two alternatives
(condition-case err (pcase 1 ((or) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((or 1) 'x) (_ 'y)) (error err))

; dotted-list patterns with non-symbol heads
(condition-case err (pcase '(1 . 2) (((1 2) . 3) 'x) (_ 'y)) (error err))
(condition-case err (pcase-let ((((1 2) . 3) '(1 . 2))) 'ok) (error err))
(condition-case err (pcase-let* ((((1 2) . 3) '(1 . 2))) 'ok) (error err))

; (and) empty/singleton behavior
(condition-case err (pcase 1 ((and) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((and 1) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((and 1 2) 'x) (_ 'y)) (error err))

; pred/or argument edge behavior
(condition-case err (pcase 1 ((pred integerp 2 3) 'x) (_ 'y)) (error err))
(condition-case err (pcase 1 ((or 1 2) 'x) (_ 'y)) (error err))
(condition-case err (pcase 3 ((or 1 2) 'x) (_ 'y)) (error err))

; pcase-let/pcase-dolist arity propagation and empty/singleton behavior
(condition-case err (pcase-let (((or) 1)) 'ok) (error err))
(condition-case err (pcase-let (((or 1) 1)) 'ok) (error err))
(condition-case err (pcase-let (((or 1 2) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((or) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((or 1) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((or 1 2) 1)) 'ok) (error err))
(condition-case err (pcase-let (((and) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((and) 1)) 'ok) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((or) '(1 2)) (push 1 acc)) (nreverse acc)) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((or 1) '(1 2)) (push 1 acc)) (nreverse acc)) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((or 1 2) '(1 2 3)) (push 1 acc)) (nreverse acc)) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((and) '(1 2)) (push 1 acc)) (nreverse acc)) (error err))

; pred/guard behavior in pcase-let and pcase-dolist
(condition-case err (pcase-let (((guard) 1)) 'ok) (error err))
(condition-case err (pcase-let (((guard t 2) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((guard) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((guard t 2) 1)) 'ok) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((guard) '(1 2)) (push 1 acc)) (nreverse acc)) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((guard t 2) '(1 2)) (push 1 acc)) (nreverse acc)) (error err))
(condition-case err (pcase-let (((pred) 1)) 'ok) (error err))
(condition-case err (pcase-let (((pred integerp 2 3) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((pred) 1)) 'ok) (error err))
(condition-case err (pcase-let* (((pred integerp 2 3) 1)) 'ok) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((pred) '(1 2)) (push 1 acc)) (nreverse acc)) (error err))
(condition-case err (let ((acc nil)) (pcase-dolist ((pred integerp 2 3) '(1 2)) (push 1 acc)) (nreverse acc)) (error err))

; non-list pcase-let/pcase-let* binding entries
(condition-case err (pcase-let ((x 1) y) y) (error err))
(condition-case err (pcase-let (((app car x y) '(1 2)) x)) (error err))
(condition-case err (pcase-let* (x) x) (error err))
(condition-case err (pcase-let* ((x 1) y) y) (error err))

; non-list pcase-let/pcase-let* bindings forms
(condition-case err (pcase-let 1 'ok) (error err))
(condition-case err (pcase-let* 1 'ok) (error err))
(condition-case err (pcase-let t 'ok) (error err))
(condition-case err (pcase-let* t 'ok) (error err))
(condition-case err (pcase-let nil 'ok) (error err))
(condition-case err (pcase-let* nil 'ok) (error err))
