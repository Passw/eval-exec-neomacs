; Overflow-arity checks for finite-arity builtins that previously accepted extras.
(condition-case err
    (progn (subst-char-in-string ?a ?b "a" nil nil) 'ok)
  (error (car err)))

(condition-case err
    (progn (assoc-default 'a '((a . 1)) nil nil nil) 'ok)
  (error (car err)))

(with-temp-buffer
  (condition-case err
      (progn (copy-to-register ?a (point-min) (point-max) nil nil nil) 'ok)
    (error (car err))))

(with-temp-buffer
  (condition-case err
      (progn (insert-register ?a nil nil) 'ok)
    (error (car err))))

(let ((kill-ring nil)
      (kill-ring-yank-pointer nil))
  (condition-case err
      (progn (kill-new "x" nil nil) 'ok)
    (error (car err))))

(let ((kill-ring '("x"))
      (kill-ring-yank-pointer '("x")))
  (condition-case err
      (progn (current-kill 0 nil nil) 'ok)
    (error (car err))))

(with-temp-buffer
  (insert "abc")
  (condition-case err
      (progn (kill-region (point-min) (point-max) nil nil) 'ok)
    (error (car err))))

(with-temp-buffer
  (insert "abc")
  (condition-case err
      (progn (kill-ring-save (point-min) (point-max) nil nil) 'ok)
    (error (car err))))

(with-temp-buffer
  (insert "word")
  (goto-char (point-min))
  (condition-case err
      (progn (thing-at-point 'word nil nil) 'ok)
    (error (car err))))

(let ((fn (lambda (&rest _) nil)))
  (unwind-protect
      (condition-case err
          (progn (advice-add 'car :before fn nil nil) 'ok)
        (error (car err)))
    (ignore-errors (advice-remove 'car fn))))
