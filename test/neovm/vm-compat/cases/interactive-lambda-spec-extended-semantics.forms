; Extended interactive string-code behavior for lambda command designators.

; "d" reads point as a 1-based character position.
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (call-interactively (lambda (pt) (interactive "d") pt)))
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (command-execute (lambda (pt) (interactive "d") pt)))

; "m" reads mark as a 1-based character position, or signals when missing.
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (set-mark 2)
  (call-interactively (lambda (mk) (interactive "m") mk)))
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (condition-case err
      (call-interactively (lambda (mk) (interactive "m") mk))
    (error err)))

; "i" inserts a nil argument.
(call-interactively (lambda (ignored) (interactive "i") ignored))
(command-execute (lambda (ignored) (interactive "i") ignored))

; "c", "k", and "K" read character/key events from unread queue state.
(let ((unread-command-events (list 97)))
  (call-interactively (lambda (ch) (interactive "cChar: ") ch)))
(let ((unread-command-events (list 97)))
  (command-execute (lambda (ch) (interactive "cChar: ") ch)))
(let ((unread-command-events (list 97)))
  (call-interactively (lambda (keys) (interactive "kKeys: ") keys)))
(let ((unread-command-events (list 97)))
  (command-execute (lambda (keys) (interactive "kKeys: ") keys)))
(let ((unread-command-events (list 97)))
  (call-interactively (lambda (keys) (interactive "KKeys: ") keys)))
(let ((unread-command-events (list 97)))
  (command-execute (lambda (keys) (interactive "KKeys: ") keys)))

; Minibuffer-backed prompt codes currently signal EOF in batch mode.
(condition-case err
    (call-interactively (lambda (x) (interactive "aFunction: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "bBuffer: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "BBuffer: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "CCommand: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "DDirectory: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "fFind file: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "FFind file: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "vVariable: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "bBuffer: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "fFind file: ") x))
  (error err))

; "N" uses prefix when present, otherwise reads a number (EOF in batch).
(let ((current-prefix-arg '(4))
      (prefix-arg nil))
  (call-interactively (lambda (n) (interactive "NNumber: ") n)))
(let ((current-prefix-arg nil)
      (prefix-arg '(5)))
  (command-execute (lambda (n) (interactive "NNumber: ") n)))
(let ((current-prefix-arg nil)
      (prefix-arg nil))
  (condition-case err
      (call-interactively (lambda (n) (interactive "NNumber: ") n))
    (error err)))
(let ((current-prefix-arg nil)
      (prefix-arg nil))
  (condition-case err
      (command-execute (lambda (n) (interactive "NNumber: ") n))
    (error err)))

; "M", "S", "x", "X", and "z" prompt from stdin in batch.
(condition-case err
    (call-interactively (lambda (s) (interactive "MString: ") s))
  (error err))
(condition-case err
    (call-interactively (lambda (s) (interactive "SSymbol: ") s))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "xExpr: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "XExpr: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (c) (interactive "zCoding: ") c))
  (error err))
(condition-case err
    (command-execute (lambda (s) (interactive "MString: ") s))
  (error err))
(condition-case err
    (command-execute (lambda (s) (interactive "SSymbol: ") s))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "xExpr: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "XExpr: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (c) (interactive "zCoding: ") c))
  (error err))

; "Z" optional coding-system path returns nil and preserves unread events in batch.
(let ((unread-command-events (list 97)))
  (list
   (call-interactively (lambda (c) (interactive "ZCoding: ") c))
   unread-command-events))
(let ((unread-command-events (list 97)))
  (list
   (command-execute (lambda (c) (interactive "ZCoding: ") c))
   unread-command-events))

; "G" file prompt variant currently signals EOF in batch.
(condition-case err
    (call-interactively (lambda (x) (interactive "GFind file: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "GFind file: ") x))
  (error err))

; "U" currently yields nil in batch and leaves unread queue unchanged.
(let ((unread-command-events (list 97)))
  (list
   (call-interactively (lambda (x) (interactive "U") x))
   unread-command-events))
(let ((unread-command-events (list 97)))
  (list
   (command-execute (lambda (x) (interactive "U") x))
   unread-command-events))

; "e" errors when no event-with-parameters context is available and preserves queue.
(let ((unread-command-events (list 97)))
  (condition-case err
      (call-interactively (lambda (x) (interactive "e") x))
    (error (list err unread-command-events))))
(let ((unread-command-events (list 97)))
  (condition-case err
      (command-execute (lambda (x) (interactive "e") x))
    (error (list err unread-command-events))))

; "e" can read event objects from explicit KEYS vectors.
(let ((evt (list 'mouse-1 (list (list (selected-window) (point) '(0 . 0) 0))))
      (r nil))
  (setq r (call-interactively (lambda (x) (interactive "e") x) nil (vector evt)))
  (and (consp r) (eq (car r) 'mouse-1)))
(let ((evt (list 'mouse-1 (list (list (selected-window) (point) '(0 . 0) 0))))
      (r nil))
  (setq r (command-execute (lambda (x) (interactive "e") x) nil (vector evt)))
  (and (consp r) (eq (car r) 'mouse-1)))
(let ((evt (list 'mouse-1 (list (list (selected-window) (point) '(0 . 0) 0))))
      (r nil))
  (setq r (call-interactively (lambda (x) (interactive "e") x) nil (vector 97 evt)))
  (and (consp r) (eq (car r) 'mouse-1)))
(equal
 (call-interactively (lambda (x) (interactive "e") x) nil (vector '(mouse-1)))
 '(mouse-1))
(condition-case err
    (call-interactively (lambda (x) (interactive "e") x) nil [mouse-1])
  (error (car err)))
(condition-case err
    (command-execute (lambda (x) (interactive "e") x) nil [mouse-1])
  (error (car err)))
(condition-case err
    (call-interactively (lambda (x) (interactive "e") x) nil (vector [mouse-1]))
  (error (car err)))

; Prefix flags on first line: "*", "^", "@" (including ordered combinations).
(with-temp-buffer
  (let ((buffer-read-only nil))
    (call-interactively (lambda () (interactive "*") 'ok))))
(with-temp-buffer
  (let ((buffer-read-only t))
    (condition-case err
        (call-interactively (lambda () (interactive "*") 'ok))
      (error (car err)))))
(with-temp-buffer
  (let ((buffer-read-only t)
        (inhibit-read-only t))
    (call-interactively (lambda () (interactive "*") 'ok))))

; "^" seeds mark/mark-active only when shift selection is active.
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (setq mark-active nil)
  (let ((this-command-keys-shift-translated t)
        (shift-select-mode t))
    (list
     (call-interactively (lambda (pt) (interactive "^d") pt))
     mark-active
     (mark t))))
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (setq mark-active nil)
  (let ((this-command-keys-shift-translated t)
        (shift-select-mode t))
    (list
     (command-execute (lambda (pt) (interactive "^d") pt))
     mark-active
     (mark t))))
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (set-mark 1)
  (setq mark-active nil)
  (let ((this-command-keys-shift-translated nil)
        (shift-select-mode t))
    (list
     (call-interactively (lambda (pt) (interactive "^d") pt))
     mark-active
     (mark t))))

; "@" is currently a no-op without mouse event context.
(with-temp-buffer
  (insert "ab")
  (goto-char 2)
  (call-interactively (lambda (pt) (interactive "@d") pt)))
(with-temp-buffer
  (insert "ab")
  (goto-char 2)
  (command-execute (lambda (pt) (interactive "@d") pt)))

; Flag order matters ("*^" vs "^*").
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (setq buffer-read-only t)
  (setq mark-active nil)
  (let ((this-command-keys-shift-translated t)
        (shift-select-mode t))
    (condition-case err
        (progn
          (call-interactively (lambda (x) (interactive "*^d") x))
          (list 'ok mark-active (mark t)))
      (error (list (car err) mark-active (mark t))))))
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (setq buffer-read-only t)
  (setq mark-active nil)
  (let ((this-command-keys-shift-translated t)
        (shift-select-mode t))
    (condition-case err
        (progn
          (call-interactively (lambda (x) (interactive "^*d") x))
          (list 'ok mark-active (mark t)))
      (error (list (car err) mark-active (mark t))))))
