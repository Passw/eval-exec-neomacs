; Extended interactive string-code behavior for lambda command designators.

; "d" reads point as a 1-based character position.
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (call-interactively (lambda (pt) (interactive "d") pt)))
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (command-execute (lambda (pt) (interactive "d") pt)))

; "m" reads mark as a 1-based character position, or signals when missing.
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (set-mark 2)
  (call-interactively (lambda (mk) (interactive "m") mk)))
(with-temp-buffer
  (insert "abcd")
  (goto-char 3)
  (condition-case err
      (call-interactively (lambda (mk) (interactive "m") mk))
    (error err)))

; "i" inserts a nil argument.
(call-interactively (lambda (ignored) (interactive "i") ignored))
(command-execute (lambda (ignored) (interactive "i") ignored))

; "c", "k", and "K" read character/key events from unread queue state.
(let ((unread-command-events (list 97)))
  (call-interactively (lambda (ch) (interactive "cChar: ") ch)))
(let ((unread-command-events (list 97)))
  (command-execute (lambda (ch) (interactive "cChar: ") ch)))
(let ((unread-command-events (list 97)))
  (call-interactively (lambda (keys) (interactive "kKeys: ") keys)))
(let ((unread-command-events (list 97)))
  (command-execute (lambda (keys) (interactive "kKeys: ") keys)))
(let ((unread-command-events (list 97)))
  (call-interactively (lambda (keys) (interactive "KKeys: ") keys)))
(let ((unread-command-events (list 97)))
  (command-execute (lambda (keys) (interactive "KKeys: ") keys)))

; Minibuffer-backed prompt codes currently signal EOF in batch mode.
(condition-case err
    (call-interactively (lambda (x) (interactive "aFunction: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "bBuffer: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "BBuffer: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "CCommand: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "DDirectory: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "fFind file: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "FFind file: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "vVariable: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "bBuffer: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "fFind file: ") x))
  (error err))

; "N" uses prefix when present, otherwise reads a number (EOF in batch).
(let ((current-prefix-arg '(4))
      (prefix-arg nil))
  (call-interactively (lambda (n) (interactive "NNumber: ") n)))
(let ((current-prefix-arg nil)
      (prefix-arg '(5)))
  (command-execute (lambda (n) (interactive "NNumber: ") n)))
(let ((current-prefix-arg nil)
      (prefix-arg nil))
  (condition-case err
      (call-interactively (lambda (n) (interactive "NNumber: ") n))
    (error err)))
(let ((current-prefix-arg nil)
      (prefix-arg nil))
  (condition-case err
      (command-execute (lambda (n) (interactive "NNumber: ") n))
    (error err)))

; "M", "S", "x", "X", and "z" prompt from stdin in batch.
(condition-case err
    (call-interactively (lambda (s) (interactive "MString: ") s))
  (error err))
(condition-case err
    (call-interactively (lambda (s) (interactive "SSymbol: ") s))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "xExpr: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (x) (interactive "XExpr: ") x))
  (error err))
(condition-case err
    (call-interactively (lambda (c) (interactive "zCoding: ") c))
  (error err))
(condition-case err
    (command-execute (lambda (s) (interactive "MString: ") s))
  (error err))
(condition-case err
    (command-execute (lambda (s) (interactive "SSymbol: ") s))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "xExpr: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "XExpr: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (c) (interactive "zCoding: ") c))
  (error err))

; "Z" optional coding-system path returns nil and preserves unread events in batch.
(let ((unread-command-events (list 97)))
  (list
   (call-interactively (lambda (c) (interactive "ZCoding: ") c))
   unread-command-events))
(let ((unread-command-events (list 97)))
  (list
   (command-execute (lambda (c) (interactive "ZCoding: ") c))
   unread-command-events))

; "G" file prompt variant currently signals EOF in batch.
(condition-case err
    (call-interactively (lambda (x) (interactive "GFind file: ") x))
  (error err))
(condition-case err
    (command-execute (lambda (x) (interactive "GFind file: ") x))
  (error err))

; "U" currently yields nil in batch and leaves unread queue unchanged.
(let ((unread-command-events (list 97)))
  (list
   (call-interactively (lambda (x) (interactive "U") x))
   unread-command-events))
(let ((unread-command-events (list 97)))
  (list
   (command-execute (lambda (x) (interactive "U") x))
   unread-command-events))

; "e" errors when no event-with-parameters context is available and preserves queue.
(let ((unread-command-events (list 97)))
  (condition-case err
      (call-interactively (lambda (x) (interactive "e") x))
    (error (list err unread-command-events))))
(let ((unread-command-events (list 97)))
  (condition-case err
      (command-execute (lambda (x) (interactive "e") x))
    (error (list err unread-command-events))))
