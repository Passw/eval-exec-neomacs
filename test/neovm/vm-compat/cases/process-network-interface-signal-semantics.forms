; Process network/signal helper compatibility semantics.
(mapcar (lambda (s)
          (let ((fn (and (fboundp s) (symbol-function s))))
            (list s
                  (fboundp s)
                  (and fn (subrp fn))
                  (and fn (subr-arity fn))
                  (commandp s))))
        '(process-connection
          format-network-address
          network-interface-list
          network-interface-info
          network-lookup-address-info
          signal-names))

(let* ((ifname (or (and (fboundp 'network-interface-list)
                        (stringp (caar (network-interface-list)))
                        (caar (network-interface-list)))
                   "lo")))
  (list
   (format-network-address [127 0 0 1 80])
   (format-network-address [127 0 0 1 80] t)
   (format-network-address [0 0 0 0 0 0 0 1 80])
   (format-network-address [0 0 0 0 0 0 0 1 80] t)
   (format-network-address "x")
   (format-network-address nil)
   (format-network-address [1])
   (format-network-address [127 0 0 1 65536])
   (format-network-address [0 0 0 0 0 0 0 1 65536])
   (condition-case err (format-network-address) (error err))
   (listp (network-interface-list))
   (consp (car (network-interface-list)))
   (stringp (caar (network-interface-list)))
   (vectorp (cdar (network-interface-list)))
   (listp (network-interface-list nil))
   (let ((entry (car (network-interface-list t))))
     (and (listp entry)
          (= (length entry) 4)
          (vectorp (nth 1 entry))
          (vectorp (nth 2 entry))
          (vectorp (nth 3 entry))))
   (let* ((entries (network-interface-list t))
          (ok t))
     (while (and ok entries)
       (let* ((entry (car entries))
              (addr (nth 1 entry))
              (bc (nth 2 entry))
              (mask (nth 3 entry))
              (len (length addr))
              (limit (if (= len 5) 4 8))
              (bits-mask (if (= len 5) #xff #xffff))
              (idx 0)
              (vals nil))
         (while (< idx limit)
           (setq vals
                 (append vals
                         (list (logand bits-mask
                                       (logior (aref addr idx)
                                               (lognot (aref mask idx)))))))
           (setq idx (1+ idx)))
         (setq vals (append vals '(0)))
         (setq ok (equal bc (apply #'vector vals))))
       (setq entries (cdr entries)))
     ok)
   (condition-case err (network-interface-list nil nil nil) (error err))
   (condition-case err (network-interface-list nil t) (error err))
   (let* ((entries (network-interface-list t 'ipv4))
          (ok t))
     (while (and ok entries)
       (let* ((entry (car entries))
              (addr (nth 1 entry)))
         (setq ok (and (vectorp addr) (= (length addr) 5))))
       (setq entries (cdr entries)))
     ok)
   (let* ((entries (network-interface-list t 'ipv6))
          (ok t))
     (while (and ok entries)
       (let* ((entry (car entries))
              (addr (nth 1 entry)))
         (setq ok (and (vectorp addr) (= (length addr) 9))))
       (setq entries (cdr entries)))
     ok)
   (let* ((entries (network-interface-list nil 'ipv4))
          (ok t))
     (while (and ok entries)
       (let* ((entry (car entries))
              (addr (cdr entry)))
         (setq ok (and (vectorp addr) (= (length addr) 5))))
       (setq entries (cdr entries)))
     ok)
   (let* ((entries (network-interface-list nil 'ipv6))
          (ok t))
     (while (and ok entries)
       (let* ((entry (car entries))
              (addr (cdr entry)))
         (setq ok (and (vectorp addr) (= (length addr) 9))))
       (setq entries (cdr entries)))
     ok)
   (let ((info (network-interface-info ifname)))
     (and (listp info)
          (= (length info) 5)
          (vectorp (car info))
          (vectorp (nth 1 info))
          (vectorp (nth 2 info))
          (or (null (nth 3 info))
              (consp (nth 3 info)))
          (listp (nth 4 info))))
   (let ((lo-info (network-interface-info "lo")))
     (and (listp lo-info)
          (= (length lo-info) 5)
          (vectorp (car lo-info))
          (vectorp (nth 1 lo-info))
          (vectorp (nth 2 lo-info))))
   (condition-case err (network-interface-info nil) (error err))
   (condition-case err (network-interface-info "abcdefghijklmnop") (error err))
   (listp (network-lookup-address-info "localhost"))
   (vectorp (car (network-lookup-address-info "localhost")))
   (listp (network-lookup-address-info "localhost" 'ipv4))
   (vectorp (car (network-lookup-address-info "localhost" 'ipv6)))
   (let* ((v4-any (network-lookup-address-info "127.0.0.1"))
          (v4-only (network-lookup-address-info "127.0.0.1" 'ipv4)))
     (and (equal v4-any v4-only)
          (consp v4-only)
          (equal (car v4-only) [127 0 0 1 0])))
   (null (network-lookup-address-info "127.0.0.1" 'ipv6))
   (let* ((v6-any (network-lookup-address-info "::1"))
          (v6-only (network-lookup-address-info "::1" 'ipv6)))
     (and (equal v6-any v6-only)
          (or (null v6-only)
              (equal (car v6-only) [0 0 0 0 0 0 0 1 0]))))
   (null (network-lookup-address-info "::1" 'ipv4))
   (let* ((entries (network-lookup-address-info "localhost" 'ipv4))
          (ok t))
     (while (and ok entries)
       (setq ok (= (length (car entries)) 5))
       (setq entries (cdr entries)))
     ok)
   (let* ((entries (network-lookup-address-info "localhost" 'ipv6))
          (ok t))
     (while (and ok entries)
       (setq ok (= (length (car entries)) 9))
       (setq entries (cdr entries)))
     ok)
   (condition-case err (network-lookup-address-info "localhost" t) (error err))
   (condition-case err (network-lookup-address-info "localhost" 'ipv4 t) (error err))
   (condition-case err (network-lookup-address-info 1) (error err))
   (listp (signal-names))
   (stringp (car (signal-names)))
   (not (null (member "KILL" (signal-names))))
   (condition-case err (signal-names nil) (error err))
   (condition-case err (process-connection nil) (error err))))
