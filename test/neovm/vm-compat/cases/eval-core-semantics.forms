; eval.c — core evaluation semantics
; eval
(eval '(+ 1 2))
(eval '(car '(a b c)))
(eval nil)
(eval t)
(eval 42)

; apply
(apply '+ '(1 2 3))
(apply 'cons '(a (b c)))
(apply 'list 1 2 '(3 4))
(condition-case err (apply 42 '(1)) (error (car err)))

; funcall
(funcall '+ 1 2)
(funcall 'car '(a b))
(funcall (lambda (x) (* x x)) 5)

; signal
(condition-case err (signal 'error '("test")) (error (cdr err)))
(condition-case err (signal 'wrong-type-argument '(integerp "x")) (error (car err)))

; commandp
(commandp 'self-insert-command)
(not (commandp 'car))
(not (commandp 42))

; autoload — type checks
(condition-case err (autoload 42 "file") (error (car err)))

; macroexpand
(macroexpand '(when t 1 2))
(macroexpand '(unless nil 1 2))

; special-variable-p
(not (special-variable-p 'nonexistent-var-12345))

; defvaralias — creates alias
(progn
  (defvar test-alias-source-99 42)
  (defvaralias 'test-alias-target-99 'test-alias-source-99)
  (= test-alias-target-99 42))

; function quoting
(functionp #'+)
(functionp #'car)
(functionp (lambda (x) x))

; and / or
(and t t t)
(eq (and t nil t) nil)
(or nil nil t)
(eq (or nil nil nil) nil)

; if / cond / progn / prog1 / prog2
(if t 1 2)
(if nil 1 2)
(cond (nil 1) (t 2) (t 3))
(progn 1 2 3)
(prog1 1 2 3)
(prog2 1 2 3)

; let / let*
(let ((x 1) (y 2)) (+ x y))
(let* ((x 1) (y (+ x 1))) (+ x y))

; while
(let ((i 0)) (while (< i 5) (setq i (1+ i))) i)

; unwind-protect
(let ((x 0))
  (condition-case nil
    (unwind-protect
      (error "test")
      (setq x 1))
    (error nil))
  x)

; condition-case
(condition-case err (/ 1 0) (arith-error 'caught))
(condition-case err (car 42) (wrong-type-argument 'caught))

; catch / throw
(catch 'done (throw 'done 42))
(catch 'outer (catch 'inner (throw 'outer 99)))

; defconst / defvar
(progn (defconst test-const-777 42) test-const-777)
(progn (defvar test-var-777 99) test-var-777)
