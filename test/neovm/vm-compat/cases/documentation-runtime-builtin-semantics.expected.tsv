1	(stringp (documentation 'car))	OK t
2	(stringp (documentation 'cdr))	OK t
3	(stringp (documentation 'if))	OK t
4	(condition-case err (documentation 'vm-doc-missing) (error (car err)))	OK void-function
5	(progn (fset 'vm-doc-lambda2 (lambda (x) "ldoc" x)) (documentation 'vm-doc-lambda2))	OK "ldoc"
6	(progn (put 'vm-doc-prop-only2 'function-documentation "pdoc") (documentation 'vm-doc-prop-only2))	OK "pdoc"
7	(progn (put 'vm-doc-prop-only2 'function-documentation '(identity "pdoc2")) (documentation 'vm-doc-prop-only2))	OK "pdoc2"
8	(progn (put 'vm-doc-prop-only2 'function-documentation 't) (documentation 'vm-doc-prop-only2))	OK t
9	(progn (put 'vm-doc-prop-only2 'function-documentation [1 2]) (documentation 'vm-doc-prop-only2))	OK [1 2]
10	(progn (put 'vm-doc-prop-only2 'function-documentation 1.5) (documentation 'vm-doc-prop-only2))	OK 1.5
11	(progn (put 'vm-doc-prop-only2 'function-documentation 9) (documentation 'vm-doc-prop-only2))	OK nil
12	(progn (put 'vm-doc-prop-only2 'function-documentation '(1 2)) (condition-case err (documentation 'vm-doc-prop-only2) (error err)))	OK (invalid-function 1)
13	(progn (put 'vm-doc-prop-only2 'function-documentation 'vm-doc-prop-unbound) (condition-case err (documentation 'vm-doc-prop-only2) (error err)))	OK (void-variable vm-doc-prop-unbound)
14	(progn (put 'vm-doc-prop-only2 'function-documentation '(progn "pdoc3")) (documentation 'vm-doc-prop-only2 t))	OK "pdoc3"
15	(progn (fset 'vm-doc-alias-target (lambda nil "aliasdoc" nil)) (defalias 'vm-doc-alias 'vm-doc-alias-target) (stringp (documentation 'vm-doc-alias)))	OK t
16	(progn (fset 'vm-doc-alias-builtin 'car) (stringp (documentation 'vm-doc-alias-builtin)))	OK t
17	(condition-case err (documentation 1) (error (car err)))	OK invalid-function
18	(stringp (documentation 'car t))	OK t
19	(condition-case err (documentation 'car nil nil) (error (car err)))	OK wrong-number-of-arguments
20	(stringp (documentation '(lambda (x) "d" x)))	OK t
21	(documentation '(lambda (x) "d" x))	OK "d"
22	(documentation '(lambda (x) x))	OK nil
23	(documentation [1 2])	OK "Keyboard macro."
24	(documentation "abc")	OK "Keyboard macro."
25	(condition-case err (documentation '(macro (x) "md" x)) (error err))	OK (invalid-function ((x) "md" x))
26	(condition-case err (documentation '(macro)) (error err))	OK (void-function nil)
27	(let ((s (documentation 'car))) (list (not (null (string-match-p "^Return the car of LIST\\." s))) (null (string-match-p "^Built-in function\\.$" s))))	OK (t t)
28	(let ((s (documentation 'cdr))) (list (not (null (string-match-p "^Return the cdr of LIST\\." s))) (null (string-match-p "^Built-in function\\.$" s))))	OK (t t)
29	(let ((s (documentation 'if))) (list (not (null (string-match-p "^If COND yields non-nil, do THEN, else do ELSE\\.\\.\\." s))) (null (string-match-p "^Built-in function\\.$" s))))	OK (t t)
30	(progn (fset 'vm-doc-alias-builtin 'car) (let ((s (documentation 'vm-doc-alias-builtin))) (list (not (null (string-match-p "^Return the car of LIST\\." s))) (null (string-match-p "^Built-in function\\.$" s)))))	OK (t t)
31	(let ((probes '((cons "Create a new cons, give it CAR and CDR as components, and return it.") (list "Return a newly created list with specified arguments as elements.") (eq "Return t if the two args are the same Lisp object.") (equal "Return t if two Lisp objects have similar structure and contents.") (length "Return the length of vector, list or string SEQUENCE.") (append "Concatenate all the arguments and make the result a list.") (mapcar "Apply FUNCTION to each element of SEQUENCE, and make a list of the results.") (assoc "Return non-nil if KEY is equal to the car of an element of ALIST.") (member "Return non-nil if ELT is an element of LIST.  Comparison done with ‘equal’.") (symbol-name "Return SYMBOL’s name, a string.")))) (mapcar (lambda (entry) (let* ((sym (car entry)) (prefix (cadr entry)) (doc (documentation sym))) (list sym (stringp doc) (not (null (string-match-p (concat "^" (regexp-quote prefix)) doc))) (null (string-match-p "^Built-in function\\.$" doc))))) probes))	OK ((cons t t t) (list t t t) (eq t t t) (equal t t t) (length t t t) (append t t t) (mapcar t t t) (assoc t t t) (member t t t) (symbol-name t t t))
