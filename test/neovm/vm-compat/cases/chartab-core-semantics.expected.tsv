1	(char-table-p (make-char-table 'syntax-table))	OK t
2	(char-table-p (make-char-table nil))	OK t
3	(condition-case err (make-char-table) (error (car err)))	OK wrong-number-of-arguments
4	(eq (char-table-subtype (make-char-table 'foo)) 'foo)	OK t
5	(eq (char-table-subtype (make-char-table nil)) nil)	OK t
6	(condition-case err (char-table-subtype 42) (error (car err)))	OK wrong-type-argument
7	(char-table-p (make-char-table nil))	OK t
8	(not (char-table-p nil))	OK t
9	(not (char-table-p [1 2 3]))	OK t
10	(not (char-table-p "hello"))	OK t
11	(eq (char-table-parent (make-char-table nil)) nil)	OK t
12	(let ((ct (make-char-table nil)) (parent (make-char-table nil))) (set-char-table-parent ct parent) (eq (char-table-parent ct) parent))	OK t
13	(condition-case err (set-char-table-parent (make-char-table nil) 42) (error (car err)))	OK wrong-type-argument
14	(let ((ct (make-char-table nil))) (set-char-table-range ct 97 42) (= (char-table-range ct 97) 42))	OK t
15	(let ((ct (make-char-table nil))) (set-char-table-range ct t 99) (= (char-table-range ct 122) 99))	OK t
16	(let ((ct (make-char-table nil))) (set-char-table-range ct t 0) (optimize-char-table ct) t)	OK t
17	(let ((ct (make-char-table nil)) (count 0)) (set-char-table-range ct 97 1) (set-char-table-range ct 98 2) (map-char-table (lambda (key val) (setq count (1+ count))) ct) (>= count 2))	OK t
18	(let ((parent (make-char-table nil)) (child (make-char-table nil))) (set-char-table-range parent 120 77) (set-char-table-parent child parent) (= (char-table-range child 120) 77))	OK t
19	(condition-case err (char-table-range 42 97) (error (car err)))	OK wrong-type-argument
20	(condition-case err (set-char-table-range 42 97 1) (error (car err)))	OK wrong-type-argument
