1	(fboundp 'make-syntax-table)	OK t
2	(fboundp 'standard-syntax-table)	OK t
3	(fboundp 'syntax-table)	OK t
4	(fboundp 'syntax-table-p)	OK t
5	(fboundp 'set-syntax-table)	OK t
6	(syntax-table-p (make-syntax-table))	OK t
7	(syntax-table-p (make-char-table 'foo))	OK nil
8	(syntax-table-p 1)	OK nil
9	(let ((tbl (make-syntax-table))) (eq (set-syntax-table tbl) tbl))	OK t
10	(char-table-p (make-syntax-table))	OK t
11	(eq (char-table-subtype (make-syntax-table)) 'syntax-table)	OK t
12	(let* ((parent (make-syntax-table)) (child (make-syntax-table parent))) (char-table-p (char-table-parent child)))	OK t
13	(let* ((parent (make-syntax-table)) (child (make-syntax-table parent))) (eq (char-table-subtype child) 'syntax-table))	OK t
14	(char-table-p (standard-syntax-table))	OK t
15	(eq (char-table-subtype (standard-syntax-table)) 'syntax-table)	OK t
16	(with-temp-buffer (char-table-p (syntax-table)))	OK t
17	(with-temp-buffer (eq (char-table-subtype (syntax-table)) 'syntax-table))	OK t
18	(condition-case err (make-syntax-table 1) (error (car err)))	OK wrong-type-argument
19	(condition-case err (set-syntax-table 1) (error (car err)))	OK wrong-type-argument
20	(condition-case err (syntax-table-p) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
21	(condition-case err (set-syntax-table) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
22	(condition-case err (standard-syntax-table 1) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
23	(condition-case err (syntax-table 1) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
