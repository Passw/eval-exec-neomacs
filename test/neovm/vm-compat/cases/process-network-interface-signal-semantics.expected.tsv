1	(mapcar (lambda (s) (let ((fn (and (fboundp s) (symbol-function s)))) (list s (fboundp s) (and fn (subrp fn)) (and fn (subr-arity fn)) (commandp s)))) '(process-connection format-network-address network-interface-list network-interface-info network-lookup-address-info signal-names))	OK ((process-connection nil nil nil nil) (format-network-address t t (1 . 2) nil) (network-interface-list t t (0 . 2) nil) (network-interface-info t t (1 . 1) nil) (network-lookup-address-info t t (1 . 3) nil) (signal-names t t (0 . 0) nil))
2	(let* ((ifname (or (and (fboundp 'network-interface-list) (stringp (caar (network-interface-list))) (caar (network-interface-list))) "lo"))) (list (format-network-address [127 0 0 1 80]) (format-network-address [127 0 0 1 80] t) (format-network-address [0 0 0 0 0 0 0 1 80]) (format-network-address [0 0 0 0 0 0 0 1 80] t) (format-network-address "x") (format-network-address nil) (format-network-address [1]) (format-network-address [127 0 0 1 65536]) (format-network-address [0 0 0 0 0 0 0 1 65536]) (condition-case err (format-network-address) (error err)) (listp (network-interface-list)) (consp (car (network-interface-list))) (stringp (caar (network-interface-list))) (vectorp (cdar (network-interface-list))) (listp (network-interface-list nil)) (let ((entry (car (network-interface-list t)))) (and (listp entry) (= (length entry) 4) (vectorp (nth 1 entry)) (vectorp (nth 2 entry)) (vectorp (nth 3 entry)))) (let* ((entries (network-interface-list t)) (ok t)) (while (and ok entries) (let* ((entry (car entries)) (addr (nth 1 entry)) (bc (nth 2 entry)) (mask (nth 3 entry)) (len (length addr)) (limit (if (= len 5) 4 8)) (bits-mask (if (= len 5) 255 65535)) (idx 0) (vals nil)) (while (< idx limit) (setq vals (append vals (list (logand bits-mask (logior (aref addr idx) (lognot (aref mask idx))))))) (setq idx (1+ idx))) (setq vals (append vals '(0))) (setq ok (equal bc (apply #'vector vals)))) (setq entries (cdr entries))) ok) (condition-case err (network-interface-list nil nil nil) (error err)) (condition-case err (network-interface-list nil t) (error err)) (let* ((entries (network-interface-list t 'ipv4)) (ok t)) (while (and ok entries) (let* ((entry (car entries)) (addr (nth 1 entry))) (setq ok (and (vectorp addr) (= (length addr) 5)))) (setq entries (cdr entries))) ok) (let* ((entries (network-interface-list t 'ipv6)) (ok t)) (while (and ok entries) (let* ((entry (car entries)) (addr (nth 1 entry))) (setq ok (and (vectorp addr) (= (length addr) 9)))) (setq entries (cdr entries))) ok) (let* ((entries (network-interface-list nil 'ipv4)) (ok t)) (while (and ok entries) (let* ((entry (car entries)) (addr (cdr entry))) (setq ok (and (vectorp addr) (= (length addr) 5)))) (setq entries (cdr entries))) ok) (let* ((entries (network-interface-list nil 'ipv6)) (ok t)) (while (and ok entries) (let* ((entry (car entries)) (addr (cdr entry))) (setq ok (and (vectorp addr) (= (length addr) 9)))) (setq entries (cdr entries))) ok) (let ((info (network-interface-info ifname))) (and (listp info) (= (length info) 5) (vectorp (car info)) (vectorp (nth 1 info)) (vectorp (nth 2 info)) (or (null (nth 3 info)) (consp (nth 3 info))) (listp (nth 4 info)))) (let ((lo-info (network-interface-info "lo"))) (and (listp lo-info) (= (length lo-info) 5) (vectorp (car lo-info)) (vectorp (nth 1 lo-info)) (vectorp (nth 2 lo-info)))) (let* ((ifname (car (car (network-interface-list nil 'ipv4)))) (info (and ifname (network-interface-info ifname))) (entries (network-interface-list nil 'ipv4)) (found nil)) (while entries (let ((entry (car entries))) (if (and (equal (car entry) ifname) (equal (cdr entry) (car info))) (setq found t))) (setq entries (cdr entries))) (or (null ifname) found)) (let* ((info (network-interface-info ifname)) (addr (car info)) (bc (nth 1 info)) (mask (nth 2 info)) (len (length addr))) (and (or (= len 5) (= len 9)) (= (length bc) len) (= (length mask) len))) (let* ((lo-info (network-interface-info "lo")) (addr (car lo-info)) (bc (nth 1 lo-info)) (mask (nth 2 lo-info))) (and (= (length addr) (length bc)) (= (length addr) (length mask)))) (equal (network-interface-info (concat "lo" (string 0) "x")) (network-interface-info "lo")) (condition-case err (network-interface-info nil) (error err)) (condition-case err (network-interface-info "abcdefghijklmnop") (error err)) (condition-case err (network-interface-info (concat "abcdefghijklmnop" (string 0))) (error err)) (condition-case err (network-interface-info (concat "aaaaaaaaaaaaaa" (string 233))) (error err)) (null (network-interface-info (concat "aaaaaaaaaaaaa" (string 233)))) (listp (network-lookup-address-info "localhost")) (vectorp (car (network-lookup-address-info "localhost"))) (listp (network-lookup-address-info "localhost" 'ipv4)) (vectorp (car (network-lookup-address-info "localhost" 'ipv6))) (let* ((v4-any (network-lookup-address-info "127.0.0.1")) (v4-only (network-lookup-address-info "127.0.0.1" 'ipv4))) (and (equal v4-any v4-only) (consp v4-only) (equal (car v4-only) [127 0 0 1 0]))) (null (network-lookup-address-info "127.0.0.1" 'ipv6)) (let* ((v6-any (network-lookup-address-info "::1")) (v6-only (network-lookup-address-info "::1" 'ipv6))) (and (equal v6-any v6-only) (or (null v6-only) (equal (car v6-only) [0 0 0 0 0 0 0 1 0])))) (null (network-lookup-address-info "::1" 'ipv4)) (let* ((entries (network-lookup-address-info "localhost" 'ipv4)) (ok t)) (while (and ok entries) (setq ok (= (length (car entries)) 5)) (setq entries (cdr entries))) ok) (let* ((entries (network-lookup-address-info "localhost" 'ipv6)) (ok t)) (while (and ok entries) (setq ok (= (length (car entries)) 9)) (setq entries (cdr entries))) ok) (equal (network-lookup-address-info (concat "abc" (string 0) "def")) (network-lookup-address-info "abc")) (equal (network-lookup-address-info (string 0)) (network-lookup-address-info "")) (condition-case err (network-lookup-address-info "localhost" t) (error err)) (condition-case err (network-lookup-address-info "localhost" 'ipv4 t) (error err)) (condition-case err (network-lookup-address-info 1) (error err)) (listp (signal-names)) (stringp (car (signal-names))) (not (null (member "KILL" (signal-names)))) (condition-case err (signal-names nil) (error err)) (condition-case err (process-connection nil) (error err))))	OK ("127.0.0.1:80" "127.0.0.1" "[0:0:0:0:0:0:0:1]:80" "0:0:0:0:0:0:0:1" "x" nil nil nil nil (wrong-number-of-arguments format-network-address 0) t t t t t t t (wrong-number-of-arguments network-interface-list 3) (error "Unsupported address family") t t t t t t t t t t (wrong-type-argument stringp nil) (error "interface name too long") (error "interface name too long") (error "interface name too long") t t t t t t t t t t t t t (error "Unsupported family") (error "Unsupported hints value") (wrong-type-argument stringp 1) t t t (wrong-number-of-arguments signal-names 1) (void-function process-connection))
