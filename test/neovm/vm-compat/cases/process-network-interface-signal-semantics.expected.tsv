1	(mapcar (lambda (s) (let ((fn (and (fboundp s) (symbol-function s)))) (list s (fboundp s) (and fn (subrp fn)) (and fn (subr-arity fn)) (commandp s)))) '(process-connection format-network-address network-interface-list network-interface-info network-lookup-address-info signal-names))	OK ((process-connection nil nil nil nil) (format-network-address t t (1 . 2) nil) (network-interface-list t t (0 . 2) nil) (network-interface-info t t (1 . 1) nil) (network-lookup-address-info t t (1 . 3) nil) (signal-names t t (0 . 0) nil))
2	(let* ((ifname (or (and (fboundp 'network-interface-list) (stringp (caar (network-interface-list))) (caar (network-interface-list))) "lo"))) (list (format-network-address [127 0 0 1 80]) (format-network-address [127 0 0 1 80] t) (format-network-address [0 0 0 0 0 0 0 1 80]) (format-network-address [0 0 0 0 0 0 0 1 80] t) (format-network-address "x") (format-network-address nil) (format-network-address [1]) (format-network-address [127 0 0 1 65536]) (format-network-address [0 0 0 0 0 0 0 1 65536]) (condition-case err (format-network-address) (error err)) (listp (network-interface-list)) (consp (car (network-interface-list))) (stringp (caar (network-interface-list))) (vectorp (cdar (network-interface-list))) (listp (network-interface-list nil)) (let ((entry (car (network-interface-list t)))) (and (listp entry) (= (length entry) 4) (vectorp (nth 1 entry)) (vectorp (nth 2 entry)) (vectorp (nth 3 entry)))) (let* ((entries (network-interface-list t)) (ok t)) (while (and ok entries) (let* ((entry (car entries)) (addr (nth 1 entry)) (bc (nth 2 entry)) (mask (nth 3 entry)) (len (length addr)) (limit (if (= len 5) 4 8)) (bits-mask (if (= len 5) 255 65535)) (idx 0) (vals nil)) (while (< idx limit) (setq vals (append vals (list (logand bits-mask (logior (aref addr idx) (lognot (aref mask idx))))))) (setq idx (1+ idx))) (setq vals (append vals '(0))) (setq ok (equal bc (apply #'vector vals)))) (setq entries (cdr entries))) ok) (condition-case err (network-interface-list nil nil nil) (error err)) (condition-case err (network-interface-list nil t) (error err)) (let ((info (network-interface-info ifname))) (and (listp info) (= (length info) 5) (vectorp (car info)) (vectorp (nth 1 info)) (vectorp (nth 2 info)) (or (null (nth 3 info)) (consp (nth 3 info))) (listp (nth 4 info)))) (let ((lo-info (network-interface-info "lo"))) (and (listp lo-info) (= (length lo-info) 5) (vectorp (car lo-info)) (vectorp (nth 1 lo-info)) (vectorp (nth 2 lo-info)))) (condition-case err (network-interface-info nil) (error err)) (condition-case err (network-interface-info "abcdefghijklmnop") (error err)) (listp (network-lookup-address-info "localhost")) (vectorp (car (network-lookup-address-info "localhost"))) (listp (network-lookup-address-info "localhost" 'ipv4)) (vectorp (car (network-lookup-address-info "localhost" 'ipv6))) (condition-case err (network-lookup-address-info "localhost" t) (error err)) (condition-case err (network-lookup-address-info "localhost" 'ipv4 t) (error err)) (condition-case err (network-lookup-address-info 1) (error err)) (listp (signal-names)) (stringp (car (signal-names))) (not (null (member "KILL" (signal-names)))) (condition-case err (signal-names nil) (error err)) (condition-case err (process-connection nil) (error err))))	OK ("127.0.0.1:80" "127.0.0.1" "[0:0:0:0:0:0:0:1]:80" "0:0:0:0:0:0:0:1" "x" nil nil nil nil (wrong-number-of-arguments format-network-address 0) t t t t t t t (wrong-number-of-arguments network-interface-list 3) (error "Unsupported address family") t t (wrong-type-argument stringp nil) (error "interface name too long") t t t t (error "Unsupported family") (error "Unsupported hints value") (wrong-type-argument stringp 1) t t t (wrong-number-of-arguments signal-names 1) (void-function process-connection))
