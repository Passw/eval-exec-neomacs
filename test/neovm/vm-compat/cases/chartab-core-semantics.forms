; chartab.c — char-table operations (oracle-safe subset)
; make-char-table
(char-table-p (make-char-table 'syntax-table))
(char-table-p (make-char-table nil))
(condition-case err (make-char-table) (error (car err)))

; char-table-subtype
(eq (char-table-subtype (make-char-table 'foo)) 'foo)
(eq (char-table-subtype (make-char-table nil)) nil)
(condition-case err (char-table-subtype 42) (error (car err)))

; char-table-p
(char-table-p (make-char-table nil))
(not (char-table-p nil))
(not (char-table-p [1 2 3]))
(not (char-table-p "hello"))

; char-table-parent / set-char-table-parent
(eq (char-table-parent (make-char-table nil)) nil)
(let ((ct (make-char-table nil))
      (parent (make-char-table nil)))
  (set-char-table-parent ct parent)
  (eq (char-table-parent ct) parent))
(condition-case err (set-char-table-parent (make-char-table nil) 42) (error (car err)))

; set-char-table-range / char-table-range
(let ((ct (make-char-table nil)))
  (set-char-table-range ct ?a 42)
  (= (char-table-range ct ?a) 42))
(let ((ct (make-char-table nil)))
  (set-char-table-range ct t 99)
  (= (char-table-range ct ?z) 99))

; optimize-char-table — should not error
(let ((ct (make-char-table nil)))
  (set-char-table-range ct t 0)
  (optimize-char-table ct)
  t)

; map-char-table
(let ((ct (make-char-table nil))
      (count 0))
  (set-char-table-range ct ?a 1)
  (set-char-table-range ct ?b 2)
  (map-char-table (lambda (key val) (setq count (1+ count))) ct)
  (>= count 2))

; inheritance via parent
(let ((parent (make-char-table nil))
      (child (make-char-table nil)))
  (set-char-table-range parent ?x 77)
  (set-char-table-parent child parent)
  (= (char-table-range child ?x) 77))

; error: wrong type
(condition-case err (char-table-range 42 ?a) (error (car err)))
(condition-case err (set-char-table-range 42 ?a 1) (error (car err)))
