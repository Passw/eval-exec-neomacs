1	(with-temp-buffer (insert "abcd") (goto-char 3) (call-interactively (lambda (pt) (interactive "d") pt)))	OK 3
2	(with-temp-buffer (insert "abcd") (goto-char 3) (command-execute (lambda (pt) (interactive "d") pt)))	OK 3
3	(with-temp-buffer (insert "abcd") (goto-char 3) (set-mark 2) (call-interactively (lambda (mk) (interactive "m") mk)))	OK 2
4	(with-temp-buffer (insert "abcd") (goto-char 3) (condition-case err (call-interactively (lambda (mk) (interactive "m") mk)) (error err)))	OK (error "The mark is not set now")
5	(call-interactively (lambda (ignored) (interactive "i") ignored))	OK nil
6	(command-execute (lambda (ignored) (interactive "i") ignored))	OK nil
7	(let ((unread-command-events (list 97))) (call-interactively (lambda (ch) (interactive "cChar: ") ch)))	OK 97
8	(let ((unread-command-events (list 97))) (command-execute (lambda (ch) (interactive "cChar: ") ch)))	OK 97
9	(let ((unread-command-events (list 97))) (call-interactively (lambda (keys) (interactive "kKeys: ") keys)))	OK "a"
10	(let ((unread-command-events (list 97))) (command-execute (lambda (keys) (interactive "kKeys: ") keys)))	OK "a"
11	(let ((unread-command-events (list 97))) (call-interactively (lambda (keys) (interactive "KKeys: ") keys)))	OK [97]
12	(let ((unread-command-events (list 97))) (command-execute (lambda (keys) (interactive "KKeys: ") keys)))	OK [97]
13	(condition-case err (call-interactively (lambda (x) (interactive "aFunction: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
14	(condition-case err (call-interactively (lambda (x) (interactive "bBuffer: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
15	(condition-case err (call-interactively (lambda (x) (interactive "BBuffer: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
16	(condition-case err (call-interactively (lambda (x) (interactive "CCommand: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
17	(condition-case err (call-interactively (lambda (x) (interactive "DDirectory: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
18	(condition-case err (call-interactively (lambda (x) (interactive "fFind file: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
19	(condition-case err (call-interactively (lambda (x) (interactive "FFind file: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
20	(condition-case err (call-interactively (lambda (x) (interactive "vVariable: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
21	(condition-case err (command-execute (lambda (x) (interactive "bBuffer: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
22	(condition-case err (command-execute (lambda (x) (interactive "fFind file: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
23	(let ((current-prefix-arg '(4)) (prefix-arg nil)) (call-interactively (lambda (n) (interactive "NNumber: ") n)))	OK 4
24	(let ((current-prefix-arg nil) (prefix-arg '(5))) (command-execute (lambda (n) (interactive "NNumber: ") n)))	OK 5
25	(let ((current-prefix-arg nil) (prefix-arg nil)) (condition-case err (call-interactively (lambda (n) (interactive "NNumber: ") n)) (error err)))	OK (end-of-file "Error reading from stdin")
26	(let ((current-prefix-arg nil) (prefix-arg nil)) (condition-case err (command-execute (lambda (n) (interactive "NNumber: ") n)) (error err)))	OK (end-of-file "Error reading from stdin")
27	(condition-case err (call-interactively (lambda (s) (interactive "MString: ") s)) (error err))	OK (end-of-file "Error reading from stdin")
28	(condition-case err (call-interactively (lambda (s) (interactive "SSymbol: ") s)) (error err))	OK (end-of-file "Error reading from stdin")
29	(condition-case err (call-interactively (lambda (x) (interactive "xExpr: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
30	(condition-case err (call-interactively (lambda (x) (interactive "XExpr: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
31	(condition-case err (call-interactively (lambda (c) (interactive "zCoding: ") c)) (error err))	OK (end-of-file "Error reading from stdin")
32	(condition-case err (command-execute (lambda (s) (interactive "MString: ") s)) (error err))	OK (end-of-file "Error reading from stdin")
33	(condition-case err (command-execute (lambda (s) (interactive "SSymbol: ") s)) (error err))	OK (end-of-file "Error reading from stdin")
34	(condition-case err (command-execute (lambda (x) (interactive "xExpr: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
35	(condition-case err (command-execute (lambda (x) (interactive "XExpr: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
36	(condition-case err (command-execute (lambda (c) (interactive "zCoding: ") c)) (error err))	OK (end-of-file "Error reading from stdin")
37	(let ((unread-command-events (list 97))) (list (call-interactively (lambda (c) (interactive "ZCoding: ") c)) unread-command-events))	OK (nil (97))
38	(let ((unread-command-events (list 97))) (list (command-execute (lambda (c) (interactive "ZCoding: ") c)) unread-command-events))	OK (nil (97))
39	(condition-case err (call-interactively (lambda (x) (interactive "GFind file: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
40	(condition-case err (command-execute (lambda (x) (interactive "GFind file: ") x)) (error err))	OK (end-of-file "Error reading from stdin")
41	(let ((unread-command-events (list 97))) (list (call-interactively (lambda (x) (interactive "U") x)) unread-command-events))	OK (nil (97))
42	(let ((unread-command-events (list 97))) (list (command-execute (lambda (x) (interactive "U") x)) unread-command-events))	OK (nil (97))
43	(let ((unread-command-events (list 97))) (condition-case err (call-interactively (lambda (x) (interactive "e") x)) (error (list err unread-command-events))))	OK ((error "command must be bound to an event with parameters") (97))
44	(let ((unread-command-events (list 97))) (condition-case err (command-execute (lambda (x) (interactive "e") x)) (error (list err unread-command-events))))	OK ((error "command must be bound to an event with parameters") (97))
45	(let ((evt (list 'mouse-1 (list (list (selected-window) (point) '(0 . 0) 0)))) (r nil)) (setq r (call-interactively (lambda (x) (interactive "e") x) nil (vector evt))) (and (consp r) (eq (car r) 'mouse-1)))	OK t
46	(let ((evt (list 'mouse-1 (list (list (selected-window) (point) '(0 . 0) 0)))) (r nil)) (setq r (command-execute (lambda (x) (interactive "e") x) nil (vector evt))) (and (consp r) (eq (car r) 'mouse-1)))	OK t
47	(let ((evt (list 'mouse-1 (list (list (selected-window) (point) '(0 . 0) 0)))) (r nil)) (setq r (call-interactively (lambda (x) (interactive "e") x) nil (vector 97 evt))) (and (consp r) (eq (car r) 'mouse-1)))	OK t
48	(equal (call-interactively (lambda (x) (interactive "e") x) nil (vector '(mouse-1))) '(mouse-1))	OK t
49	(condition-case err (call-interactively (lambda (x) (interactive "e") x) nil [mouse-1]) (error (car err)))	OK error
50	(condition-case err (command-execute (lambda (x) (interactive "e") x) nil [mouse-1]) (error (car err)))	OK error
51	(condition-case err (call-interactively (lambda (x) (interactive "e") x) nil (vector [mouse-1])) (error (car err)))	OK error
52	(with-temp-buffer (let ((buffer-read-only nil)) (call-interactively (lambda nil (interactive "*") 'ok))))	OK ok
53	(with-temp-buffer (let ((buffer-read-only t)) (condition-case err (call-interactively (lambda nil (interactive "*") 'ok)) (error (car err)))))	OK buffer-read-only
54	(with-temp-buffer (let ((buffer-read-only t) (inhibit-read-only t)) (call-interactively (lambda nil (interactive "*") 'ok))))	OK ok
55	(with-temp-buffer (insert "abcd") (goto-char 3) (setq mark-active nil) (let ((this-command-keys-shift-translated t) (shift-select-mode t)) (list (call-interactively (lambda (pt) (interactive "^d") pt)) mark-active (mark t))))	OK (3 t 3)
56	(with-temp-buffer (insert "abcd") (goto-char 3) (setq mark-active nil) (let ((this-command-keys-shift-translated t) (shift-select-mode t)) (list (command-execute (lambda (pt) (interactive "^d") pt)) mark-active (mark t))))	OK (3 t 3)
57	(with-temp-buffer (insert "abcd") (goto-char 3) (set-mark 1) (setq mark-active nil) (let ((this-command-keys-shift-translated nil) (shift-select-mode t)) (list (call-interactively (lambda (pt) (interactive "^d") pt)) mark-active (mark t))))	OK (3 nil 1)
58	(with-temp-buffer (insert "ab") (goto-char 2) (call-interactively (lambda (pt) (interactive "@d") pt)))	OK 2
59	(with-temp-buffer (insert "ab") (goto-char 2) (command-execute (lambda (pt) (interactive "@d") pt)))	OK 2
60	(with-temp-buffer (insert "abcd") (goto-char 3) (setq buffer-read-only t) (setq mark-active nil) (let ((this-command-keys-shift-translated t) (shift-select-mode t)) (condition-case err (progn (call-interactively (lambda (x) (interactive "*^d") x)) (list 'ok mark-active (mark t))) (error (list (car err) mark-active (mark t))))))	OK (buffer-read-only nil nil)
61	(with-temp-buffer (insert "abcd") (goto-char 3) (setq buffer-read-only t) (setq mark-active nil) (let ((this-command-keys-shift-translated t) (shift-select-mode t)) (condition-case err (progn (call-interactively (lambda (x) (interactive "^*d") x)) (list 'ok mark-active (mark t))) (error (list (car err) mark-active (mark t))))))	OK (buffer-read-only t 3)
