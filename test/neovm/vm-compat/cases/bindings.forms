; Dynamic-binding stack behavior and restoration
(let ((x 1)) (let ((x 2)) x))
(let ((x 1)) (let ((x 2)) nil) x)
(let ((x 1)) (setq x 3) x)
(let ((x 1)) (let ((x 2)) (setq x 7) x) x)

; Global vs dynamically scoped overrides
(progn (setq z 10) (let ((z 11)) z) z)
(progn (setq z 10) (let ((z 11)) (setq z 12) z) z)

; Sequential bindings and arithmetic dependencies
(let* ((a 1) (b (+ a 1)) (c (+ b 1))) (list a b c))

; Error handling should preserve side-effects at the right depth
(let ((x 0)) (condition-case e (progn (setq x 1) (/ 1 0)) (arith-error x)))
(let ((x 0)) (condition-case e (unwind-protect (/ 1 0) (setq x 5)) (arith-error x)))

; catch/throw with dynamic variable mutation
(let ((x 1)) (catch 'k (setq x 9) (throw 'k x) 0))
(let ((x 1)) (condition-case e (catch 'k (throw 'k 5) x) (error 'bad)))
