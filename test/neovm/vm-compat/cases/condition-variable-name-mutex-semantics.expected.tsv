1	(fboundp 'condition-name)	OK t
2	(fboundp 'condition-mutex)	OK t
3	(subrp (symbol-function 'condition-name))	OK t
4	(subrp (symbol-function 'condition-mutex))	OK t
5	(subr-arity (symbol-function 'condition-name))	OK (1 . 1)
6	(subr-arity (symbol-function 'condition-mutex))	OK (1 . 1)
7	(let* ((m (make-mutex)) (cv (make-condition-variable m))) (list (condition-name cv) (eq (condition-mutex cv) m) (mutexp (condition-mutex cv))))	OK (nil t t)
8	(let* ((m (make-mutex)) (cv (make-condition-variable m "cv-name"))) (condition-name cv))	OK "cv-name"
9	(condition-case err (condition-name nil) (error err))	OK (wrong-type-argument condition-variable-p nil)
10	(condition-case err (condition-mutex nil) (error err))	OK (wrong-type-argument condition-variable-p nil)
11	(condition-case err (condition-name '(condition-variable . 1)) (error err))	OK (wrong-type-argument condition-variable-p (condition-variable . 1))
12	(condition-case err (condition-mutex '(condition-variable . 1)) (error err))	OK (wrong-type-argument condition-variable-p (condition-variable . 1))
13	(condition-case err (condition-name) (error (car err)))	OK wrong-number-of-arguments
14	(condition-case err (condition-mutex nil nil) (error (car err)))	OK wrong-number-of-arguments
