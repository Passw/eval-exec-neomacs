1	(fboundp 'terminal-list)	OK t
2	(funcall #'terminal-list)	OK (#<terminal 0 on initial_terminal>)
3	(apply #'terminal-list nil)	OK (#<terminal 0 on initial_terminal>)
4	(equal (funcall #'terminal-list) (terminal-list))	OK t
5	(equal (apply #'terminal-list nil) (terminal-list))	OK t
6	(let ((fn (indirect-function 'terminal-list))) (funcall fn))	OK (#<terminal 0 on initial_terminal>)
7	(funcall (symbol-function 'terminal-list))	OK (#<terminal 0 on initial_terminal>)
8	(let ((lst (funcall #'terminal-list))) (and (consp lst) (terminal-live-p (car lst))))	OK t
9	(let ((lst (apply #'terminal-list nil))) (and (listp lst) (terminal-live-p (car lst))))	OK t
10	(condition-case err (funcall #'terminal-list nil) (error err))	OK (wrong-number-of-arguments #<subr terminal-list> 1)
11	(condition-case err (apply #'terminal-list '(nil)) (error err))	OK (wrong-number-of-arguments #<subr terminal-list> 1)
12	(condition-case err (funcall #'terminal-list nil nil) (error err))	OK (wrong-number-of-arguments #<subr terminal-list> 2)
13	(condition-case err (apply #'terminal-list '(nil nil)) (error err))	OK (wrong-number-of-arguments #<subr terminal-list> 2)
