(fboundp 'help-key-description)
(subr-arity (symbol-function 'help-key-description))
(help-function-arglist 'help-key-description)
(help-function-arglist 'help-key-description t)
(condition-case err (help-key-description) (error (car err)))
(condition-case err (help-key-description "a") (error (car err)))
(condition-case err (help-key-description "a" nil nil) (error (car err)))
(condition-case err (help-key-description 1 "a") (error (car err)))
(condition-case err (help-key-description "a" 1) (error (car err)))
(condition-case err (help-key-description "a" '(a)) (error (car err)))
(condition-case err (help-key-description "a" "") (error (car err)))
(condition-case err (help-key-description [] []) (error (car err)))
(help-key-description nil nil)
(string= (help-key-description "ab" nil) "a b")
(string= (help-key-description "ab" "ab") "a b")
(string= (help-key-description "ab" "ac") "a b (translated from a c)")
(string= (help-key-description "a" "b") "a 'LATIN SMALL LETTER A' (translated from b)")
(string= (help-key-description [97] [98]) "a 'LATIN SMALL LETTER A' (translated from b)")
(string= (help-key-description [24 6] [24 6]) "C-x C-f")
(string= (help-key-description [24 6] [24]) "C-x C-f (translated from C-x)")
(string= (help-key-description nil "a") "nil (translated from a)")
(string= (help-key-description '(a) nil) "<a>")
(string= (help-key-description '(a) "a") "<a> (translated from a)")
(string= (help-key-description "" nil) "")
(string= (help-key-description "" "a") " (translated from a)")

(fboundp 'recent-keys)
(subr-arity (symbol-function 'recent-keys))
(help-function-arglist 'recent-keys)
(help-function-arglist 'recent-keys t)
(type-of (recent-keys))
(length (recent-keys))
(append (recent-keys) nil)
(type-of (recent-keys nil))
(length (recent-keys nil))
(type-of (recent-keys t))
(length (recent-keys t))
(type-of (recent-keys 'foo))
(length (recent-keys "x"))
(condition-case err (recent-keys nil nil) (error (car err)))
(let ((start (length (recent-keys))))
  (setq unread-command-events (list 97))
  (read-char)
  (append (nthcdr start (append (recent-keys) nil)) nil))
(let ((start (length (recent-keys))))
  (setq unread-command-events (list '(mouse-1) 98))
  (read-char-exclusive nil nil 0)
  (append (nthcdr start (append (recent-keys) nil)) nil))
(let ((start (length (recent-keys))))
  (setq unread-command-events (list 'foo 97))
  (condition-case _ (read-char nil nil 0) (error nil))
  (append (nthcdr start (append (recent-keys) nil)) nil))
(let ((start (length (recent-keys))))
  (setq unread-command-events (list 99 100))
  (read-key nil)
  (append (nthcdr start (append (recent-keys) nil)) nil))
(let ((start (length (recent-keys))))
  (setq unread-command-events (list '(control 97)))
  (read-event nil nil 0)
  (append (nthcdr start (append (recent-keys) nil)) nil))

; Prompt/input readers in batch do not publish recent-keys entries when they
; terminate with end-of-file on queued unread events.
(let ((probes
       '((read-string "")
         (read-number "")
         (read-from-minibuffer "")
         (completing-read "" (("a") ("b")))
         (read-command "")
         (read-variable "")
         (read-buffer "")
         (read-file-name ""))))
  (mapcar
   (lambda (entry)
     (let ((fn (car entry))
           (args (cdr entry))
           (start (length (recent-keys))))
       (condition-case _
           (progn
             (setq unread-command-events (list 97 'foo))
             (apply fn args))
         (error nil))
       (list fn (append (nthcdr start (append (recent-keys) nil)) nil))))
   probes))

(equal (append (recent-keys) nil) (append (recent-keys t) nil))
