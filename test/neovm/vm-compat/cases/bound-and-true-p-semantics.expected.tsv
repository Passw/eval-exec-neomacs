1	(fboundp 'bound-and-true-p)	OK t
2	(macrop 'bound-and-true-p)	OK t
3	(functionp 'bound-and-true-p)	OK nil
4	(func-arity (indirect-function 'bound-and-true-p))	OK (1 . 1)
5	(macroexpand '(bound-and-true-p vm-batp))	OK (and (boundp 'vm-batp) vm-batp)
6	(macroexpand '(bound-and-true-p 1))	ERR (wrong-type-argument (symbolp 1))
7	(let ((vm-batp t)) (bound-and-true-p vm-batp))	OK t
8	(let ((vm-batp nil)) (bound-and-true-p vm-batp))	OK nil
9	(condition-case err (bound-and-true-p vm-batp-unbound) (error (list :error (car err) (cdr err))))	OK nil
10	(condition-case err (bound-and-true-p 1) (error (list :error (car err) (cdr err))))	OK (:error wrong-type-argument (symbolp 1))
11	(condition-case err (bound-and-true-p) (error (list :error (car err) (cdr err))))	OK (:error wrong-number-of-arguments ((1 . 1) 0))
12	(condition-case err (bound-and-true-p vm-a vm-b) (error (list :error (car err) (cdr err))))	OK (:error wrong-number-of-arguments ((1 . 1) 2))
