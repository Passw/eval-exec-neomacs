1	(documentation-property 'vm-docprop-symbol 'variable-documentation)	OK nil
2	(stringp (documentation-property 'load-path 'variable-documentation))	OK t
3	(stringp (documentation-property 'load-path 'variable-documentation t))	OK t
4	(not (null (string-match-p "List of directories to search for files to load" (documentation-property 'load-path 'variable-documentation nil))))	OK t
5	(not (null (string-match-p "List of directories to search for files to load" (documentation-property 'load-path 'variable-documentation t))))	OK t
6	(mapcar (lambda (s) (let ((v (documentation-property s 'variable-documentation))) (list s (stringp v) (null v)))) '(load-path load-history features debug-on-error default-directory load-file-name noninteractive inhibit-quit print-length print-level standard-output buffer-read-only kill-ring kill-ring-yank-pointer last-command lexical-binding load-prefer-newer))	OK ((load-path t nil) (load-history t nil) (features t nil) (debug-on-error t nil) (default-directory t nil) (load-file-name t nil) (noninteractive t nil) (inhibit-quit t nil) (print-length t nil) (print-level t nil) (standard-output t nil) (buffer-read-only t nil) (kill-ring t nil) (kill-ring-yank-pointer t nil) (last-command t nil) (lexical-binding t nil) (load-prefer-newer t nil))
7	(mapcar (lambda (entry) (let* ((sym (car entry)) (prefix (cadr entry)) (doc (documentation-property sym 'variable-documentation)) (first (and (stringp doc) (car (split-string doc (string 10) t))))) (list sym (stringp doc) (and (stringp first) (string-prefix-p prefix first))))) '((load-history "Alist mapping loaded file names to symbols and features.") (features "A list of symbols which are the features of the executing Emacs.") (debug-on-error "Non-nil means enter debugger if an error is signaled.") (default-directory "Name of default directory of current buffer.") (load-file-name "Full name of file being loaded by") (noninteractive "Non-nil means Emacs is running without interactive terminal.") (inhibit-quit "Non-nil inhibits C-g quitting from happening immediately.") (print-length "Maximum length of list to print before abbreviating.") (print-level "Maximum depth of list nesting to print before abbreviating.") (standard-output "Output stream") (buffer-read-only "Non-nil if this buffer is read-only.") (kill-ring "List of killed text sequences.") (kill-ring-yank-pointer "The tail of the kill ring whose car is the last thing yanked.") (last-command "The last command executed.") (lexical-binding "Whether to use lexical binding when evaluating code.") (load-prefer-newer "Non-nil means")))	OK ((load-history t t) (features t t) (debug-on-error t t) (default-directory t t) (load-file-name t t) (noninteractive t t) (inhibit-quit t t) (print-length t t) (print-level t t) (standard-output t t) (buffer-read-only t t) (kill-ring t t) (kill-ring-yank-pointer t t) (last-command t t) (lexical-binding t t) (load-prefer-newer t t))
8	(mapcar (lambda (entry) (let* ((sym (car entry)) (prefix (cadr entry)) (doc (documentation-property sym 'variable-documentation)) (first (and (stringp doc) (car (split-string doc (string 10) t))))) (list sym (stringp doc) (and (stringp first) (string-prefix-p prefix first))))) '((abbrev-mode "Non-nil if Abbrev mode is enabled.") (after-change-functions "List of functions to call after each text change.") (before-change-functions "List of functions to call before each text change.") (auto-fill-function "Function called (if non-nil) to perform auto-fill.") (case-fold-search "Non-nil if searches and matches should ignore case.") (buffer-file-name "Name of file visited in current buffer, or nil if not visiting a file.") (buffer-undo-list "List of undo entries in current buffer.") (fill-column "Column beyond which automatic line-wrapping should happen.") (current-prefix-arg "The value of the prefix argument for this editing command.") (this-command "The command now being executed.") (undo-limit "Keep no more undo information once it exceeds this size.") (undo-strong-limit "Don") (select-active-regions "If non-nil, any active region automatically sets the primary selection.") (transient-mark-mode "Non-nil if Transient Mark mode is enabled.") (exec-path "List of directories to search programs to run in subprocesses.") (shell-file-name "File name to load inferior shells from.") (tool-bar-mode "Non-nil if Tool-Bar mode is enabled.") (tab-bar-mode "Non-nil if Tab-Bar mode is enabled.") (display-line-numbers "Non-nil means display line numbers.") (truncate-lines "Non-nil means do not display continuation lines.") (word-wrap "Non-nil means to use word-wrapping for continuation lines.") (user-full-name "The full name of the user logged in.") (window-system "Name of window system through which the selected frame is displayed.") (completion-ignore-case "Non-nil means") (comment-end-can-be-escaped "Non-nil means an escaped ender inside a comment") (debug-on-quit "Non-nil means enter debugger if quit is signaled (C-g, for example).") (major-mode "Symbol for current buffer") (mode-line-format "Template for displaying mode line for a window")))	OK ((abbrev-mode t t) (after-change-functions t t) (before-change-functions t t) (auto-fill-function t t) (case-fold-search t t) (buffer-file-name t t) (buffer-undo-list t t) (fill-column t t) (current-prefix-arg t t) (this-command t t) (undo-limit t t) (undo-strong-limit t t) (select-active-regions t t) (transient-mark-mode t t) (exec-path t t) (shell-file-name t t) (tool-bar-mode t t) (tab-bar-mode t t) (display-line-numbers t t) (truncate-lines t t) (word-wrap t t) (user-full-name t t) (window-system t t) (completion-ignore-case t t) (comment-end-can-be-escaped t t) (debug-on-quit t t) (major-mode t t) (mode-line-format t t))
9	(progn (put 'vm-docprop-symbol 'variable-documentation "doc") (documentation-property 'vm-docprop-symbol 'variable-documentation))	OK "doc"
10	(progn (put 'vm-docprop-symbol 'variable-documentation 9) (documentation-property 'vm-docprop-symbol 'variable-documentation))	OK nil
11	(progn (put 'vm-docprop-symbol 'function-documentation "fdoc") (documentation-property 'vm-docprop-symbol 'function-documentation))	OK "fdoc"
12	(documentation-property 'vm-docprop-symbol 1)	OK nil
13	(progn (put 'vm-docprop-symbol 'x "v") (documentation-property 'vm-docprop-symbol 'x t))	OK "v"
14	(progn (put 'vm-docprop-symbol 'variable-documentation '(1 2)) (condition-case err (documentation-property 'vm-docprop-symbol 'variable-documentation) (error err)))	OK (invalid-function 1)
15	(progn (put 'vm-docprop-symbol 'variable-documentation '(identity "doc")) (documentation-property 'vm-docprop-symbol 'variable-documentation))	OK "doc"
16	(progn (put 'vm-docprop-symbol 'variable-documentation 'vm-docprop-unbound) (condition-case err (documentation-property 'vm-docprop-symbol 'variable-documentation) (error err)))	OK (void-variable vm-docprop-unbound)
17	(progn (put 'vm-docprop-symbol 'variable-documentation 't) (documentation-property 'vm-docprop-symbol 'variable-documentation))	OK t
18	(progn (put 'vm-docprop-symbol 'variable-documentation [1 2]) (documentation-property 'vm-docprop-symbol 'variable-documentation))	OK [1 2]
19	(progn (put 'vm-docprop-symbol 'variable-documentation 1.5) (documentation-property 'vm-docprop-symbol 'variable-documentation))	OK 1.5
20	(progn (put 'vm-docprop-symbol 'variable-documentation '(progn "doc")) (documentation-property 'vm-docprop-symbol 'variable-documentation t))	OK "doc"
21	(condition-case err (documentation-property 1 'variable-documentation) (error (car err)))	OK wrong-type-argument
22	(condition-case err (documentation-property 'vm-docprop-symbol) (error (car err)))	OK wrong-number-of-arguments
