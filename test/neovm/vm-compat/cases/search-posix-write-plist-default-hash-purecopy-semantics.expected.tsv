1	(fboundp 'search-forward-regexp)	OK t
2	(fboundp 'search-backward-regexp)	OK t
3	(fboundp 'posix-looking-at)	OK t
4	(fboundp 'posix-string-match)	OK t
5	(fboundp 'write-char)	OK t
6	(fboundp 'purecopy)	OK t
7	(fboundp 'plist-member)	OK t
8	(fboundp 'secure-hash-algorithms)	OK t
9	(fboundp 'set-default-toplevel-value)	OK t
10	(func-arity 'search-forward-regexp)	OK (1 . 4)
11	(func-arity 'search-backward-regexp)	OK (1 . 4)
12	(func-arity 'posix-looking-at)	OK (1 . 2)
13	(func-arity 'posix-string-match)	OK (2 . 4)
14	(func-arity 'write-char)	OK (1 . 2)
15	(func-arity 'purecopy)	OK (1 . 1)
16	(func-arity 'plist-member)	OK (2 . 3)
17	(func-arity 'secure-hash-algorithms)	OK (0 . 0)
18	(func-arity 'set-default-toplevel-value)	OK (2 . 2)
19	(subr-arity (symbol-function 'search-forward-regexp))	OK (1 . 4)
20	(subr-arity (symbol-function 'search-backward-regexp))	OK (1 . 4)
21	(subr-arity (symbol-function 'posix-looking-at))	OK (1 . 2)
22	(subr-arity (symbol-function 'posix-string-match))	OK (2 . 4)
23	(subr-arity (symbol-function 'write-char))	OK (1 . 2)
24	(subr-arity (symbol-function 'purecopy))	OK (1 . 1)
25	(subr-arity (symbol-function 'plist-member))	OK (2 . 3)
26	(subr-arity (symbol-function 'secure-hash-algorithms))	OK (0 . 0)
27	(subr-arity (symbol-function 'set-default-toplevel-value))	OK (2 . 2)
28	(condition-case err (search-forward-regexp) (error err))	OK (wrong-number-of-arguments search-forward-regexp 0)
29	(condition-case err (search-backward-regexp) (error err))	OK (wrong-number-of-arguments search-backward-regexp 0)
30	(condition-case err (posix-looking-at) (error err))	OK (wrong-number-of-arguments posix-looking-at 0)
31	(condition-case err (posix-looking-at "a" nil nil) (error err))	OK (wrong-number-of-arguments posix-looking-at 3)
32	(condition-case err (posix-string-match) (error err))	OK (wrong-number-of-arguments posix-string-match 0)
33	(condition-case err (posix-string-match "a" 1) (error err))	OK (wrong-type-argument stringp 1)
34	(condition-case err (write-char) (error err))	OK (wrong-number-of-arguments write-char 0)
35	(condition-case err (write-char 65 nil nil) (error err))	OK (wrong-number-of-arguments write-char 3)
36	(condition-case err (write-char 'x) (error err))	OK (wrong-type-argument fixnump x)
37	(condition-case err (purecopy) (error err))	OK (wrong-number-of-arguments purecopy 0)
38	(condition-case err (purecopy 1 2) (error err))	OK (wrong-number-of-arguments purecopy 2)
39	(condition-case err (plist-member :a) (error err))	OK (wrong-number-of-arguments plist-member 1)
40	(condition-case err (plist-member '(:a 1) :a nil nil) (error err))	OK (wrong-number-of-arguments plist-member 4)
41	(condition-case err (secure-hash-algorithms nil) (error err))	OK (wrong-number-of-arguments secure-hash-algorithms 1)
42	(condition-case err (set-default-toplevel-value 1 2) (error err))	OK (wrong-type-argument symbolp 1)
43	(condition-case err (set-default-toplevel-value 'x) (error err))	OK (wrong-number-of-arguments set-default-toplevel-value 1)
44	(with-temp-buffer (insert "ab12cd34") (goto-char (point-min)) (list (search-forward-regexp "[0-9]" nil t) (match-string 0) (search-forward-regexp "[0-9]" nil t) (match-string 0)))	OK (4 "1" 5 "2")
45	(with-temp-buffer (insert "ab12cd34") (goto-char (point-max)) (list (search-backward-regexp "[0-9]" nil t) (match-string 0) (search-backward-regexp "[0-9]" nil t) (match-string 0)))	OK (8 "4" 7 "3")
46	(with-temp-buffer (insert "Abc") (goto-char (point-min)) (let ((case-fold-search t)) (list (posix-looking-at "abc") (match-string 0) (match-beginning 0) (match-end 0))))	OK (t "Abc" 1 4)
47	(with-temp-buffer (insert "Abc") (goto-char (point-min)) (let ((case-fold-search nil)) (posix-looking-at "abc")))	OK nil
48	(list (posix-string-match "b+" "abbb" 0) (match-string 0 "abbb") (posix-string-match "b+" "abbb" 2) (match-string 0 "abbb") (posix-string-match "z+" "abbb"))	OK (1 "bbb" 2 "bb" nil)
49	(list (write-char 65) (condition-case err (write-char 65 1) (error err)) (with-temp-buffer (let ((standard-output (current-buffer))) (list (write-char 66) (string-to-list (buffer-string))))))	OK (65 (invalid-function 1) (66 (66)))
50	(let* ((x (list 1 2)) (y (purecopy x))) (list (eq x y) y))	OK (t (1 2))
51	(list (plist-member '(:a 1 :b 2) :a) (plist-member '(:a 1 :b 2) :c) (plist-member '(:a . 1) :a) (condition-case err (plist-member '(:b . 1) :a) (error err)) (plist-member '(:a 1 :b 2) :b #'eq) (condition-case err (plist-member '(:a 1) :a 1) (error err)))	OK ((:a 1 :b 2) nil (:a . 1) (wrong-type-argument plistp (:b . 1)) (:b 2) (invalid-function 1))
52	(secure-hash-algorithms)	OK (md5 sha1 sha224 sha256 sha384 sha512)
53	(let ((sym (make-symbol "neovm-case-var"))) (list (default-boundp sym) (set-default-toplevel-value sym 7) (default-boundp sym) (default-toplevel-value sym)))	OK (nil nil t 7)
