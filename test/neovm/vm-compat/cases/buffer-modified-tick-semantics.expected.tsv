1	(fboundp 'buffer-modified-tick)	OK t
2	(subrp (symbol-function 'buffer-modified-tick))	OK t
3	(subr-arity (symbol-function 'buffer-modified-tick))	OK (0 . 1)
4	(fboundp 'buffer-chars-modified-tick)	OK t
5	(subrp (symbol-function 'buffer-chars-modified-tick))	OK t
6	(subr-arity (symbol-function 'buffer-chars-modified-tick))	OK (0 . 1)
7	(with-temp-buffer (list 'ticks (buffer-modified-tick) (buffer-chars-modified-tick) (progn (insert "x") (buffer-modified-tick)) (buffer-chars-modified-tick) (progn (set-buffer-modified-p nil) (buffer-modified-tick)) (buffer-chars-modified-tick) (progn (delete-region (point-min) (point-max)) (buffer-modified-tick)) (buffer-chars-modified-tick)))	OK (ticks 1 1 2 2 2 2 3 3)
8	(with-temp-buffer (list 'nil-arg (buffer-modified-tick nil) (buffer-chars-modified-tick nil)))	OK (nil-arg 1 1)
9	(let ((b (generate-new-buffer " *ticks-dead*"))) (kill-buffer b) (list 'dead (buffer-modified-tick b) (buffer-chars-modified-tick b)))	OK (dead 1 1)
10	(condition-case err (buffer-modified-tick 'x) (error (list 'mod-type (car err) (cdr err))))	OK (mod-type wrong-type-argument (bufferp x))
11	(condition-case err (buffer-chars-modified-tick 'x) (error (list 'chars-type (car err) (cdr err))))	OK (chars-type wrong-type-argument (bufferp x))
12	(condition-case err (buffer-modified-tick nil nil) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
13	(condition-case err (buffer-chars-modified-tick nil nil) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
