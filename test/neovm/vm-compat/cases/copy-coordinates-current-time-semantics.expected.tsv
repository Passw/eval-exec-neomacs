1	(list (list 'copy-keymap (fboundp 'copy-keymap) (func-arity 'copy-keymap) (commandp 'copy-keymap)) (list 'copy-category-table (fboundp 'copy-category-table) (func-arity 'copy-category-table) (commandp 'copy-category-table)) (list 'coordinates-in-window-p (fboundp 'coordinates-in-window-p) (func-arity 'coordinates-in-window-p) (commandp 'coordinates-in-window-p)) (list 'current-cpu-time (fboundp 'current-cpu-time) (func-arity 'current-cpu-time) (commandp 'current-cpu-time)) (list 'current-idle-time (fboundp 'current-idle-time) (func-arity 'current-idle-time) (commandp 'current-idle-time)))	OK ((copy-keymap t (1 . 1) nil) (copy-category-table t (0 . 1) nil) (coordinates-in-window-p t (2 . 2) nil) (current-cpu-time t (0 . 0) nil) (current-idle-time t (0 . 0) nil))
2	(let* ((k (make-sparse-keymap)) (_ (define-key k (kbd "a") 'foo)) (c (copy-keymap k))) (list (keymapp c) (eq c k) (eq (lookup-key c (kbd "a")) 'foo)))	OK (t nil t)
3	(let* ((k (make-sparse-keymap)) (_ (define-key k (kbd "C-x a") 'foo)) (c (copy-keymap k))) (define-key c (kbd "C-x b") 'bar) (list (lookup-key k (kbd "C-x b")) (lookup-key c (kbd "C-x b")) (lookup-key k (kbd "C-x a")) (lookup-key c (kbd "C-x a"))))	OK (nil bar foo foo)
4	(condition-case err (copy-keymap nil) (error err))	OK (wrong-type-argument keymapp nil)
5	(let* ((std (standard-category-table)) (cpy (copy-category-table))) (list (category-table-p cpy) (eq cpy std) (eq (char-table-subtype cpy) 'category-table)))	OK (t nil t)
6	(let* ((tbl (make-category-table)) (cpy (copy-category-table tbl))) (list (category-table-p cpy) (eq cpy tbl) (eq (char-table-subtype cpy) 'category-table)))	OK (t nil t)
7	(condition-case err (copy-category-table 1) (error err))	OK (wrong-type-argument category-table-p 1)
8	(coordinates-in-window-p '(1 . 2) nil)	OK (1 . 2)
9	(coordinates-in-window-p '(9999 . 9999) nil)	OK nil
10	(condition-case err (coordinates-in-window-p 1 nil) (error err))	OK (wrong-type-argument consp 1)
11	(condition-case err (coordinates-in-window-p '(a . 1) nil) (error err))	OK (wrong-type-argument numberp a)
12	(condition-case err (coordinates-in-window-p '(1 2) nil) (error err))	OK (wrong-type-argument numberp (2))
13	(condition-case err (coordinates-in-window-p '(1 . 2) 'foo) (error err))	OK (wrong-type-argument window-live-p foo)
14	(condition-case err (coordinates-in-window-p '(1 . 2)) (error err))	OK (wrong-number-of-arguments coordinates-in-window-p 1)
15	(let ((cpu (current-cpu-time))) (list (consp cpu) (integerp (car cpu)) (eq (cdr cpu) 1000000)))	OK (t t t)
16	(condition-case err (current-cpu-time 1) (error err))	OK (wrong-number-of-arguments current-cpu-time 1)
17	(current-idle-time)	OK nil
18	(condition-case err (current-idle-time 1) (error err))	OK (wrong-number-of-arguments current-idle-time 1)
