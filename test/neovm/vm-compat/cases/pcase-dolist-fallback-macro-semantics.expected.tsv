1	(fboundp 'pcase-dolist)	OK t
2	(macrop 'pcase-dolist)	OK (t)
3	(functionp 'pcase-dolist)	OK nil
4	(autoloadp (symbol-function 'pcase-dolist))	OK t
5	(autoloadp (indirect-function 'pcase-dolist))	OK t
6	(let ((f (symbol-function 'pcase-dolist))) (list (car f) (nth 1 f) (nth 3 f) (nth 4 f)))	OK (autoload "pcase" nil t)
7	(let ((f (indirect-function 'pcase-dolist))) (list (car f) (nth 1 f) (nth 3 f) (nth 4 f)))	OK (autoload "pcase" nil t)
8	(let ((d (nth 2 (symbol-function 'pcase-dolist)))) (list (length d) (string-match-p (string 10) d) (car (split-string d (string 10))) (car (cdr (split-string d (string 10))))))	OK (593 77 "Eval BODY once for each set of bindings defined by PATTERN and LIST elements." "PATTERN should be a `pcase' pattern describing the structure of")
9	(func-arity 'pcase-dolist)	OK (1 . many)
10	(macroexpand '(pcase-dolist (x '(1 2 3)) x))	OK (let ((tail '(1 2 3))) (while tail (let ((x (car tail))) x (setq tail (cdr tail)))))
11	(macroexpand '(pcase-dolist (`(,k ,v) '((a 1) (b 2))) (list k v)))	OK (let ((tail '((a 1) (b 2)))) (while tail (let ((x0 (car tail))) (pcase-let* ((`(,k ,v) x0)) (list k v)) (setq tail (cdr tail)))))
12	(macroexpand '(pcase-dolist (x '(1 2) :done) x))	OK (let ((tail '(1 2))) (while tail (let ((x (car tail))) x (setq tail (cdr tail)))) :done)
13	(condition-case err (macroexpand '(pcase-dolist)) (error err))	OK (wrong-number-of-arguments (1 . 1) 0)
14	(condition-case err (macroexpand '(pcase-dolist 1)) (error err))	OK (wrong-type-argument listp 1)
15	(condition-case err (macroexpand '(pcase-dolist (x))) (error err))	OK (wrong-number-of-arguments (2 . 3) 1)
16	(condition-case err (macroexpand '(pcase-dolist x x)) (error err))	OK (wrong-type-argument listp x)
17	(condition-case err (macroexpand '(pcase-dolist (x '(1 2) . z) x)) (error err))	OK (wrong-type-argument listp z)
18	(let ((a (func-arity 'pcase-dolist)) (b (condition-case err (func-arity (indirect-function 'pcase-dolist)) (error err))) (c (autoloadp (indirect-function 'pcase-dolist)))) (list a b c))	OK ((1 . many) (1 . many) nil)
19	(let ((acc nil)) (pcase-dolist (x '(1 2 3)) (setq acc (cons x acc))) (nreverse acc))	OK (1 2 3)
20	(let ((acc nil)) (pcase-dolist (x '(1 2) (nreverse acc)) (setq acc (cons x acc))))	OK (1 2)
21	(condition-case err (pcase-dolist (x) x) (error err))	OK (wrong-number-of-arguments (2 . 3) 1)
22	(condition-case err (pcase-dolist (x '(1 2) :r :extra) x) (error err))	OK (wrong-number-of-arguments (2 . 3) 4)
23	(condition-case err (pcase-dolist (x '(1) . z) x) (error err))	OK (wrong-type-argument listp z)
24	(condition-case err (pcase-dolist (x 1) x) (error err))	OK (wrong-type-argument listp 1)
25	(condition-case err (pcase-dolist (x '(1 . 2)) x) (error err))	OK (wrong-type-argument listp 2)
