1	(fboundp 'pcase-dolist)	OK t
2	(macrop 'pcase-dolist)	OK (t)
3	(functionp 'pcase-dolist)	OK nil
4	(autoloadp (symbol-function 'pcase-dolist))	OK t
5	(autoloadp (indirect-function 'pcase-dolist))	OK t
6	(let ((f (symbol-function 'pcase-dolist))) (list (car f) (nth 1 f) (nth 3 f) (nth 4 f)))	OK (autoload "pcase" nil t)
7	(let ((f (indirect-function 'pcase-dolist))) (list (car f) (nth 1 f) (nth 3 f) (nth 4 f)))	OK (autoload "pcase" nil t)
8	(func-arity 'pcase-dolist)	OK (1 . many)
9	(macroexpand '(pcase-dolist (x '(1 2 3)) x))	OK (let ((tail '(1 2 3))) (while tail (let ((x (car tail))) x (setq tail (cdr tail)))))
10	(macroexpand '(pcase-dolist (`(,k ,v) '((a 1) (b 2))) (list k v)))	OK (let ((tail '((a 1) (b 2)))) (while tail (let ((x0 (car tail))) (pcase-let* ((`(,k ,v) x0)) (list k v)) (setq tail (cdr tail)))))
11	(condition-case err (macroexpand '(pcase-dolist)) (error err))	OK (wrong-number-of-arguments (1 . 1) 0)
12	(condition-case err (macroexpand '(pcase-dolist 1)) (error err))	OK (wrong-type-argument listp 1)
13	(condition-case err (macroexpand '(pcase-dolist (x))) (error err))	OK (wrong-number-of-arguments (2 . 3) 1)
14	(condition-case err (macroexpand '(pcase-dolist x x)) (error err))	OK (wrong-type-argument listp x)
15	(let ((a (func-arity 'pcase-dolist)) (b (condition-case err (func-arity (indirect-function 'pcase-dolist)) (error err))) (c (autoloadp (indirect-function 'pcase-dolist)))) (list a b c))	OK ((1 . many) (1 . many) nil)
16	(let ((acc nil)) (pcase-dolist (x '(1 2 3)) (setq acc (cons x acc))) (nreverse acc))	OK (1 2 3)
