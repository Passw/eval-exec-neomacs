1	(mapcar (lambda (s) (list s (fboundp s) (subr-arity (symbol-function s)))) '(window-at window-parent window-left-child window-top-child window-next-sibling window-prev-sibling))	OK ((window-at t (2 . 3)) (window-parent t (0 . 1)) (window-left-child t (0 . 1)) (window-top-child t (0 . 1)) (window-next-sibling t (0 . 1)) (window-prev-sibling t (0 . 1)))
2	(let ((w (selected-window))) (list (or (null (funcall #'window-parent w)) (windowp (funcall #'window-parent w))) (or (null (apply #'window-parent (list w))) (windowp (apply #'window-parent (list w)))) (let ((fn (indirect-function 'window-parent))) (or (null (funcall fn w)) (windowp (funcall fn w))))))	OK (t t t)
3	(let ((w (selected-window))) (list (or (null (funcall #'window-left-child w)) (windowp (funcall #'window-left-child w))) (or (null (apply #'window-left-child (list w))) (windowp (apply #'window-left-child (list w)))) (let ((fn (indirect-function 'window-left-child))) (or (null (funcall fn w)) (windowp (funcall fn w)))) (or (null (funcall #'window-top-child w)) (windowp (funcall #'window-top-child w))) (or (null (apply #'window-top-child (list w))) (windowp (apply #'window-top-child (list w)))) (let ((fn (indirect-function 'window-top-child))) (or (null (funcall fn w)) (windowp (funcall fn w))))))	OK (t t t t t t)
4	(let ((w (selected-window))) (list (or (null (funcall #'window-next-sibling w)) (windowp (funcall #'window-next-sibling w))) (or (null (apply #'window-next-sibling (list w))) (windowp (apply #'window-next-sibling (list w)))) (let ((fn (indirect-function 'window-next-sibling))) (or (null (funcall fn w)) (windowp (funcall fn w)))) (or (null (funcall #'window-prev-sibling w)) (windowp (funcall #'window-prev-sibling w))) (or (null (apply #'window-prev-sibling (list w))) (windowp (apply #'window-prev-sibling (list w)))) (let ((fn (indirect-function 'window-prev-sibling))) (or (null (funcall fn w)) (windowp (funcall fn w))))))	OK (t t t t t t)
5	(list (or (null (funcall #'window-at 0 0)) (windowp (funcall #'window-at 0 0))) (or (null (apply #'window-at '(0 0))) (windowp (apply #'window-at '(0 0)))) (let ((fn (indirect-function 'window-at))) (or (null (funcall fn 0 0)) (windowp (funcall fn 0 0)))))	OK (t t t)
6	(list (condition-case err (funcall #'window-parent 999999) (error (car err))) (condition-case err (apply #'window-parent '(999999)) (error (car err))) (condition-case err (funcall #'window-left-child 999999) (error (car err))) (condition-case err (funcall #'window-top-child 999999) (error (car err))) (condition-case err (funcall #'window-next-sibling 999999) (error (car err))) (condition-case err (funcall #'window-prev-sibling 999999) (error (car err))) (condition-case err (funcall #'window-at (selected-window) nil) (error (car err))))	OK (wrong-type-argument wrong-type-argument wrong-type-argument wrong-type-argument wrong-type-argument wrong-type-argument wrong-type-argument)
7	(list (condition-case err (funcall #'window-parent nil nil) (error (car err))) (condition-case err (apply #'window-parent '(nil nil)) (error (car err))) (condition-case err (funcall #'window-left-child nil nil) (error (car err))) (condition-case err (funcall #'window-top-child nil nil) (error (car err))) (condition-case err (funcall #'window-next-sibling nil nil) (error (car err))) (condition-case err (funcall #'window-prev-sibling nil nil) (error (car err))) (condition-case err (funcall #'window-at) (error (car err))) (condition-case err (funcall #'window-at nil nil) (error (car err))))	OK (wrong-number-of-arguments wrong-number-of-arguments wrong-number-of-arguments wrong-number-of-arguments wrong-number-of-arguments wrong-number-of-arguments wrong-number-of-arguments wrong-type-argument)
