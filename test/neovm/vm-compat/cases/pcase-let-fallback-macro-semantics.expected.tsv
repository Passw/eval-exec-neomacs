1	(fboundp 'pcase-let)	OK t
2	(fboundp 'pcase-let*)	OK t
3	(macrop 'pcase-let)	OK (t)
4	(macrop 'pcase-let*)	OK (t)
5	(functionp 'pcase-let)	OK nil
6	(functionp 'pcase-let*)	OK nil
7	(autoloadp (symbol-function 'pcase-let))	OK t
8	(autoloadp (indirect-function 'pcase-let))	OK t
9	(let ((f (symbol-function 'pcase-let))) (list (car f) (nth 1 f) (nth 3 f) (nth 4 f)))	OK (autoload "pcase" nil t)
10	(let ((d (nth 2 (symbol-function 'pcase-let)))) (list (stringp d) (string-match-p "Like `let'" d)))	OK (t 0)
11	(autoloadp (symbol-function 'pcase-let*))	OK t
12	(autoloadp (indirect-function 'pcase-let*))	OK t
13	(func-arity 'pcase-let)	OK (1 . many)
14	(func-arity 'pcase-let*)	OK (1 . many)
15	(let ((a (func-arity 'pcase-let)) (b (condition-case err (func-arity (indirect-function 'pcase-let)) (error err))) (c (autoloadp (indirect-function 'pcase-let)))) (list a b c))	OK ((1 . many) (1 . many) nil)
16	(let ((a (func-arity 'pcase-let*)) (b (condition-case err (func-arity (indirect-function 'pcase-let*)) (error err))) (c (autoloadp (indirect-function 'pcase-let*)))) (list a b c))	OK ((1 . many) (1 . many) nil)
17	(macroexpand '(pcase-let ((x 1)) x))	OK (let* ((x 1)) x)
18	(macroexpand '(pcase-let ((x 1) (y x)) (list x y)))	OK (let ((x 1) (y x)) (pcase-let* nil (list x y)))
19	(macroexpand '(pcase-let* ((x 1) (y x)) (list x y)))	OK (let* ((x 1) (y x)) (list x y))
20	(macroexpand '(pcase-let ((x 1) (`(,a ,b) '(2 3))) (list x a b)))	OK (let ((x 1) (x1 '(2 3))) (pcase-let* ((`(,a ,b) x1)) (list x a b)))
21	(condition-case err (macroexpand '(pcase-let)) (error err))	OK (wrong-number-of-arguments (1 . 1) 0)
22	(condition-case err (macroexpand '(pcase-let*)) (error err))	OK (wrong-number-of-arguments (1 . 1) 0)
23	(condition-case err (macroexpand '(pcase-let x x)) (error err))	OK (wrong-type-argument listp x)
24	(condition-case err (macroexpand '(pcase-let* x x)) (error err))	OK (wrong-type-argument listp x)
25	(pcase-let ((x 10) (y 20)) (+ x y))	OK 30
26	(pcase-let* ((x 10) (y (+ x 5))) y)	OK 15
