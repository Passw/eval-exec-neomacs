; call-interactively and command-execute should honor lambda interactive specs.

; call-interactively uses current-prefix-arg for "p".
(let ((f (lambda (n) (interactive "p") n))
      (current-prefix-arg '(4)))
  (call-interactively f))

; command-execute uses prefix-arg for "p"/"P" (not current-prefix-arg).
(let ((f (lambda (n) (interactive "p") n))
      (current-prefix-arg '(4)))
  (command-execute f))
(let ((f (lambda (n) (interactive "p") n))
      (current-prefix-arg '(4))
      (prefix-arg '(5)))
  (command-execute f))
(let ((f (lambda (arg) (interactive "P") arg))
      (current-prefix-arg '(4))
      (prefix-arg '(5)))
  (command-execute f))

; call-interactively still reads "P" from current-prefix-arg.
(let ((f (lambda (arg) (interactive "P") arg))
      (current-prefix-arg '(4))
      (prefix-arg '(5)))
  (call-interactively f))

; quoted lambda command designators are callable.
(let ((current-prefix-arg 3))
  (call-interactively '(lambda (n) (interactive "p") n)))

; expression interactive forms evaluate and must produce a list.
(call-interactively (lambda (x) (interactive (list 7)) x))
(command-execute (lambda (x) (interactive (list 8)) x))
(condition-case err
    (call-interactively (lambda (x) (interactive 7) x))
  (error err))

; "r" reads region boundaries; missing mark signals an error.
(with-temp-buffer
  (insert "abc")
  (goto-char 2)
  (set-mark 3)
  (call-interactively (lambda (b e) (interactive "r") (list b e))))
(with-temp-buffer
  (insert "abc")
  (goto-char 2)
  (set-mark 3)
  (command-execute (lambda (b e) (interactive "r") (list b e))))
(with-temp-buffer
  (insert "abc")
  (goto-char 2)
  (condition-case err
      (call-interactively (lambda (b e) (interactive "r") (list b e)))
    (error err)))

; "s" prompts from stdin and hits EOF in batch.
(condition-case err
    (call-interactively (lambda (s) (interactive "sPrompt: ") s))
  (error err))
(condition-case err
    (command-execute (lambda (s) (interactive "sPrompt: ") s))
  (error err))
